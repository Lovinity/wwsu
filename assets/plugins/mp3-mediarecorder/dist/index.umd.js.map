{"version":3,"file":"index.umd.js","sources":["../node_modules/event-target-shim/dist/event-target-shim.mjs","../src/types/post-message.type.ts","../src/recorder/index.ts"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    if (retv == null) {\n        throw new TypeError(\n            \"'this' is expected an Event object, but got another value.\"\n        )\n    }\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { EventTarget, defineEventAttribute };\n//# sourceMappingURL=event-target-shim.mjs.map\n","import { Mp3WorkerEncodingConfig } from './config.type';\n\nexport enum PostMessageType {\n    DATA_AVAILABLE = 'DATA_AVAILABLE',\n    START_RECORDING = 'START_RECORDING',\n    STOP_RECORDING = 'STOP_RECORDING',\n    ERROR = 'ERROR',\n    BLOB_READY = 'BLOB_READY',\n    WORKER_RECORDING = 'WORKER_RECORDING',\n}\nexport const errorMessage = (error: string) => ({ type: PostMessageType.ERROR as PostMessageType.ERROR, error });\nexport const startRecordingMessage = (config: Mp3WorkerEncodingConfig) => ({\n    type: PostMessageType.START_RECORDING as PostMessageType.START_RECORDING,\n    config,\n});\nexport const workerRecordingMessage = () => ({\n    type: PostMessageType.WORKER_RECORDING as PostMessageType.WORKER_RECORDING,\n});\n\nexport const dataAvailableMessage = (data: ArrayLike<number>) => ({\n    type: PostMessageType.DATA_AVAILABLE as PostMessageType.DATA_AVAILABLE,\n    data,\n});\n\nexport const blobReadyMessage = (blob: Blob) => ({\n    type: PostMessageType.BLOB_READY as PostMessageType.BLOB_READY,\n    blob,\n});\nexport const stopRecordingMessage = () => ({\n    type: PostMessageType.STOP_RECORDING as PostMessageType.STOP_RECORDING,\n});\n\nexport type WorkerPostMessage = ReturnType<\n    | typeof errorMessage\n    | typeof startRecordingMessage\n    | typeof dataAvailableMessage\n    | typeof blobReadyMessage\n    | typeof stopRecordingMessage\n    | typeof workerRecordingMessage\n>;\n","import { defineEventAttribute, EventTarget } from 'event-target-shim';\nimport {\n    dataAvailableMessage,\n    PostMessageType,\n    startRecordingMessage,\n    stopRecordingMessage,\n    WorkerPostMessage,\n} from '../types/post-message.type';\n\nexport interface Mp3MediaRecorderOptions extends MediaRecorderOptions {\n    worker: Worker;\n    audioContext?: AudioContext;\n}\n\nconst MP3_MIME_TYPE = 'audio/mpeg';\nconst SafeAudioContext: typeof AudioContext = (window as any).AudioContext || (window as any).webkitAudioContext;\nconst createGain = (ctx: AudioContext) => (ctx.createGain || (ctx as any).createGainNode).call(ctx);\nconst createScriptProcessor = (ctx: AudioContext) =>\n    (ctx.createScriptProcessor || (ctx as any).createJavaScriptNode).call(ctx, 4096, 1, 1);\n\nexport class Mp3MediaRecorder extends EventTarget {\n    stream: MediaStream;\n    mimeType = MP3_MIME_TYPE;\n    state: RecordingState = 'inactive';\n    audioBitsPerSecond = 0;\n    videoBitsPerSecond = 0;\n\n    private audioContext: AudioContext;\n    private sourceNode: MediaStreamAudioSourceNode;\n    private gainNode: GainNode;\n    private processorNode: ScriptProcessorNode;\n    private worker: Worker;\n    private isInternalAudioContext = false;\n\n    static isTypeSupported = (mimeType: string) => mimeType === MP3_MIME_TYPE;\n\n    constructor(stream: MediaStream, { audioContext, worker }: Mp3MediaRecorderOptions) {\n        super();\n\n        if (!worker) {\n            throw new Error('No worker provided in Mp3MediaRecorder constructor.');\n        }\n        this.stream = stream;\n        this.isInternalAudioContext = !audioContext;\n        this.audioContext = audioContext || new SafeAudioContext();\n        this.worker = worker;\n        this.sourceNode = this.audioContext.createMediaStreamSource(stream);\n        this.gainNode = createGain(this.audioContext);\n        this.gainNode.gain.value = 1;\n        this.processorNode = createScriptProcessor(this.audioContext);\n        this.sourceNode.connect(this.gainNode);\n        this.gainNode.connect(this.processorNode);\n        this.worker.onmessage = this.onWorkerMessage;\n    }\n\n    start(): void {\n        if (this.state !== 'inactive') {\n            throw this.getStateError('start');\n        }\n        this.processorNode.onaudioprocess = (event) => {\n            this.worker.postMessage(dataAvailableMessage(event.inputBuffer.getChannelData(0)));\n        };\n        this.processorNode.connect(this.audioContext.destination);\n        if (this.audioContext.state === 'closed') {\n            this.audioContext = new AudioContext();\n        } else if (this.audioContext.state === 'suspended') {\n            this.audioContext.resume();\n        }\n        this.worker.postMessage(startRecordingMessage({ sampleRate: this.audioContext.sampleRate }));\n    }\n\n    stop(): void {\n        if (this.state === 'inactive') {\n            throw this.getStateError('stop');\n        }\n        this.processorNode.disconnect();\n        if (this.isInternalAudioContext) {\n            this.audioContext.close();\n        }\n        this.worker.postMessage(stopRecordingMessage());\n    }\n\n    pause(): void {\n        if (this.state === 'inactive') {\n            throw this.getStateError('pause');\n        }\n        this.audioContext.suspend().then(() => {\n            this.state = 'paused';\n            this.dispatchEvent(new Event('pause'));\n        });\n    }\n\n    resume(): void {\n        if (this.state === 'inactive') {\n            throw this.getStateError('resume');\n        }\n        this.audioContext.resume().then(() => {\n            this.state = 'recording';\n            this.dispatchEvent(new Event('resume'));\n        });\n    }\n\n    requestData(): void {\n        // not implemented, dataavailable event only fires when encoding is finished\n    }\n\n    private getStateError(method: string) {\n        return new Error(\n            `Failed to execute '${method}' on 'MediaRecorder': The MediaRecorder's state is '${this.state}'.`\n        );\n    }\n\n    private onWorkerMessage = (event: MessageEvent): void => {\n        const message: WorkerPostMessage = event.data;\n\n        switch (message.type) {\n            case PostMessageType.WORKER_RECORDING: {\n                const event = new Event('start');\n                this.dispatchEvent(event);\n                this.state = 'recording';\n                break;\n            }\n            case PostMessageType.ERROR: {\n                const error = new Error(message.error) as DOMException;\n                const errEvent = new Event('error');\n                (errEvent as any).error = error;\n                this.dispatchEvent(errEvent);\n                this.state = 'inactive';\n                break;\n            }\n            case PostMessageType.BLOB_READY: {\n                const stopEvent = new Event('stop');\n                const fallbackDataEvent = new Event('dataavailable');\n                (fallbackDataEvent as any).data = message.blob;\n                (fallbackDataEvent as any).timecode = Date.now();\n                const dataEvent = window.BlobEvent\n                    ? new BlobEvent('dataavailable', {\n                          data: message.blob,\n                          timecode: Date.now(),\n                      })\n                    : fallbackDataEvent;\n                this.dispatchEvent(dataEvent);\n                this.dispatchEvent(stopEvent);\n                this.state = 'inactive';\n                break;\n            }\n            case PostMessageType.ERROR: {\n                throw new Error(message.error);\n            }\n        }\n    };\n}\n\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'start');\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'stop');\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'pause');\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'resume');\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'dataavailable');\ndefineEventAttribute(Mp3MediaRecorder.prototype, 'error');\n\ndeclare module './index' {\n    interface Mp3MediaRecorder\n        extends Pick<MediaRecorder, 'onstart' | 'onstop' | 'onpause' | 'onresume' | 'ondataavailable' | 'onerror'> {}\n}\n"],"names":["Event"],"mappings":"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"}