{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///moment-recur-ts.min.js","webpack:///webpack/bootstrap 9766912eb0d4753f9896","webpack:///external \"moment\"","webpack:///./src/index.ts","webpack:///./src/recur.ts","webpack:///./src/rule.ts","webpack:///./src/calendar.ts","webpack:///./src/interval.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","moment","recur_1","fn","monthWeek","week","undefined","week0","clone","startOf","diff","weekDiff","add","monthWeekByDay","Math","floor","date","dateOnly","isValid","utc","format","recur","start","end","isMoment","options","Recur","__generator","thisArg","body","verb","v","step","op","f","TypeError","_","y","t","done","label","ops","pop","trys","length","push","e","g","sent","next","throw","return","Symbol","iterator","__values","rule_1","_this","reversed","maximumYears","rules","map","rule","Rule","units","measure","exceptions","ex","from","addMeasureFunctions","startDate","Error","endDate","fromDate","maxYears","years","save","data","repeats","every","hasRule","filter","oldRule","except","forget","dateOrRule","normMeasure_1","normalizeMeasure","err","date_1","exception","isSame","findIndex","matches","dateToMatch","ignoreStartEnd","inRange","isException","matchAllRules","startFrom","currentDate","_a","findPreviousMatch","findNextMatch","RangeError","isAfter","reverse","all","dates","_b","e_1_1","e_1","error","_c","num","count","e_2_1","e_2","previous","e_3_1","e_3","keys","MeasureSingleToPlural","measureSingle","measurePlural","e_4_1","e_4","isBefore","e_5_1","e_5","match","e_6_1","e_6","nextDate","limit","allRulesMatch","subtract","nextDates","sort","a","b","calendar_1","interval_1","normMeasure","Interval","unitsToArray","Calendar","Array","isArray","key","day","month","year","dayOfWeek","dayOfMonth","weekOfMonth","weekOfMonthByDay","weekOfYear","monthOfYear","normalizeUnits","range","ranges","period","unit","periodUnit","indexOf","endOf","currentDateIn","isLastDayOfPeriod","nextDateInPeriod","nextPeriod","incrementRange","isSameOrAfter","isFirstDayOfPeriod","previousPeriod","decrementRange","isSameOrBefore","low","high","unitIn","set","Number","isInteger","currentUnit","nextUnit","find","some","u","daysOfWeek","daysOfMonth","weeksOfMonth","weeksOfMonthByDay","weeksOfYear","monthsOfYear","precise","abs","multiples"],"mappings":"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","file":"moment-recur-ts.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moment-recur-ts\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moment-recur-ts\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"moment-recur-ts\"] = factory(root[\"moment\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moment-recur-ts\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moment-recur-ts\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"moment-recur-ts\"] = factory(root[\"moment\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar recur_1 = __webpack_require__(2);\r\nmoment.fn.monthWeek = function (week) {\r\n    if (week === undefined) {\r\n        // First day of the first week of the month\r\n        var week0 = this.clone().startOf('month').startOf('week');\r\n        // First day of week\r\n        var day0 = this.clone().startOf('week');\r\n        return day0.diff(week0, 'weeks');\r\n    }\r\n    else {\r\n        var weekDiff = week - this.monthWeek();\r\n        return this.clone().add(weekDiff, 'weeks');\r\n    }\r\n};\r\nmoment.fn.monthWeekByDay = function (week) {\r\n    if (week === undefined) {\r\n        return Math.floor((this.date() - 1) / 7);\r\n    }\r\n    else {\r\n        var weekDiff = week - this.monthWeekByDay();\r\n        return this.clone().add(weekDiff, 'weeks');\r\n    }\r\n};\r\n// Plugin for removing all time information from a given date\r\nmoment.fn.dateOnly = function () {\r\n    // return this.startOf('day')\r\n    return this.isValid() ? moment.utc(this.format('YYYY-MM-DD')) : this;\r\n};\r\nmoment.recur = function (start, end) {\r\n    // If we have an object, use it as a set of options\r\n    if (typeof start === 'object' && !moment.isMoment(start)) {\r\n        var options = start;\r\n        return new recur_1.Recur(options);\r\n    }\r\n    // else, use the values passed\r\n    return new recur_1.Recur({ start: start, end: end });\r\n};\r\nmoment.fn.recur = function (start, end) {\r\n    // If we have an object, use it as a set of options\r\n    if (start === Object(start) && !moment.isMoment(start)) {\r\n        var options = start;\r\n        // if we have no start date, use the moment\r\n        if (options.start === undefined) {\r\n            options.start = this;\r\n        }\r\n        return new recur_1.Recur(options);\r\n    }\r\n    // if there is no end value, use the start value as the end\r\n    if (!end) {\r\n        end = start;\r\n        start = undefined;\r\n    }\r\n    // use the moment for the start value\r\n    if (!start) {\r\n        start = this;\r\n    }\r\n    return new recur_1.Recur({ start: start, end: end });\r\n};\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar rule_1 = __webpack_require__(3);\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nvar ISO_DATE_FMT = 'YYYY-MM-DD';\r\n/**\r\n * The main Recur object to provide an interface for settings, rules, and matching\r\n *\r\n * Creating Rules\r\n * --------------\r\n * moment-recur-ts uses rules to define when a date should recur. You can then generate future\r\n * or past recurrences based on these rules, or see if a specific date matches the rules.\r\n * Rules can also be overridden or removed.\r\n *\r\n * ### Length Intervals\r\n * moment-recur-ts supports intervals for days, weeks, months, and years. Measurements may be singular or\r\n * plural (ex: `day()` vs `days()`). Length Intervals **must** have a start date defined.\r\n *\r\n * Possible Length Intervals Include:\r\n * * day / days\r\n * * week / weeks\r\n * * month / months\r\n * * year / years\r\n *\r\n * ### Calendar Intervals\r\n * Calendar Intervals do not depend on a start date. They define a unit of another unit. For instance,\r\n * a day of a month, or a month of a year. Measurements may be singular or plural\r\n * (ex: `dayOfMonth()` vs `daysOfMonth()`).\r\n *\r\n * Possible Calendar Intervals Include:\r\n * * dayOfWeek / daysOfWeek\r\n * * dayOfMonth / daysOfMonth\r\n * * weekOfMonth / weeksOfMonth\r\n * * weekOfYear / weeksOfYear\r\n * * monthOfYear / monthsOfYear\r\n */\r\nvar Recur = /** @class */ (function () {\r\n    /**\r\n     * ### Recur Object Constrcutor\r\n     *\r\n     * From an instance of moment:\r\n     * ```js\r\n     * let recurrence;\r\n     *\r\n     * // Create a recurrence using today as the start date.\r\n     * recurrence = moment().recur();\r\n     *\r\n     * // Create a recurrence while passing the start and end dates to the recur function.\r\n     * // Note: passing an end date requires you to also pass a start date.\r\n     * recurrence = moment().recur( start, end );\r\n     *\r\n     * // You may pass a start date to the moment, or use an existing moment, to set the start date.\r\n     * // In this case, passing a date to the recur function sets and end date.\r\n     * recurrence = moment(start).recur( end );\r\n     *\r\n     * // Finally, you can create a recurrence and pass in an entire set of options.\r\n     * recurrence = moment().recur({\r\n     *   start: \"01/01/2014\",\r\n     *   end: \"01/01/2015\"\r\n     * });\r\n     * ```\r\n     * From static moment:\r\n     * ```js\r\n     * // Create recurrence without a start date. Note: this will not work with intervals.\r\n     * recurrence = moment.recur();\r\n     *\r\n     * // Create a recurrence, passing just the start, or the start and end dates.\r\n     * recurrence = moment.recur( start, end );\r\n     *\r\n     * // Create a recurrence, passing set of options.\r\n     * recurrence = moment.recur({\r\n     *   start: \"01/01/2014\",\r\n     *   end: \"01/01/2015\"\r\n     * });\r\n     * ```\r\n     */\r\n    function Recur(options) {\r\n        var _this = this;\r\n        /**\r\n         * @internal\r\n         * @hidden\r\n         */\r\n        this.reversed = false;\r\n        /**\r\n         * @internal\r\n         * @hidden\r\n         */\r\n        this.maximumYears = 1000;\r\n        if (options.start) {\r\n            this.start = moment(options.start).dateOnly();\r\n        }\r\n        if (options.end) {\r\n            this.end = moment(options.end).dateOnly();\r\n        }\r\n        // Our list of rules, all of which must match\r\n        this.rules = (options.rules || []).map(function (rule) { return rule_1.Rule.factory(rule.units, rule.measure, _this.start); });\r\n        // Our list of exceptions. Match always fails on these dates.\r\n        var exceptions = options.exceptions || [];\r\n        this.exceptions = exceptions.map(function (ex) { return moment(ex).dateOnly(); });\r\n        // Temporary units integer, array, or object. Does not get imported/exported.\r\n        this.units = null;\r\n        // Temporary measure type. Does not get imported/exported.\r\n        this.measure = null;\r\n        // Temporary from date for next/previous. Does not get imported/exported.\r\n        this.from = null;\r\n        this.addMeasureFunctions();\r\n        return this;\r\n    }\r\n    Recur.prototype.startDate = function (date) {\r\n        if (date === null) {\r\n            this.start = null;\r\n            return this;\r\n        }\r\n        if (date) {\r\n            this.start = moment(date).dateOnly();\r\n            return this;\r\n        }\r\n        if (!this.start) {\r\n            throw new Error('No start date defined for recurrence.');\r\n        }\r\n        return this.start;\r\n    };\r\n    Recur.prototype.endDate = function (date) {\r\n        if (date === null) {\r\n            this.end = null;\r\n            return this;\r\n        }\r\n        if (date) {\r\n            this.end = moment(date).dateOnly();\r\n            return this;\r\n        }\r\n        if (!this.end) {\r\n            throw new Error('No end date defined for recurrence.');\r\n        }\r\n        return this.end;\r\n    };\r\n    Recur.prototype.fromDate = function (date) {\r\n        if (date === null) {\r\n            this.from = null;\r\n            return this;\r\n        }\r\n        if (date) {\r\n            this.from = moment(date).dateOnly();\r\n            return this;\r\n        }\r\n        if (!this.from) {\r\n            throw new Error('No from date defined for recurrence.');\r\n        }\r\n        return this.from;\r\n    };\r\n    Recur.prototype.maxYears = function (years) {\r\n        if (years) {\r\n            this.maximumYears = years;\r\n            return this;\r\n        }\r\n        else {\r\n            return this.maximumYears;\r\n        }\r\n    };\r\n    /**\r\n     * Use `save()` to export all options, rules, and exceptions as an object.\r\n     * This can be used to store recurrences in a database.\r\n     * > Note: This does not export the \"From Date\" which is considered a temporary option.\r\n     * ```js\r\n     * recurrence.save();\r\n     * ```\r\n     */\r\n    Recur.prototype.save = function () {\r\n        var data = {};\r\n        if (this.start && moment(this.start).isValid()) {\r\n            data.start = this.start.format(ISO_DATE_FMT);\r\n        }\r\n        if (this.end && moment(this.end).isValid()) {\r\n            data.end = this.end.format(ISO_DATE_FMT);\r\n        }\r\n        data.exceptions = this.exceptions.map(function (date) { return date.format(ISO_DATE_FMT); });\r\n        data.rules = this.rules;\r\n        return data;\r\n    };\r\n    /**\r\n     * Use `repeats()` to check if a recurrence has rules set.\r\n     * ```js\r\n     * recurrence.repeats(); // true/false\r\n     * ```\r\n     */\r\n    Recur.prototype.repeats = function () {\r\n        return this.rules.length > 0;\r\n    };\r\n    /**\r\n     * The `every()` function allows you to set the units and, optionally, the measurment type\r\n     * of the recurring date. It returns the recur object to allow chaining.\r\n     *\r\n     *  ```js\r\n     *  let myDate, recurrence;\r\n     *\r\n     *  // Create a date to start from\r\n     *  myDate = moment(\"01/01/2014\");\r\n     *\r\n     *  // You can pass the units to recur on, and the measurement type.\r\n     *  recurrence = myDate.recur().every(1, \"days\");\r\n     *\r\n     *  // You can also chain the measurement type instead of passing it to every.\r\n     *  recurrence = myDate.recur().every(1).day();\r\n     *\r\n     *  // It is also possible to pass an array of units.\r\n     *  recurrence = myDate.recur().every([3, 5]).days();\r\n     *\r\n     *  // When using the dayOfWeek measurement, you can pass days names.\r\n     *  recurrence = myDate.recur().every([\"Monday\", \"wed\"]).daysOfWeek();\r\n     *\r\n     *  // Month names also work when using monthOfYear.\r\n     *  recurrence = myDate.recur().every([\"Jan\", \"february\"], \"monthsOfYear\");\r\n     *  ```\r\n     *\r\n     *  `every()` will override the last \"every\" if a measurement was not provided.\r\n     *  The following line will create a recurrence for every 5 days.\r\n     *  ```js\r\n     *  recurrence  = myDate.recur().every(1).every(5).days();\r\n     *  ```\r\n     *  If you need to specify multiple units, pass an array to `every()`.\r\n     *\r\n     *  You may also pass the units directly to the interval functions (listed below)\r\n     *  instead of using `every()`.\r\n     *  ```js\r\n     *  let recurrence = moment.recur().monthOfYear(\"January\");\r\n     *  ```\r\n     */\r\n    Recur.prototype.every = function (units, measure) {\r\n        if (units != null) {\r\n            this.units = units;\r\n        }\r\n        if (measure != null) {\r\n            this.measure = measure;\r\n        }\r\n        // Don't create the rule until measure is defined\r\n        if (!this.measure) {\r\n            return this;\r\n        }\r\n        var rule = rule_1.Rule.factory(this.units, this.measure, this.start);\r\n        if (rule.measure === 'weeksOfMonthByDay' && !this.hasRule('daysOfWeek')) {\r\n            throw new Error('weeksOfMonthByDay must be combined with daysOfWeek');\r\n        }\r\n        // Remove the temporary rule data\r\n        this.units = null;\r\n        this.measure = null;\r\n        // Remove existing rule based on measure\r\n        this.rules = this.rules.filter(function (oldRule) { return oldRule.measure !== rule.measure; });\r\n        this.rules.push(rule);\r\n        return this;\r\n    };\r\n    /**\r\n     * To prevent a date from matching that would normally match, use the `except()` function.\r\n     * ```js\r\n     * let recurrence = moment(\"01/01/2014\").recur().every(1).day().except(\"01/02/2014\");\r\n     * recurrence.matches(\"01/02/2014\"); // false\r\n     * ```\r\n     */\r\n    Recur.prototype.except = function (date) {\r\n        date = moment(date).dateOnly();\r\n        this.exceptions.push(date);\r\n        return this;\r\n    };\r\n    /**\r\n     * Forgets rules (by passing measure) and exceptions (by passing date)\r\n     * ```js\r\n     * // Exceptions can be removed by passing a date to the forget() function.\r\n     * recurrence.forget(\"01/03/2014\");\r\n     * ```\r\n     * ```js\r\n     * // Rules can be removed by passing the measurement to the forget() function.\r\n     * recurrence.forget(\"days\");\r\n     * ```\r\n     */\r\n    Recur.prototype.forget = function (dateOrRule, format) {\r\n        if (!dateOrRule) {\r\n            throw new Error('Invalid input for recurrence forget: ' + dateOrRule);\r\n        }\r\n        try {\r\n            var normMeasure_1 = rule_1.Rule.normalizeMeasure(dateOrRule);\r\n            this.rules = this.rules.filter(function (rule) { return rule.measure !== normMeasure_1; });\r\n            return this;\r\n        }\r\n        catch (err) {\r\n            var date_1 = moment(dateOrRule, format);\r\n            // If valid date, try to remove it from exceptions\r\n            if (date_1.isValid()) {\r\n                date_1 = date_1.dateOnly(); // change to date only for perfect comparison\r\n                this.exceptions = this.exceptions.filter(function (exception) { return !date_1.isSame(exception); });\r\n                return this;\r\n            }\r\n            else {\r\n                throw new Error('Invalid input for recurrence forget: ' + dateOrRule);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks if a rule has been set on the chain\r\n     */\r\n    Recur.prototype.hasRule = function (measure) {\r\n        return this.rules.findIndex(function (rule) { return rule.measure === rule_1.Rule.normalizeMeasure(measure); }) !== -1;\r\n    };\r\n    /**\r\n     * The `matches()` function will test a date to check if all of the recurrence rules match.\r\n     * It returns `true` if the date matches, `false` otherwise.\r\n     * ```js\r\n     * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n     * interval.matches(\"01/02/2014\"); // false\r\n     * interval.matches(\"01/03/2014\"); // true\r\n     * ```\r\n     *\r\n     * You may also see if a date matches before the start date or after the end date by\r\n     * passing `true` as the second argument to `matches()`.\r\n     * ```js\r\n     * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n     * interval.matches(\"12/30/2013\"); // false\r\n     * interval.matches(\"12/30/2013\", true); // true\r\n     * ```\r\n     */\r\n    Recur.prototype.matches = function (dateToMatch, ignoreStartEnd) {\r\n        var date = moment(dateToMatch).dateOnly();\r\n        if (!date.isValid()) {\r\n            throw Error('Invalid date supplied to match method: ' + dateToMatch);\r\n        }\r\n        if (!ignoreStartEnd && !this.inRange(date)) {\r\n            return false;\r\n        }\r\n        if (this.isException(date)) {\r\n            return false;\r\n        }\r\n        if (!this.matchAllRules(date)) {\r\n            return false;\r\n        }\r\n        // if we passed everything above, then this date matches\r\n        return true;\r\n    };\r\n    /**\r\n     * Iterate over moments matched by rules\r\n     * > Note if there is no end date, results are unbounded (you must manually terminate the iterator).\r\n     *\r\n     * > Also note, this exapmle intentionally ignores some complicated leap year math.\r\n     *\r\n     * ```js\r\n     * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n     * let leapYears = [...recurrence].map(m => m.year())\r\n     * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n     * ```\r\n     * Or, this is a bit faster...\r\n     * ```js\r\n     * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n     * let leapYears = []\r\n     * for (let date of recurrence) {\r\n     *   leapYears.push(date.year())\r\n     * }\r\n     * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n     * ```\r\n     */\r\n    Recur.prototype[Symbol.iterator] = function () {\r\n        var startFrom, currentDate;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    startFrom = this.from || this.start;\r\n                    if (!startFrom || !startFrom.isValid()) {\r\n                        throw Error('Cannot get occurrences without start or from date.');\r\n                    }\r\n                    if (this.end && (startFrom > this.end)) {\r\n                        throw Error('Start date cannot be later than end date.');\r\n                    }\r\n                    currentDate = startFrom.clone();\r\n                    if (!this.matchAllRules(currentDate)) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, currentDate.clone()];\r\n                case 1:\r\n                    _a.sent();\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (false) return [3 /*break*/, 5];\r\n                    try {\r\n                        currentDate = this.reversed ?\r\n                            this.findPreviousMatch(currentDate) :\r\n                            this.findNextMatch(currentDate);\r\n                    }\r\n                    catch (err) {\r\n                        /* istanbul ignore else */\r\n                        if (err instanceof RangeError)\r\n                            return [2 /*return*/, undefined];\r\n                        else\r\n                            throw err;\r\n                    }\r\n                    if (this.end && currentDate.isAfter(this.end))\r\n                        return [3 /*break*/, 5];\r\n                    if (!!this.isException(currentDate)) return [3 /*break*/, 4];\r\n                    return [4 /*yield*/, currentDate.clone()];\r\n                case 3:\r\n                    _a.sent();\r\n                    _a.label = 4;\r\n                case 4: return [3 /*break*/, 2];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Reverse iterator direction\r\n     * > Note since there is no end date, results are unbounded (you must manually terminate the iterator).\r\n     *\r\n     * ```js\r\n     * let mondays = []\r\n     * for (let monday of moment().recur().every('Monday').dayOfWeek().reverse()) {\r\n     *   lastThreeMondays.push(monday)\r\n     *   if (mondays.length > 10) break\r\n     * }\r\n     * ```\r\n     */\r\n    Recur.prototype.reverse = function () {\r\n        this.reversed = !this.reversed;\r\n        return this;\r\n    };\r\n    Recur.prototype.all = function (format) {\r\n        if (!this.end || !this.end.isValid()) {\r\n            throw Error('Cannot get all occurrences without an end date.');\r\n        }\r\n        this.reversed = false;\r\n        var dates = [];\r\n        try {\r\n            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var date = _b.value;\r\n                dates.push(format ? date.format(format) : date);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return dates;\r\n        var e_1, _c;\r\n    };\r\n    Recur.prototype.next = function (num, format) {\r\n        if (!num)\r\n            return [];\r\n        var dates = [];\r\n        var count = 0;\r\n        this.reversed = false;\r\n        try {\r\n            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var date = _b.value;\r\n                if (!(this.start && date.isSame(this.start))) {\r\n                    dates.push(format ? date.format(format) : date);\r\n                    count++;\r\n                }\r\n                if (count >= num)\r\n                    break;\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return dates;\r\n        var e_2, _c;\r\n    };\r\n    Recur.prototype.previous = function (num, format) {\r\n        if (!num)\r\n            return [];\r\n        var dates = [];\r\n        var count = 0;\r\n        this.reversed = true;\r\n        try {\r\n            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var date = _b.value;\r\n                if (!(this.start && date.isSame(this.start))) {\r\n                    dates.push(format ? date.format(format) : date);\r\n                    count++;\r\n                }\r\n                if (count >= num)\r\n                    break;\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return dates;\r\n        var e_3, _c;\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Recur.prototype.addMeasureFunctions = function () {\r\n        var _this = this;\r\n        var _loop_1 = function (measureSingle) {\r\n            var measurePlural = rule_1.Rule.MeasureSingleToPlural[measureSingle];\r\n            Recur.prototype[measureSingle] = function (units) {\r\n                _this.every(units, measurePlural);\r\n                return _this;\r\n            };\r\n            Recur.prototype[measurePlural] = function (units) {\r\n                _this.every(units, measurePlural);\r\n                return _this;\r\n            };\r\n        };\r\n        try {\r\n            for (var _a = __values(Object.keys(rule_1.Rule.MeasureSingleToPlural)), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var measureSingle = _b.value;\r\n                _loop_1(measureSingle);\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        var e_4, _c;\r\n    };\r\n    /**\r\n     * Private function to see if a date is within range of start/end\r\n     * @internal\r\n     */\r\n    Recur.prototype.inRange = function (date) {\r\n        if (this.start && date.isBefore(this.start)) {\r\n            return false;\r\n        }\r\n        else if (this.end && date.isAfter(this.end)) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * Private function to check if a date is an exception\r\n     * @internal\r\n     */\r\n    Recur.prototype.isException = function (date) {\r\n        try {\r\n            for (var _a = __values(this.exceptions), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var exception = _b.value;\r\n                if (moment(exception).isSame(date)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n        return false;\r\n        var e_5, _c;\r\n    };\r\n    /**\r\n     * Private funtion to see if all rules match\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    Recur.prototype.matchAllRules = function (date) {\r\n        try {\r\n            for (var _a = __values(this.rules), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var rule = _b.value;\r\n                if (!rule.match(date)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n        return true;\r\n        var e_6, _c;\r\n    };\r\n    /**\r\n     * Private funtion to see if all rules match\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    Recur.prototype.findNextMatch = function (currentDate) {\r\n        var nextDate = currentDate.clone().add(1, 'day');\r\n        var limit = currentDate.clone().add(this.maximumYears, 'years');\r\n        var allRulesMatch = false;\r\n        while (!allRulesMatch) {\r\n            // if (nextDate.year() >= currentDate.year() + this.maximumYears) {\r\n            //   throw new RangeError()\r\n            // }\r\n            nextDate.subtract(1, 'day');\r\n            var nextDates = this.rules.map(function (rule) { return rule.next(nextDate, limit); });\r\n            nextDates.sort(function (a, b) { return a.diff(b); });\r\n            nextDate = nextDates[nextDates.length - 1];\r\n            allRulesMatch = nextDate.isSame(nextDates[0]);\r\n        }\r\n        return nextDate;\r\n    };\r\n    /**\r\n     * Private funtion to see if all rules match\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    Recur.prototype.findPreviousMatch = function (currentDate) {\r\n        var nextDate = currentDate.clone().subtract(1, 'day');\r\n        var limit = currentDate.clone().subtract(this.maximumYears, 'years');\r\n        var allRulesMatch = false;\r\n        while (!allRulesMatch) {\r\n            // if (nextDate.year() <= currentDate.year() - this.maximumYears) {\r\n            //   throw new RangeError()\r\n            // }\r\n            nextDate.add(1, 'day');\r\n            var nextDates = this.rules.map(function (rule) { return rule.previous(nextDate, limit); });\r\n            nextDates.sort(function (a, b) { return b.diff(a); });\r\n            nextDate = nextDates[nextDates.length - 1];\r\n            allRulesMatch = nextDate.isSame(nextDates[0]);\r\n        }\r\n        return nextDate;\r\n    };\r\n    return Recur;\r\n}());\r\nexports.Recur = Recur;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar calendar_1 = __webpack_require__(4);\r\nvar interval_1 = __webpack_require__(5);\r\nvar Rule;\r\n(function (Rule) {\r\n    /**\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    Rule.MeasureSingleToPlural = {\r\n        day: 'days',\r\n        week: 'weeks',\r\n        month: 'months',\r\n        year: 'years',\r\n        dayOfWeek: 'daysOfWeek',\r\n        dayOfMonth: 'daysOfMonth',\r\n        weekOfMonth: 'weeksOfMonth',\r\n        weekOfMonthByDay: 'weeksOfMonthByDay',\r\n        weekOfYear: 'weeksOfYear',\r\n        monthOfYear: 'monthsOfYear'\r\n    };\r\n    /**\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    function factory(units, measure, start) {\r\n        var normMeasure = normalizeMeasure(measure);\r\n        switch (normMeasure) {\r\n            case 'days':\r\n            case 'weeks':\r\n            case 'months':\r\n            case 'years':\r\n                return new interval_1.Interval(unitsToArray(units), normMeasure, start);\r\n            case 'daysOfWeek':\r\n            case 'daysOfMonth':\r\n            case 'weeksOfMonth':\r\n            case 'weeksOfMonthByDay':\r\n            case 'weeksOfYear':\r\n            case 'monthsOfYear':\r\n                return new calendar_1.Calendar(unitsToArray(units), normMeasure);\r\n        }\r\n    }\r\n    Rule.factory = factory;\r\n    /**\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    function unitsToArray(units) {\r\n        if (units == null) {\r\n            throw new Error('Units not defined for recurrence rule.');\r\n        }\r\n        else if (Array.isArray(units)) {\r\n            return units;\r\n        }\r\n        else if (typeof units === 'object') {\r\n            return Object.keys(units);\r\n        }\r\n        else if (typeof units === 'number') {\r\n            return [units];\r\n            // tslint:disable-next-line:strict-type-predicates\r\n        }\r\n        else if (typeof units === 'string') {\r\n            return [units];\r\n        }\r\n        else {\r\n            throw new Error('Provide an array, object, string or number when passing units!');\r\n        }\r\n    }\r\n    /**\r\n     * Private function to pluralize measure names for use with dictionaries.\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    function normalizeMeasure(measure) {\r\n        if (typeof measure === 'string') {\r\n            if (Rule.MeasureSingleToPlural[measure]) {\r\n                return Rule.MeasureSingleToPlural[measure];\r\n            }\r\n            else {\r\n                for (var key in Rule.MeasureSingleToPlural) {\r\n                    if (Rule.MeasureSingleToPlural[key] === measure)\r\n                        return measure;\r\n                }\r\n            }\r\n        }\r\n        throw new Error('Invalid Measure for recurrence: ' + measure);\r\n    }\r\n    Rule.normalizeMeasure = normalizeMeasure;\r\n})(Rule = exports.Rule || (exports.Rule = {}));\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\n/**\r\n * Calendar object for creating and matching calendar-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nvar Calendar = /** @class */ (function () {\r\n    function Calendar(units, measure) {\r\n        this.measure = measure;\r\n        this.units = this.normalizeUnits(units);\r\n        this.range = Calendar.ranges[this.measure].range;\r\n        this.period = Calendar.ranges[this.measure].period;\r\n    }\r\n    Calendar.prototype.match = function (date) {\r\n        // Get the unit based on the required measure of the date\r\n        var unit = this.periodUnit(date);\r\n        // If the unit is in our list, return true, else return false\r\n        if (this.units.indexOf(unit) !== -1) {\r\n            return true;\r\n        }\r\n        if ((this.units[0] === -1) &&\r\n            (unit === this.periodUnit(moment(date).endOf(this.range)))) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    Calendar.prototype.next = function (currentDateIn, limit) {\r\n        var currentDate = currentDateIn.clone();\r\n        // If still within our period, just give the next day\r\n        if (!this.isLastDayOfPeriod(currentDate)) {\r\n            var nextDateInPeriod = moment(currentDate).add(1, 'day');\r\n            if (this.match(nextDateInPeriod))\r\n                return nextDateInPeriod;\r\n        }\r\n        while (true) {\r\n            // Get the next period based on the measure\r\n            var nextDate = this.nextPeriod(currentDate);\r\n            if (nextDate) {\r\n                return nextDate;\r\n            }\r\n            else {\r\n                // No more units found within this range,\r\n                // bump our range by one and try again.\r\n                currentDate = this.incrementRange(currentDate, 1);\r\n                // Check to see if next range starts on a valid period\r\n                if (this.match(currentDate)) {\r\n                    return currentDate;\r\n                }\r\n                if (currentDate.isSameOrAfter(limit)) {\r\n                    throw new RangeError('Recurrence Year limit exceeded.');\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Calendar.prototype.previous = function (currentDateIn, limit) {\r\n        var currentDate = currentDateIn.clone();\r\n        // If still within our period, just give the next day\r\n        if (!this.isFirstDayOfPeriod(currentDate)) {\r\n            var nextDateInPeriod = moment(currentDate).subtract(1, 'day');\r\n            if (this.match(nextDateInPeriod))\r\n                return nextDateInPeriod;\r\n        }\r\n        while (true) {\r\n            // Get the next period based on the measure\r\n            var nextDate = this.previousPeriod(currentDate);\r\n            if (nextDate) {\r\n                return nextDate;\r\n            }\r\n            else {\r\n                // No more units found within this range,\r\n                // bump our range by one and try again.\r\n                currentDate = this.decrementRange(currentDate, 1);\r\n                // Check to see if next range starts on a valid period\r\n                if (this.match(currentDate)) {\r\n                    return currentDate;\r\n                }\r\n                if (currentDate.isSameOrBefore(limit)) {\r\n                    throw new RangeError('Recurrence Year limit exceeded.');\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Calendar.prototype.normalizeUnits = function (units) {\r\n        var _this = this;\r\n        var low = Calendar.ranges[this.measure].low;\r\n        var high = Calendar.ranges[this.measure].high;\r\n        return units.map(function (unitIn) {\r\n            if (unitIn === 'last')\r\n                unitIn = -1;\r\n            if (typeof unitIn !== 'number') {\r\n                // Convert day/month names to numbers, if needed\r\n                if (_this.measure === 'daysOfWeek') {\r\n                    unitIn = moment().set('days', unitIn).get('days');\r\n                }\r\n                else if (_this.measure === 'monthsOfYear') {\r\n                    unitIn = moment().set('months', unitIn).get('months');\r\n                }\r\n                else {\r\n                    unitIn = +unitIn;\r\n                }\r\n            }\r\n            if (!Number.isInteger(unitIn)) {\r\n                throw new TypeError('Invalid calendar unit in recurrence: ' + unitIn);\r\n            }\r\n            if ((unitIn < low || unitIn > high) && (unitIn !== -1)) {\r\n                throw new RangeError('Value should be in range ' + low + ' to ' + high);\r\n            }\r\n            return unitIn;\r\n        }).sort(function (a, b) { return a - b; });\r\n    };\r\n    Calendar.prototype.periodUnit = function (date, unit) {\r\n        switch (this.measure) {\r\n            case 'daysOfWeek':\r\n                return date.day(unit);\r\n            case 'daysOfMonth':\r\n                return date.date(unit);\r\n            case 'weeksOfMonth':\r\n                return date.monthWeek(unit);\r\n            case 'weeksOfMonthByDay':\r\n                return date.monthWeekByDay(unit);\r\n            case 'weeksOfYear':\r\n                return date.week(unit);\r\n            case 'monthsOfYear':\r\n                return date.month(unit);\r\n        }\r\n    };\r\n    Calendar.prototype.nextPeriod = function (date) {\r\n        var _this = this;\r\n        // Get the next period based on the measure\r\n        var currentUnit = this.periodUnit(date);\r\n        var nextUnit = this.units\r\n            .map(function (unit) { return unit === -1 ? _this.periodUnit(date.clone().endOf(_this.range)) : unit; })\r\n            .find(function (unit) { return unit > currentUnit; });\r\n        if (nextUnit !== undefined) {\r\n            return this.periodUnit(date.clone(), nextUnit).startOf(this.period);\r\n        }\r\n        else {\r\n            // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n            if (this.measure === 'weeksOfYear' && (this.units.indexOf(1) !== -1)) {\r\n                return date.clone().endOf('year').startOf('week');\r\n            }\r\n            return undefined;\r\n        }\r\n    };\r\n    Calendar.prototype.previousPeriod = function (date) {\r\n        var _this = this;\r\n        // Get the next period based on the measure\r\n        var currentUnit = this.periodUnit(date);\r\n        if (this.measure === 'weeksOfYear' && date.month() === 11 && date.week() === 1)\r\n            currentUnit = 53;\r\n        var nextUnit = this.units\r\n            .map(function (unit) { return unit === -1 ? _this.periodUnit(date.clone().endOf(_this.range)) : unit; })\r\n            .reverse().find(function (unit) { return unit < currentUnit; });\r\n        if (nextUnit !== undefined) {\r\n            if (this.measure === 'weeksOfYear' && currentUnit === 53)\r\n                date.week(0);\r\n            return this.periodUnit(date.clone(), nextUnit).endOf(this.period);\r\n        }\r\n        else {\r\n            // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n            if (this.measure === 'weeksOfYear' &&\r\n                this.units.some(function (u) { return 52 >= u && u <= 53; })) {\r\n                return date.clone().startOf('year').endOf('week');\r\n            }\r\n            return undefined;\r\n        }\r\n    };\r\n    Calendar.prototype.incrementRange = function (date, count) {\r\n        return date.add(count, this.range).startOf(this.range);\r\n    };\r\n    Calendar.prototype.decrementRange = function (date, count) {\r\n        return date.subtract(count, this.range).endOf(this.range);\r\n    };\r\n    Calendar.prototype.isLastDayOfPeriod = function (date) {\r\n        if (this.measure === 'weeksOfMonthByDay') {\r\n            return date.monthWeekByDay() !== moment(date).add(1, 'day').monthWeekByDay();\r\n        }\r\n        if (this.period === 'day') {\r\n            return true;\r\n        }\r\n        else {\r\n            return date.isSame(moment(date).endOf(this.period));\r\n        }\r\n    };\r\n    Calendar.prototype.isFirstDayOfPeriod = function (date) {\r\n        if (this.measure === 'weeksOfMonthByDay') {\r\n            return date.monthWeekByDay() !== moment(date).subtract(1, 'day').monthWeekByDay();\r\n        }\r\n        if (this.period === 'day') {\r\n            return true;\r\n        }\r\n        else {\r\n            return date.isSame(moment(date).startOf(this.period));\r\n        }\r\n    };\r\n    Calendar.ranges = {\r\n        daysOfWeek: {\r\n            period: 'day',\r\n            range: 'week',\r\n            low: 0,\r\n            high: 6\r\n        },\r\n        daysOfMonth: {\r\n            period: 'day',\r\n            range: 'month',\r\n            low: 1,\r\n            high: 31\r\n        },\r\n        weeksOfMonth: {\r\n            period: 'week',\r\n            range: 'month',\r\n            low: 0,\r\n            high: 4\r\n        },\r\n        weeksOfMonthByDay: {\r\n            period: 'week',\r\n            range: 'month',\r\n            low: 0,\r\n            high: 4\r\n        },\r\n        weeksOfYear: {\r\n            period: 'week',\r\n            range: 'year',\r\n            low: 1,\r\n            high: 53\r\n        },\r\n        monthsOfYear: {\r\n            period: 'month',\r\n            range: 'year',\r\n            low: 0,\r\n            high: 11\r\n        }\r\n    };\r\n    return Calendar;\r\n}());\r\nexports.Calendar = Calendar;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Interval object for creating and matching interval-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nvar Interval = /** @class */ (function () {\r\n    function Interval(units, measure, start) {\r\n        if (!start) {\r\n            throw new Error('Must have a start date set to set an interval!');\r\n        }\r\n        this.start = start.clone();\r\n        this.measure = measure;\r\n        this.units = this.normalizeUnits(units);\r\n    }\r\n    Interval.prototype.match = function (date) {\r\n        var precise = this.measure !== 'days';\r\n        var diff = Math.abs(this.start.diff(date, this.measure, precise));\r\n        try {\r\n            // Check to see if any of the units provided match the date\r\n            for (var _a = __values(this.units), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var unit = _b.value;\r\n                // If the units divide evenly into the difference, we have a match\r\n                if ((diff % unit) === 0) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return false;\r\n        var e_1, _c;\r\n    };\r\n    Interval.prototype.next = function (currentDate) {\r\n        // let precise = this.measure !== 'days'\r\n        // Get the multiple of the start\r\n        var diff = currentDate.diff(this.start, this.measure);\r\n        // Find the next muliple for each unit\r\n        var multiples = this.units.map(function (unit) { return (Math.floor(diff / unit) + 1) * unit; });\r\n        multiples.sort(function (a, b) { return a - b; });\r\n        return this.start.clone().add(multiples[0], this.measure);\r\n    };\r\n    Interval.prototype.previous = function (currentDate) {\r\n        // let precise = this.measure !== 'days'\r\n        // Get the multiple of the start\r\n        var diff = this.start.diff(currentDate, this.measure);\r\n        // Find the next muliple for each unit\r\n        var multiples = this.units.map(function (unit) { return (Math.floor(diff / unit) + 1) * unit; });\r\n        multiples.sort(function (a, b) { return b - a; });\r\n        return this.start.clone().subtract(multiples[0], this.measure);\r\n    };\r\n    Interval.prototype.normalizeUnits = function (units) {\r\n        // Make sure all of the units are integers greater than 0.\r\n        return units.map(function (unit) {\r\n            unit = +unit;\r\n            if (unit <= 0) {\r\n                throw new Error('Intervals must be greater than zero.');\r\n            }\r\n            if (!Number.isInteger(unit)) {\r\n                throw new Error('Intervals must be integers.');\r\n            }\r\n            return unit;\r\n        }).sort(function (a, b) { return a - b; });\r\n    };\r\n    return Interval;\r\n}());\r\nexports.Interval = Interval;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// moment-recur-ts.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9766912eb0d4753f9896","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 0\n// module chunks = 0 1","import * as moment from 'moment'\r\nimport { Recur } from './recur'\r\n\r\ndeclare module 'moment' {\r\n\r\n  interface Moment {\r\n\r\n    /**\r\n     * The `monthWeek()` method can be used to determine the week of the month a date is in.\r\n     * ```js\r\n     * moment(\"01/01/2014\").monthWeek(); // 0\r\n     * ```\r\n     */\r\n    monthWeek (): number\r\n    monthWeek (week: number): moment.Moment\r\n\r\n    /**\r\n     * Plugin for calculating the occurrence of the day of the week in the month.\r\n     * Similar to `moment().monthWeek()`, the return value is zero-indexed.\r\n     * A return value of 2 means the date is the 3rd occurence of that day\r\n     * of the week in the month.\r\n     */\r\n    monthWeekByDay (): number\r\n    monthWeekByDay (dayCount: number): moment.Moment\r\n\r\n    /**\r\n     * The `dateOnly()` method can be used to remove any time information from a moment.\r\n     * ```js\r\n     * moment(\"2014-01-01 09:30:26\").dateOnly(); // 01/01/2014 12:00:00 AM\r\n     * ```\r\n     */\r\n    dateOnly (): moment.Moment\r\n\r\n    /**\r\n     * Recur can also be created the following ways:\r\n     * ```js\r\n     * moment().recur()\r\n     * moment().recur(options)\r\n     * moment().recur(start, end)\r\n     * moment(start).recur(end)\r\n     * moment().recur(end)\r\n     * ```\r\n     */\r\n    recur (start?: moment.MomentInput, end?: moment.MomentInput): Recur\r\n    recur (options?: Recur.Options): Recur\r\n\r\n    /**\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    set (unit: moment.unitOfTime.All, value: number | string): moment.Moment\r\n  }\r\n\r\n  /**\r\n   * Recur can be created the following ways:\r\n   * ```js\r\n   * moment.recur()\r\n   * moment.recur(options)\r\n   * moment.recur(start)\r\n   * moment.recur(start, end)\r\n   * ```\r\n   */\r\n  function recur (start?: moment.MomentInput, end?: moment.MomentInput): Recur\r\n  function recur (options?: Recur.Options): Recur\r\n}\r\n\r\nmoment.fn.monthWeek = function (this: moment.Moment, week?: number): number | moment.Moment {\r\n\r\n  if (week === undefined) {\r\n    // First day of the first week of the month\r\n    const week0 = this.clone().startOf('month').startOf('week')\r\n\r\n    // First day of week\r\n    const day0 = this.clone().startOf('week')\r\n\r\n    return day0.diff(week0, 'weeks')\r\n  } else {\r\n    const weekDiff = week - this.monthWeek()\r\n    return this.clone().add(weekDiff, 'weeks')\r\n  }\r\n} as {(): number, (w: number): moment.Moment}\r\n\r\nmoment.fn.monthWeekByDay = function (this: moment.Moment, week?: number): number | moment.Moment {\r\n  if (week === undefined) {\r\n    return Math.floor((this.date() - 1) / 7)\r\n  } else {\r\n    const weekDiff = week - this.monthWeekByDay()\r\n    return this.clone().add(weekDiff, 'weeks')\r\n  }\r\n} as {(): number, (w: number): moment.Moment}\r\n\r\n// Plugin for removing all time information from a given date\r\nmoment.fn.dateOnly = function (): moment.Moment {\r\n  // return this.startOf('day')\r\n  return this.isValid() ? moment.utc(this.format('YYYY-MM-DD')) : this\r\n}\r\n\r\n;\r\n(moment as any).recur = function (start?: moment.MomentInput | Recur.Options,\r\n                                  end?: moment.MomentInput): Recur {\r\n  // If we have an object, use it as a set of options\r\n  if (typeof start === 'object' && !moment.isMoment(start)) {\r\n    const options = start as Recur.Options\r\n    return new Recur(options)\r\n  }\r\n\r\n  // else, use the values passed\r\n  return new Recur({ start, end })\r\n}\r\n\r\nmoment.fn.recur = function (this: moment.Moment,\r\n                            start?: moment.MomentInput | Recur.Options,\r\n                            end?: moment.MomentInput): Recur {\r\n  // If we have an object, use it as a set of options\r\n  if (start === Object(start) && !moment.isMoment(start)) {\r\n    const options = start as Recur.Options\r\n    // if we have no start date, use the moment\r\n    if (options.start === undefined) {\r\n      options.start = this\r\n    }\r\n\r\n    return new Recur(options)\r\n  }\r\n\r\n  // if there is no end value, use the start value as the end\r\n  if (!end) {\r\n    end = start as moment.MomentInput\r\n    start = undefined\r\n  }\r\n\r\n  // use the moment for the start value\r\n  if (!start) {\r\n    start = this\r\n  }\r\n\r\n  return new Recur({ start: start as moment.MomentInput, end })\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/** @hidden */\r\nexport type Moment = moment.Moment\r\n/** @hidden */\r\nexport type MomentInput = moment.MomentInput\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nconst ISO_DATE_FMT = 'YYYY-MM-DD'\r\n\r\nexport namespace Recur {\r\n  /**\r\n   * Set options upon creation.\r\n   *\r\n   * > Note that the units for rules are converted to objects,\r\n   * > so it is not recommended to set rules this way.\r\n   * > They can be set in the options so that they can be imported.\r\n   *\r\n   * ```js\r\n   * moment().recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"12/31/2014\",\r\n   *   rules: [\r\n   *     { units: [2], measure: \"days\" }\r\n   *   ],\r\n   *   exceptions: [\"01/05/2014\"]\r\n   * });\r\n   * ```\r\n   */\r\n  export interface Options {\r\n    start?: MomentInput\r\n    end?: MomentInput\r\n    rules?: {\r\n      units: Rule.UnitsInput\r\n      measure: Rule.MeasureInput\r\n    }[]\r\n    exceptions?: MomentInput[]\r\n  }\r\n}\r\n\r\nexport interface Recur {\r\n\r\n  days (units?: Rule.UnitsInput): this\r\n  day (units?: Rule.UnitsInput): this\r\n\r\n  weeks (units?: Rule.UnitsInput): this\r\n  week (units?: Rule.UnitsInput): this\r\n\r\n  months (units?: Rule.UnitsInput): this\r\n  month (units?: Rule.UnitsInput): this\r\n\r\n  years (units?: Rule.UnitsInput): this\r\n  year (units?: Rule.UnitsInput): this\r\n\r\n  daysOfWeek (units?: Rule.UnitsInput): this\r\n  dayOfWeek (units?: Rule.UnitsInput): this\r\n\r\n  daysOfMonth (units?: Rule.UnitsInput): this\r\n  dayOfMonth (units?: Rule.UnitsInput): this\r\n\r\n  weeksOfMonth (units?: Rule.UnitsInput): this\r\n  weekOfMonth (units?: Rule.UnitsInput): this\r\n\r\n  weeksOfYear (units?: Rule.UnitsInput): this\r\n  weekOfYear (units?: Rule.UnitsInput): this\r\n\r\n  /**\r\n   * ```js\r\n   * // Will match any date that is in January of any year.\r\n   * cal = moment.recur().every(\"January\").monthsOfYear();\r\n   * ```\r\n   */\r\n  monthsOfYear (units?: Rule.UnitsInput): Recur\r\n  monthOfYear (units?: Rule.UnitsInput): Recur\r\n\r\n  /**\r\n   * A weekOfMonthByDay interval is available for combining with the daysOfWeek to\r\n   * achieve \"nth weekday of month\" recurrences. The following matches every 1st\r\n   * and 3rd Thursday of the month.\r\n   * > (Note this cannot be combined at the moment with every(x).months() expression)\r\n   *\r\n   * ```js\r\n   * cal = moment.recur()\r\n   *   .every(\"Thursday\").daysOfWeek()\r\n   *   .every([0, 2]).weeksOfMonthByDay();\r\n   * ```\r\n   * ```js\r\n   * cal = moment.recur()\r\n   *   .every(moment(\"01/01/2014\").day()).daysOfWeek()\r\n   *   .every(moment(\"01/01/2014\").monthWeekByDay()).weeksOfMonthByDay();\r\n   * ```\r\n   */\r\n  weeksOfMonthByDay (units?: Rule.UnitsInput): Recur\r\n  weekOfMonthByDay (units?: Rule.UnitsInput): Recur\r\n}\r\n\r\n/**\r\n * The main Recur object to provide an interface for settings, rules, and matching\r\n *\r\n * Creating Rules\r\n * --------------\r\n * moment-recur-ts uses rules to define when a date should recur. You can then generate future\r\n * or past recurrences based on these rules, or see if a specific date matches the rules.\r\n * Rules can also be overridden or removed.\r\n *\r\n * ### Length Intervals\r\n * moment-recur-ts supports intervals for days, weeks, months, and years. Measurements may be singular or\r\n * plural (ex: `day()` vs `days()`). Length Intervals **must** have a start date defined.\r\n *\r\n * Possible Length Intervals Include:\r\n * * day / days\r\n * * week / weeks\r\n * * month / months\r\n * * year / years\r\n *\r\n * ### Calendar Intervals\r\n * Calendar Intervals do not depend on a start date. They define a unit of another unit. For instance,\r\n * a day of a month, or a month of a year. Measurements may be singular or plural\r\n * (ex: `dayOfMonth()` vs `daysOfMonth()`).\r\n *\r\n * Possible Calendar Intervals Include:\r\n * * dayOfWeek / daysOfWeek\r\n * * dayOfMonth / daysOfMonth\r\n * * weekOfMonth / weeksOfMonth\r\n * * weekOfYear / weeksOfYear\r\n * * monthOfYear / monthsOfYear\r\n */\r\nexport class Recur implements Iterable<moment.Moment> {\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected start: Moment | null\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected end: Moment | null\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected from: Moment | null\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private rules: Rule[]\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private exceptions: Moment[]\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private units: Rule.UnitsInput\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private measure: Rule.MeasureInput\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private reversed = false\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private maximumYears = 1000\r\n\r\n  /**\r\n   * ### Recur Object Constrcutor\r\n   *\r\n   * From an instance of moment:\r\n   * ```js\r\n   * let recurrence;\r\n   *\r\n   * // Create a recurrence using today as the start date.\r\n   * recurrence = moment().recur();\r\n   *\r\n   * // Create a recurrence while passing the start and end dates to the recur function.\r\n   * // Note: passing an end date requires you to also pass a start date.\r\n   * recurrence = moment().recur( start, end );\r\n   *\r\n   * // You may pass a start date to the moment, or use an existing moment, to set the start date.\r\n   * // In this case, passing a date to the recur function sets and end date.\r\n   * recurrence = moment(start).recur( end );\r\n   *\r\n   * // Finally, you can create a recurrence and pass in an entire set of options.\r\n   * recurrence = moment().recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"01/01/2015\"\r\n   * });\r\n   * ```\r\n   * From static moment:\r\n   * ```js\r\n   * // Create recurrence without a start date. Note: this will not work with intervals.\r\n   * recurrence = moment.recur();\r\n   *\r\n   * // Create a recurrence, passing just the start, or the start and end dates.\r\n   * recurrence = moment.recur( start, end );\r\n   *\r\n   * // Create a recurrence, passing set of options.\r\n   * recurrence = moment.recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"01/01/2015\"\r\n   * });\r\n   * ```\r\n   */\r\n  constructor (options: Recur.Options) {\r\n    if (options.start) {\r\n      this.start = moment(options.start).dateOnly()\r\n    }\r\n\r\n    if (options.end) {\r\n      this.end = moment(options.end).dateOnly()\r\n    }\r\n\r\n    // Our list of rules, all of which must match\r\n    this.rules = (options.rules || []).map(rule => Rule.factory(rule.units, rule.measure, this.start))\r\n\r\n    // Our list of exceptions. Match always fails on these dates.\r\n    const exceptions = options.exceptions || []\r\n    this.exceptions = exceptions.map(ex => moment(ex).dateOnly())\r\n\r\n    // Temporary units integer, array, or object. Does not get imported/exported.\r\n    this.units = null\r\n\r\n    // Temporary measure type. Does not get imported/exported.\r\n    this.measure = null\r\n\r\n    // Temporary from date for next/previous. Does not get imported/exported.\r\n    this.from = null\r\n\r\n    this.addMeasureFunctions()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Get/Set the Start Date\r\n   * ```js\r\n   * recurrence.startDate(); // Get\r\n   * recurrence.startDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public startDate (): Moment\r\n  public startDate (date: MomentInput | null): Recur\r\n  public startDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.start = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.start = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.start) {\r\n      throw new Error('No start date defined for recurrence.')\r\n    }\r\n    return this.start\r\n  }\r\n\r\n  /**\r\n   * Get/Set the End Date\r\n   * ```js\r\n   * recurrence.endDate(); // Get\r\n   * recurrence.endDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public endDate (): Moment\r\n  public endDate (date: MomentInput | null): Recur\r\n  public endDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.end = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.end = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.end) {\r\n      throw new Error('No end date defined for recurrence.')\r\n    }\r\n    return this.end\r\n  }\r\n\r\n  /**\r\n   * Get/Set a temporary \"From Date\" for use with generating dates\r\n   * ```js\r\n   * recurrence.fromDate(); // Get\r\n   * recurrence.fromDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public fromDate (): Moment\r\n  public fromDate (date: MomentInput | null): Recur\r\n  public fromDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.from = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.from = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.from) {\r\n      throw new Error('No from date defined for recurrence.')\r\n    }\r\n    return this.from\r\n  }\r\n\r\n  /**\r\n   * Interval calculations will use a default of 1000 year limit when determining unbounded\r\n   * rules. Use this function to query or change the maximum limit.\r\n   */\r\n  public maxYears (): number\r\n  public maxYears (years: number): Recur\r\n  public maxYears (years?: number): number | Recur {\r\n    if (years) {\r\n      this.maximumYears = years\r\n      return this\r\n    } else {\r\n      return this.maximumYears\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use `save()` to export all options, rules, and exceptions as an object.\r\n   * This can be used to store recurrences in a database.\r\n   * > Note: This does not export the \"From Date\" which is considered a temporary option.\r\n   * ```js\r\n   * recurrence.save();\r\n   * ```\r\n   */\r\n  public save (): Recur.Options {\r\n    const data: Recur.Options = {}\r\n\r\n    if (this.start && moment(this.start).isValid()) {\r\n      data.start = this.start.format(ISO_DATE_FMT)\r\n    }\r\n\r\n    if (this.end && moment(this.end).isValid()) {\r\n      data.end = this.end.format(ISO_DATE_FMT)\r\n    }\r\n\r\n    data.exceptions = this.exceptions.map(date => date.format(ISO_DATE_FMT))\r\n\r\n    data.rules = this.rules\r\n\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Use `repeats()` to check if a recurrence has rules set.\r\n   * ```js\r\n   * recurrence.repeats(); // true/false\r\n   * ```\r\n   */\r\n  public repeats (): boolean {\r\n    return this.rules.length > 0\r\n  }\r\n\r\n  /**\r\n   * The `every()` function allows you to set the units and, optionally, the measurment type\r\n   * of the recurring date. It returns the recur object to allow chaining.\r\n   *\r\n   *  ```js\r\n   *  let myDate, recurrence;\r\n   *\r\n   *  // Create a date to start from\r\n   *  myDate = moment(\"01/01/2014\");\r\n   *\r\n   *  // You can pass the units to recur on, and the measurement type.\r\n   *  recurrence = myDate.recur().every(1, \"days\");\r\n   *\r\n   *  // You can also chain the measurement type instead of passing it to every.\r\n   *  recurrence = myDate.recur().every(1).day();\r\n   *\r\n   *  // It is also possible to pass an array of units.\r\n   *  recurrence = myDate.recur().every([3, 5]).days();\r\n   *\r\n   *  // When using the dayOfWeek measurement, you can pass days names.\r\n   *  recurrence = myDate.recur().every([\"Monday\", \"wed\"]).daysOfWeek();\r\n   *\r\n   *  // Month names also work when using monthOfYear.\r\n   *  recurrence = myDate.recur().every([\"Jan\", \"february\"], \"monthsOfYear\");\r\n   *  ```\r\n   *\r\n   *  `every()` will override the last \"every\" if a measurement was not provided.\r\n   *  The following line will create a recurrence for every 5 days.\r\n   *  ```js\r\n   *  recurrence  = myDate.recur().every(1).every(5).days();\r\n   *  ```\r\n   *  If you need to specify multiple units, pass an array to `every()`.\r\n   *\r\n   *  You may also pass the units directly to the interval functions (listed below)\r\n   *  instead of using `every()`.\r\n   *  ```js\r\n   *  let recurrence = moment.recur().monthOfYear(\"January\");\r\n   *  ```\r\n   */\r\n  public every (units: Rule.UnitsInput, measure?: Rule.MeasureInput): this {\r\n\r\n    if (units != null) {\r\n      this.units = units\r\n    }\r\n\r\n    if (measure != null) {\r\n      this.measure = measure\r\n    }\r\n\r\n    // Don't create the rule until measure is defined\r\n    if (!this.measure) {\r\n      return this\r\n    }\r\n\r\n    const rule = Rule.factory(this.units, this.measure, this.start)\r\n\r\n    if (rule.measure === 'weeksOfMonthByDay' && !this.hasRule('daysOfWeek')) {\r\n      throw new Error('weeksOfMonthByDay must be combined with daysOfWeek')\r\n    }\r\n\r\n    // Remove the temporary rule data\r\n    this.units = null\r\n    this.measure = null\r\n\r\n    // Remove existing rule based on measure\r\n    this.rules = this.rules.filter(oldRule => oldRule.measure !== rule.measure)\r\n\r\n    this.rules.push(rule)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * To prevent a date from matching that would normally match, use the `except()` function.\r\n   * ```js\r\n   * let recurrence = moment(\"01/01/2014\").recur().every(1).day().except(\"01/02/2014\");\r\n   * recurrence.matches(\"01/02/2014\"); // false\r\n   * ```\r\n   */\r\n  public except (date: MomentInput): this {\r\n    date = moment(date).dateOnly()\r\n    this.exceptions.push(date)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Forgets rules (by passing measure) and exceptions (by passing date)\r\n   * ```js\r\n   * // Exceptions can be removed by passing a date to the forget() function.\r\n   * recurrence.forget(\"01/03/2014\");\r\n   * ```\r\n   * ```js\r\n   * // Rules can be removed by passing the measurement to the forget() function.\r\n   * recurrence.forget(\"days\");\r\n   * ```\r\n   */\r\n  public forget (dateOrRule: MomentInput | Rule.MeasureInput, format?: string): this {\r\n\r\n    if (!dateOrRule) {\r\n      throw new Error('Invalid input for recurrence forget: ' + dateOrRule)\r\n    }\r\n\r\n    try {\r\n      const normMeasure = Rule.normalizeMeasure(dateOrRule)\r\n      this.rules = this.rules.filter(rule => rule.measure !== normMeasure)\r\n      return this\r\n\r\n    } catch (err) {\r\n\r\n      let date = moment(dateOrRule, format)\r\n\r\n      // If valid date, try to remove it from exceptions\r\n      if (date.isValid()) {\r\n        date = date.dateOnly() // change to date only for perfect comparison\r\n        this.exceptions = this.exceptions.filter(exception => !date.isSame(exception))\r\n        return this\r\n      } else {\r\n        throw new Error('Invalid input for recurrence forget: ' + dateOrRule)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a rule has been set on the chain\r\n   */\r\n  public hasRule (measure: Rule.MeasureInput): boolean {\r\n    return this.rules.findIndex(rule => rule.measure === Rule.normalizeMeasure(measure)) !== -1\r\n  }\r\n\r\n  /**\r\n   * The `matches()` function will test a date to check if all of the recurrence rules match.\r\n   * It returns `true` if the date matches, `false` otherwise.\r\n   * ```js\r\n   * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n   * interval.matches(\"01/02/2014\"); // false\r\n   * interval.matches(\"01/03/2014\"); // true\r\n   * ```\r\n   *\r\n   * You may also see if a date matches before the start date or after the end date by\r\n   * passing `true` as the second argument to `matches()`.\r\n   * ```js\r\n   * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n   * interval.matches(\"12/30/2013\"); // false\r\n   * interval.matches(\"12/30/2013\", true); // true\r\n   * ```\r\n   */\r\n  public matches (dateToMatch: MomentInput, ignoreStartEnd?: boolean): boolean {\r\n    const date = moment(dateToMatch).dateOnly()\r\n\r\n    if (!date.isValid()) {\r\n      throw Error('Invalid date supplied to match method: ' + dateToMatch)\r\n    }\r\n\r\n    if (!ignoreStartEnd && !this.inRange(date)) {\r\n      return false\r\n    }\r\n\r\n    if (this.isException(date)) {\r\n      return false\r\n    }\r\n\r\n    if (!this.matchAllRules(date)) {\r\n      return false\r\n    }\r\n\r\n    // if we passed everything above, then this date matches\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Iterate over moments matched by rules\r\n   * > Note if there is no end date, results are unbounded (you must manually terminate the iterator).\r\n   *\r\n   * > Also note, this exapmle intentionally ignores some complicated leap year math.\r\n   *\r\n   * ```js\r\n   * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n   * let leapYears = [...recurrence].map(m => m.year())\r\n   * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n   * ```\r\n   * Or, this is a bit faster...\r\n   * ```js\r\n   * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n   * let leapYears = []\r\n   * for (let date of recurrence) {\r\n   *   leapYears.push(date.year())\r\n   * }\r\n   * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n   * ```\r\n   */\r\n  public *[Symbol.iterator] (): IterableIterator<Moment> {\r\n\r\n    const startFrom = this.from || this.start\r\n    if (!startFrom || !startFrom.isValid()) {\r\n      throw Error('Cannot get occurrences without start or from date.')\r\n    }\r\n\r\n    if (this.end && (startFrom > this.end)) {\r\n      throw Error('Start date cannot be later than end date.')\r\n    }\r\n\r\n    let currentDate = startFrom.clone()\r\n\r\n    // yield the starting date if it's a match\r\n    if (this.matchAllRules(currentDate)) {\r\n      yield currentDate.clone()\r\n    }\r\n\r\n    while (true) {\r\n\r\n      try {\r\n        currentDate = this.reversed ?\r\n          this.findPreviousMatch(currentDate) :\r\n          this.findNextMatch(currentDate)\r\n      } catch (err) {\r\n        /* istanbul ignore else */\r\n        if (err instanceof RangeError) return undefined\r\n        else throw err\r\n      }\r\n\r\n      if (this.end && currentDate.isAfter(this.end)) break\r\n\r\n      if (!this.isException(currentDate)) {\r\n        yield currentDate.clone()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reverse iterator direction\r\n   * > Note since there is no end date, results are unbounded (you must manually terminate the iterator).\r\n   *\r\n   * ```js\r\n   * let mondays = []\r\n   * for (let monday of moment().recur().every('Monday').dayOfWeek().reverse()) {\r\n   *   lastThreeMondays.push(monday)\r\n   *   if (mondays.length > 10) break\r\n   * }\r\n   * ```\r\n   */\r\n  public reverse (): this {\r\n    this.reversed = !this.reversed\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * With both a start date and an end date set, you can generate all dates within\r\n   * that range that match the pattern (including the start/end dates).\r\n   *\r\n   * ```js\r\n   * let recurrence = moment().recur(\"01/01/2014\", \"01/07/2014\").every(2).days();\r\n   *\r\n   * // Outputs: [\"01/01/2014\", \"01/03/2014\", \"01/05/2014\", \"01/07/2014\"]\r\n   * allDates = recurrence.all(\"L\");\r\n   * ```\r\n   */\r\n  public all (): Moment[]\r\n  public all (format: string): string[]\r\n  public all (format?: string): (string | Moment)[] {\r\n\r\n    if (!this.end || !this.end.isValid()) {\r\n      throw Error('Cannot get all occurrences without an end date.')\r\n    }\r\n\r\n    this.reversed = false\r\n\r\n    const dates: (string | Moment)[] = []\r\n    for (const date of this) {\r\n      dates.push(format ? date.format(format) : date)\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * Get next N occurrences\r\n   * ```js\r\n   * // Generate the next three dates as moments\r\n   * // Outputs: [moment(\"01/03/2014\"), moment(\"01/05/2014\"), moment(\"01/07/2014\")]\r\n   * nextDates = recurrence.next(3);\r\n   * ```\r\n   * ```js\r\n   * // Generate the next three dates, formatted in local format\r\n   * // Outputs: [\"01/03/2014\", \"01/05/2014\", \"01/07/2014\"]\r\n   * nextDates = recurrence.next(3, \"L\");\r\n   * ```\r\n   */\r\n  public next (num: number): Moment[]\r\n  public next (num: number, format: string): string[]\r\n  public next (num: number, format?: string): (string | Moment)[] {\r\n    if (!num) return []\r\n    const dates: (string | Moment)[] = []\r\n    let count = 0\r\n    this.reversed = false\r\n    for (const date of this) {\r\n      if (!(this.start && date.isSame(this.start))) {\r\n        dates.push(format ? date.format(format) : date)\r\n        count++\r\n      }\r\n      if (count >= num) break\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * Get previous N occurrences\r\n   * ```js\r\n   * // Generate previous three dates, formatted in local format\r\n   * // Outputs: [\"12/30/2013\", \"12/28/2013\", \"12/26/2013\"]\r\n   * nextDates = recurrence.previous(3, \"L\");\r\n   * ```\r\n   */\r\n  public previous (num: number): Moment[]\r\n  public previous (num: number, format: string): string[]\r\n  public previous (num?: number, format?: string): (string | Moment)[] {\r\n    if (!num) return []\r\n    const dates: (string | Moment)[] = []\r\n    let count = 0\r\n    this.reversed = true\r\n    for (const date of this) {\r\n      if (!(this.start && date.isSame(this.start))) {\r\n        dates.push(format ? date.format(format) : date)\r\n        count++\r\n      }\r\n      if (count >= num) break\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private addMeasureFunctions (): void {\r\n    for (const measureSingle of Object.keys(Rule.MeasureSingleToPlural)) {\r\n      const measurePlural = Rule.MeasureSingleToPlural[measureSingle];\r\n      (Recur as any).prototype[measureSingle] = (units?: Rule.UnitsInput): this => {\r\n        this.every(units, measurePlural)\r\n        return this\r\n      }\r\n      (Recur as any).prototype[measurePlural] = (units?: Rule.UnitsInput): this => {\r\n        this.every(units, measurePlural)\r\n        return this\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to see if a date is within range of start/end\r\n   * @internal\r\n   */\r\n  private inRange (date: Moment): boolean {\r\n    if (this.start && date.isBefore(this.start)) {\r\n      return false\r\n    } else if (this.end && date.isAfter(this.end)) {\r\n      return false\r\n    } else {\r\n      return true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to check if a date is an exception\r\n   * @internal\r\n   */\r\n  private isException (date: MomentInput): boolean {\r\n\r\n    for (const exception of this.exceptions) {\r\n      if (moment(exception).isSame(date)) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private matchAllRules (date: Moment): boolean {\r\n\r\n    for (const rule of this.rules) {\r\n      if (!rule.match(date)) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private findNextMatch (currentDate: Moment): Moment {\r\n\r\n    let nextDate = currentDate.clone().add(1, 'day')\r\n    const limit = currentDate.clone().add(this.maximumYears, 'years')\r\n\r\n    let allRulesMatch = false\r\n    while (!allRulesMatch) {\r\n      // if (nextDate.year() >= currentDate.year() + this.maximumYears) {\r\n      //   throw new RangeError()\r\n      // }\r\n      nextDate.subtract(1, 'day')\r\n      const nextDates = this.rules.map(rule => rule.next(nextDate, limit))\r\n      nextDates.sort((a, b) => a.diff(b))\r\n      nextDate = nextDates[nextDates.length - 1]\r\n      allRulesMatch = nextDate.isSame(nextDates[0])\r\n    }\r\n\r\n    return nextDate\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private findPreviousMatch (currentDate: Moment): Moment {\r\n\r\n    let nextDate = currentDate.clone().subtract(1, 'day')\r\n    const limit = currentDate.clone().subtract(this.maximumYears, 'years')\r\n\r\n    let allRulesMatch = false\r\n    while (!allRulesMatch) {\r\n      // if (nextDate.year() <= currentDate.year() - this.maximumYears) {\r\n      //   throw new RangeError()\r\n      // }\r\n      nextDate.add(1, 'day')\r\n      const nextDates = this.rules.map(rule => rule.previous(nextDate, limit))\r\n      nextDates.sort((a, b) => b.diff(a))\r\n      nextDate = nextDates[nextDates.length - 1]\r\n      allRulesMatch = nextDate.isSame(nextDates[0])\r\n    }\r\n\r\n    return nextDate\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/recur.ts","import * as moment from 'moment'\r\nimport { Calendar } from './calendar'\r\nimport { Interval } from './interval'\r\n\r\nexport namespace Rule {\r\n  export type MeasureSingle =\r\n    'day'\r\n    | 'week'\r\n    | 'month'\r\n    | 'year'\r\n    | 'dayOfWeek'\r\n    | 'dayOfMonth'\r\n    | 'weekOfMonth'\r\n    | 'weekOfMonthByDay'\r\n    | 'weekOfYear'\r\n    | 'monthOfYear'\r\n\r\n  export type MeasurePlural =\r\n    'days'\r\n    | 'weeks'\r\n    | 'months'\r\n    | 'years'\r\n    | 'daysOfWeek'\r\n    | 'daysOfMonth'\r\n    | 'weeksOfMonth'\r\n    | 'weeksOfMonthByDay'\r\n    | 'weeksOfYear'\r\n    | 'monthsOfYear'\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export const MeasureSingleToPlural: {\r\n    [m: string]: MeasurePlural\r\n  } = {\r\n    day: 'days',\r\n    week: 'weeks',\r\n    month: 'months',\r\n    year: 'years',\r\n    dayOfWeek: 'daysOfWeek',\r\n    dayOfMonth: 'daysOfMonth',\r\n    weekOfMonth: 'weeksOfMonth',\r\n    weekOfMonthByDay: 'weeksOfMonthByDay',\r\n    weekOfYear: 'weeksOfYear',\r\n    monthOfYear: 'monthsOfYear'\r\n  }\r\n\r\n  export type UnitsInput = string | number | (string | number)[] | UnitsObject | undefined | null\r\n\r\n  /**\r\n   * @hidden\r\n   * @deprecated\r\n   */\r\n  export interface UnitsObject {\r\n    [unit: string]: boolean\r\n\r\n    [unit: number]: boolean\r\n  }\r\n\r\n  export type MeasureInput = MeasureSingle | MeasurePlural | undefined | null\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export function factory (units: UnitsInput, measure: MeasureInput, start: moment.Moment | null): Rule {\r\n\r\n    const normMeasure = normalizeMeasure(measure)\r\n\r\n    switch (normMeasure) {\r\n      case 'days':\r\n      case 'weeks':\r\n      case 'months':\r\n      case 'years':\r\n        return new Interval(unitsToArray(units), normMeasure, start)\r\n\r\n      case 'daysOfWeek':\r\n      case 'daysOfMonth':\r\n      case 'weeksOfMonth':\r\n      case 'weeksOfMonthByDay':\r\n      case 'weeksOfYear':\r\n      case 'monthsOfYear':\r\n        return new Calendar(unitsToArray(units), normMeasure)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  function unitsToArray (units: UnitsInput): (string | number)[] {\r\n\r\n    if (units == null) {\r\n      throw new Error('Units not defined for recurrence rule.')\r\n    } else if (Array.isArray(units)) {\r\n      return units\r\n    } else if (typeof units === 'object') {\r\n      return Object.keys(units)\r\n    } else if (typeof units === 'number') {\r\n      return [units]\r\n      // tslint:disable-next-line:strict-type-predicates\r\n    } else if (typeof units === 'string') {\r\n      return [units]\r\n    } else {\r\n      throw new Error('Provide an array, object, string or number when passing units!')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to pluralize measure names for use with dictionaries.\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export function normalizeMeasure (measure: any): MeasurePlural {\r\n    if (typeof measure === 'string') {\r\n      if (MeasureSingleToPlural[measure]) {\r\n        return MeasureSingleToPlural[measure]\r\n      } else {\r\n        for (const key in MeasureSingleToPlural) {\r\n          if (MeasureSingleToPlural[key] === measure) return measure\r\n        }\r\n      }\r\n    }\r\n    throw new Error('Invalid Measure for recurrence: ' + measure)\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport interface Rule {\r\n\r\n  readonly units: number[]\r\n  readonly measure: Rule.MeasurePlural\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  match (date: moment.Moment): boolean\r\n\r\n  next (current: moment.Moment, limit?: moment.Moment): moment.Moment\r\n\r\n  previous (current: moment.Moment, limit?: moment.Moment): moment.Moment\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/rule.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nexport type CalendarMeasure =\r\n  'daysOfWeek'\r\n  | 'daysOfMonth'\r\n  | 'weeksOfMonth'\r\n  | 'weeksOfMonthByDay'\r\n  | 'weeksOfYear'\r\n  | 'monthsOfYear'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\ntype TimeUnits = 'day' | 'month' | 'week' | 'year'\r\n\r\n/**\r\n * Calendar object for creating and matching calendar-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nexport class Calendar implements Rule {\r\n\r\n  private static readonly ranges: {\r\n    [key: string]: {\r\n      period: TimeUnits\r\n      range: TimeUnits\r\n      low: number\r\n      high: number\r\n    }\r\n  } = {\r\n    daysOfWeek: {\r\n      period: 'day',\r\n      range: 'week',\r\n      low: 0,\r\n      high: 6\r\n    },\r\n    daysOfMonth: {\r\n      period: 'day',\r\n      range: 'month',\r\n      low: 1,\r\n      high: 31\r\n    },\r\n    weeksOfMonth: {\r\n      period: 'week',\r\n      range: 'month',\r\n      low: 0,\r\n      high: 4\r\n    },\r\n    weeksOfMonthByDay: {\r\n      period: 'week',\r\n      range: 'month',\r\n      low: 0,\r\n      high: 4\r\n    },\r\n    weeksOfYear: {\r\n      period: 'week',\r\n      range: 'year',\r\n      low: 1,\r\n      high: 53\r\n    },\r\n    monthsOfYear: {\r\n      period: 'month',\r\n      range: 'year',\r\n      low: 0,\r\n      high: 11\r\n    }\r\n  }\r\n\r\n  public readonly units: number[]\r\n  public readonly measure: CalendarMeasure\r\n\r\n  private readonly range: TimeUnits\r\n  private readonly period: TimeUnits\r\n\r\n  constructor (units: (string | number)[], measure: CalendarMeasure) {\r\n\r\n    this.measure = measure\r\n    this.units = this.normalizeUnits(units)\r\n\r\n    this.range = Calendar.ranges[this.measure].range\r\n    this.period = Calendar.ranges[this.measure].period\r\n  }\r\n\r\n  public match (date: moment.Moment): boolean {\r\n\r\n    // Get the unit based on the required measure of the date\r\n    const unit = this.periodUnit(date)\r\n\r\n    // If the unit is in our list, return true, else return false\r\n    if (this.units.indexOf(unit) !== -1) {\r\n      return true\r\n    }\r\n    if ((this.units[0] === -1) &&\r\n      (unit === this.periodUnit(moment(date).endOf(this.range)))) {\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  public next (currentDateIn: moment.Moment, limit: moment.Moment): moment.Moment {\r\n\r\n    let currentDate = currentDateIn.clone()\r\n    // If still within our period, just give the next day\r\n    if (!this.isLastDayOfPeriod(currentDate)) {\r\n      const nextDateInPeriod = moment(currentDate).add(1, 'day')\r\n      if (this.match(nextDateInPeriod)) return nextDateInPeriod\r\n    }\r\n\r\n    while (true) {\r\n      // Get the next period based on the measure\r\n      const nextDate = this.nextPeriod(currentDate)\r\n      if (nextDate) {\r\n        return nextDate\r\n      } else {\r\n        // No more units found within this range,\r\n        // bump our range by one and try again.\r\n        currentDate = this.incrementRange(currentDate, 1)\r\n\r\n        // Check to see if next range starts on a valid period\r\n        if (this.match(currentDate)) {\r\n          return currentDate\r\n        }\r\n\r\n        if (currentDate.isSameOrAfter(limit)) {\r\n          throw new RangeError('Recurrence Year limit exceeded.')\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public previous (currentDateIn: moment.Moment, limit: moment.Moment): moment.Moment {\r\n\r\n    let currentDate = currentDateIn.clone()\r\n    // If still within our period, just give the next day\r\n    if (!this.isFirstDayOfPeriod(currentDate)) {\r\n      const nextDateInPeriod = moment(currentDate).subtract(1, 'day')\r\n      if (this.match(nextDateInPeriod)) return nextDateInPeriod\r\n    }\r\n\r\n    while (true) {\r\n      // Get the next period based on the measure\r\n      const nextDate = this.previousPeriod(currentDate)\r\n      if (nextDate) {\r\n        return nextDate\r\n      } else {\r\n        // No more units found within this range,\r\n        // bump our range by one and try again.\r\n        currentDate = this.decrementRange(currentDate, 1)\r\n\r\n        // Check to see if next range starts on a valid period\r\n        if (this.match(currentDate)) {\r\n          return currentDate\r\n        }\r\n\r\n        if (currentDate.isSameOrBefore(limit)) {\r\n          throw new RangeError('Recurrence Year limit exceeded.')\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private normalizeUnits (units: any[]): number[] {\r\n\r\n    const low = Calendar.ranges[this.measure].low\r\n    const high = Calendar.ranges[this.measure].high\r\n\r\n    return units.map(unitIn => {\r\n      if (unitIn === 'last') unitIn = -1\r\n      if (typeof unitIn !== 'number') {\r\n        // Convert day/month names to numbers, if needed\r\n        if (this.measure === 'daysOfWeek') {\r\n          unitIn = moment().set('days', unitIn).get('days')\r\n        } else if (this.measure === 'monthsOfYear') {\r\n          unitIn = moment().set('months', unitIn).get('months')\r\n        } else {\r\n          unitIn = +unitIn\r\n        }\r\n      }\r\n      if (!Number.isInteger(unitIn)) {\r\n        throw new TypeError('Invalid calendar unit in recurrence: ' + unitIn)\r\n      }\r\n      if ((unitIn < low || unitIn > high) && (unitIn !== -1)) {\r\n        throw new RangeError('Value should be in range ' + low + ' to ' + high)\r\n      }\r\n      return unitIn\r\n    }).sort((a, b) => a - b)\r\n  }\r\n\r\n  private periodUnit (date: moment.Moment): number\r\n  private periodUnit (date: moment.Moment, unit: number): moment.Moment\r\n  private periodUnit (date: moment.Moment, unit?: number): number | moment.Moment {\r\n    switch (this.measure) {\r\n      case 'daysOfWeek':\r\n        return date.day(unit!)\r\n      case 'daysOfMonth':\r\n        return date.date(unit!)\r\n      case 'weeksOfMonth':\r\n        return date.monthWeek(unit!)\r\n      case 'weeksOfMonthByDay':\r\n        return date.monthWeekByDay(unit!)\r\n      case 'weeksOfYear':\r\n        return date.week(unit!)\r\n      case 'monthsOfYear':\r\n        return date.month(unit!)\r\n    }\r\n  }\r\n\r\n  private nextPeriod (date: moment.Moment): moment.Moment | undefined {\r\n    // Get the next period based on the measure\r\n    const currentUnit = this.periodUnit(date)\r\n\r\n    const nextUnit = this.units\r\n      .map(unit => unit === -1 ? this.periodUnit(date.clone().endOf(this.range)) : unit)\r\n      .find(unit => unit > currentUnit)\r\n\r\n    if (nextUnit !== undefined) {\r\n      return this.periodUnit(date.clone(), nextUnit).startOf(this.period)\r\n    } else {\r\n\r\n      // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n      if (this.measure === 'weeksOfYear' && (this.units.indexOf(1) !== -1)) {\r\n        return date.clone().endOf('year').startOf('week')\r\n      }\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  private previousPeriod (date: moment.Moment): moment.Moment | undefined {\r\n    // Get the next period based on the measure\r\n    let currentUnit = this.periodUnit(date)\r\n    if (this.measure === 'weeksOfYear' && date.month() === 11 && date.week() === 1) currentUnit = 53\r\n\r\n    const nextUnit = this.units\r\n      .map(unit => unit === -1 ? this.periodUnit(date.clone().endOf(this.range)) : unit)\r\n      .reverse().find(unit => unit < currentUnit)\r\n\r\n    if (nextUnit !== undefined) {\r\n      if (this.measure === 'weeksOfYear' && currentUnit === 53) date.week(0)\r\n      return this.periodUnit(date.clone(), nextUnit).endOf(this.period)\r\n    } else {\r\n\r\n      // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n      if (this.measure === 'weeksOfYear' &&\r\n        this.units.some(u => 52 >= u && u <= 53)) {\r\n        return date.clone().startOf('year').endOf('week')\r\n      }\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  private incrementRange (date: moment.Moment, count: number): moment.Moment {\r\n    return date.add(count, this.range).startOf(this.range)\r\n  }\r\n\r\n  private decrementRange (date: moment.Moment, count: number): moment.Moment {\r\n    return date.subtract(count, this.range).endOf(this.range)\r\n  }\r\n\r\n  private isLastDayOfPeriod (date: moment.Moment): boolean {\r\n    if (this.measure === 'weeksOfMonthByDay') {\r\n      return date.monthWeekByDay() !== moment(date).add(1, 'day').monthWeekByDay()\r\n    }\r\n\r\n    if (this.period === 'day') {\r\n      return true\r\n    } else {\r\n      return date.isSame(moment(date).endOf(this.period))\r\n    }\r\n  }\r\n\r\n  private isFirstDayOfPeriod (date: moment.Moment): boolean {\r\n    if (this.measure === 'weeksOfMonthByDay') {\r\n      return date.monthWeekByDay() !== moment(date).subtract(1, 'day').monthWeekByDay()\r\n    }\r\n\r\n    if (this.period === 'day') {\r\n      return true\r\n    } else {\r\n      return date.isSame(moment(date).startOf(this.period))\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/calendar.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nexport type IntervalMeasure = 'days' | 'weeks' | 'months' | 'years'\r\n\r\n/**\r\n * Interval object for creating and matching interval-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nexport class Interval implements Rule {\r\n\r\n  public readonly units: number[]\r\n  public readonly measure: IntervalMeasure\r\n\r\n  private start: moment.Moment\r\n\r\n  constructor (units: (string | number)[], measure: IntervalMeasure, start: moment.Moment | null) {\r\n\r\n    if (!start) {\r\n      throw new Error('Must have a start date set to set an interval!')\r\n    }\r\n    this.start = start.clone()\r\n\r\n    this.measure = measure\r\n    this.units = this.normalizeUnits(units)\r\n  }\r\n\r\n  public match (date: moment.Moment): boolean {\r\n\r\n    const precise = this.measure !== 'days'\r\n    const diff = Math.abs(this.start.diff(date, this.measure, precise))\r\n\r\n    // Check to see if any of the units provided match the date\r\n    for (const unit of this.units) {\r\n      // If the units divide evenly into the difference, we have a match\r\n      if ((diff % unit) === 0) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  public next (currentDate: moment.Moment): moment.Moment {\r\n\r\n    // let precise = this.measure !== 'days'\r\n    // Get the multiple of the start\r\n    const diff = currentDate.diff(this.start, this.measure)\r\n\r\n    // Find the next muliple for each unit\r\n    const multiples = this.units.map(unit => (Math.floor(diff / unit) + 1) * unit)\r\n    multiples.sort((a, b) => a - b)\r\n\r\n    return this.start.clone().add(multiples[0], this.measure)\r\n  }\r\n\r\n  public previous (currentDate: moment.Moment): moment.Moment {\r\n\r\n    // let precise = this.measure !== 'days'\r\n    // Get the multiple of the start\r\n    const diff = this.start.diff(currentDate, this.measure)\r\n\r\n    // Find the next muliple for each unit\r\n    const multiples = this.units.map(unit => (Math.floor(diff / unit) + 1) * unit)\r\n    multiples.sort((a, b) => b - a)\r\n\r\n    return this.start.clone().subtract(multiples[0], this.measure)\r\n  }\r\n\r\n  private normalizeUnits (units: any[]): number[] {\r\n\r\n    // Make sure all of the units are integers greater than 0.\r\n    return units.map(unit => {\r\n      unit = +unit\r\n      if (unit <= 0) {\r\n        throw new Error('Intervals must be greater than zero.')\r\n      }\r\n      if (!Number.isInteger(unit)) {\r\n        throw new Error('Intervals must be integers.')\r\n      }\r\n      return unit\r\n    }).sort((a, b) => a - b)\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/interval.ts"],"sourceRoot":""}