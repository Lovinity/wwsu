{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9766912eb0d4753f9896","webpack:///external \"moment\"","webpack:///./src/index.ts","webpack:///./src/recur.ts","webpack:///./src/rule.ts","webpack:///./src/calendar.ts","webpack:///./src/interval.ts"],"names":[],"mappings":"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","file":"moment-recur-ts.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moment-recur-ts\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moment-recur-ts\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"moment-recur-ts\"] = factory(root[\"moment\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9766912eb0d4753f9896","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 0\n// module chunks = 0 1","import * as moment from 'moment'\r\nimport { Recur } from './recur'\r\n\r\ndeclare module 'moment' {\r\n\r\n  interface Moment {\r\n\r\n    /**\r\n     * The `monthWeek()` method can be used to determine the week of the month a date is in.\r\n     * ```js\r\n     * moment(\"01/01/2014\").monthWeek(); // 0\r\n     * ```\r\n     */\r\n    monthWeek (): number\r\n    monthWeek (week: number): moment.Moment\r\n\r\n    /**\r\n     * Plugin for calculating the occurrence of the day of the week in the month.\r\n     * Similar to `moment().monthWeek()`, the return value is zero-indexed.\r\n     * A return value of 2 means the date is the 3rd occurence of that day\r\n     * of the week in the month.\r\n     */\r\n    monthWeekByDay (): number\r\n    monthWeekByDay (dayCount: number): moment.Moment\r\n\r\n    /**\r\n     * The `dateOnly()` method can be used to remove any time information from a moment.\r\n     * ```js\r\n     * moment(\"2014-01-01 09:30:26\").dateOnly(); // 01/01/2014 12:00:00 AM\r\n     * ```\r\n     */\r\n    dateOnly (): moment.Moment\r\n\r\n    /**\r\n     * Recur can also be created the following ways:\r\n     * ```js\r\n     * moment().recur()\r\n     * moment().recur(options)\r\n     * moment().recur(start, end)\r\n     * moment(start).recur(end)\r\n     * moment().recur(end)\r\n     * ```\r\n     */\r\n    recur (start?: moment.MomentInput, end?: moment.MomentInput): Recur\r\n    recur (options?: Recur.Options): Recur\r\n\r\n    /**\r\n     * @internal\r\n     * @hidden\r\n     */\r\n    set (unit: moment.unitOfTime.All, value: number | string): moment.Moment\r\n  }\r\n\r\n  /**\r\n   * Recur can be created the following ways:\r\n   * ```js\r\n   * moment.recur()\r\n   * moment.recur(options)\r\n   * moment.recur(start)\r\n   * moment.recur(start, end)\r\n   * ```\r\n   */\r\n  function recur (start?: moment.MomentInput, end?: moment.MomentInput): Recur\r\n  function recur (options?: Recur.Options): Recur\r\n}\r\n\r\nmoment.fn.monthWeek = function (this: moment.Moment, week?: number): number | moment.Moment {\r\n\r\n  if (week === undefined) {\r\n    // First day of the first week of the month\r\n    const week0 = this.clone().startOf('month').startOf('week')\r\n\r\n    // First day of week\r\n    const day0 = this.clone().startOf('week')\r\n\r\n    return day0.diff(week0, 'weeks')\r\n  } else {\r\n    const weekDiff = week - this.monthWeek()\r\n    return this.clone().add(weekDiff, 'weeks')\r\n  }\r\n} as {(): number, (w: number): moment.Moment}\r\n\r\nmoment.fn.monthWeekByDay = function (this: moment.Moment, week?: number): number | moment.Moment {\r\n  if (week === undefined) {\r\n    return Math.floor((this.date() - 1) / 7)\r\n  } else {\r\n    const weekDiff = week - this.monthWeekByDay()\r\n    return this.clone().add(weekDiff, 'weeks')\r\n  }\r\n} as {(): number, (w: number): moment.Moment}\r\n\r\n// Plugin for removing all time information from a given date\r\nmoment.fn.dateOnly = function (): moment.Moment {\r\n  // return this.startOf('day')\r\n  return this.isValid() ? moment.utc(this.format('YYYY-MM-DD')) : this\r\n}\r\n\r\n;\r\n(moment as any).recur = function (start?: moment.MomentInput | Recur.Options,\r\n                                  end?: moment.MomentInput): Recur {\r\n  // If we have an object, use it as a set of options\r\n  if (typeof start === 'object' && !moment.isMoment(start)) {\r\n    const options = start as Recur.Options\r\n    return new Recur(options)\r\n  }\r\n\r\n  // else, use the values passed\r\n  return new Recur({ start, end })\r\n}\r\n\r\nmoment.fn.recur = function (this: moment.Moment,\r\n                            start?: moment.MomentInput | Recur.Options,\r\n                            end?: moment.MomentInput): Recur {\r\n  // If we have an object, use it as a set of options\r\n  if (start === Object(start) && !moment.isMoment(start)) {\r\n    const options = start as Recur.Options\r\n    // if we have no start date, use the moment\r\n    if (options.start === undefined) {\r\n      options.start = this\r\n    }\r\n\r\n    return new Recur(options)\r\n  }\r\n\r\n  // if there is no end value, use the start value as the end\r\n  if (!end) {\r\n    end = start as moment.MomentInput\r\n    start = undefined\r\n  }\r\n\r\n  // use the moment for the start value\r\n  if (!start) {\r\n    start = this\r\n  }\r\n\r\n  return new Recur({ start: start as moment.MomentInput, end })\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/** @hidden */\r\nexport type Moment = moment.Moment\r\n/** @hidden */\r\nexport type MomentInput = moment.MomentInput\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nconst ISO_DATE_FMT = 'YYYY-MM-DD'\r\n\r\nexport namespace Recur {\r\n  /**\r\n   * Set options upon creation.\r\n   *\r\n   * > Note that the units for rules are converted to objects,\r\n   * > so it is not recommended to set rules this way.\r\n   * > They can be set in the options so that they can be imported.\r\n   *\r\n   * ```js\r\n   * moment().recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"12/31/2014\",\r\n   *   rules: [\r\n   *     { units: [2], measure: \"days\" }\r\n   *   ],\r\n   *   exceptions: [\"01/05/2014\"]\r\n   * });\r\n   * ```\r\n   */\r\n  export interface Options {\r\n    start?: MomentInput\r\n    end?: MomentInput\r\n    rules?: {\r\n      units: Rule.UnitsInput\r\n      measure: Rule.MeasureInput\r\n    }[]\r\n    exceptions?: MomentInput[]\r\n  }\r\n}\r\n\r\nexport interface Recur {\r\n\r\n  days (units?: Rule.UnitsInput): this\r\n  day (units?: Rule.UnitsInput): this\r\n\r\n  weeks (units?: Rule.UnitsInput): this\r\n  week (units?: Rule.UnitsInput): this\r\n\r\n  months (units?: Rule.UnitsInput): this\r\n  month (units?: Rule.UnitsInput): this\r\n\r\n  years (units?: Rule.UnitsInput): this\r\n  year (units?: Rule.UnitsInput): this\r\n\r\n  daysOfWeek (units?: Rule.UnitsInput): this\r\n  dayOfWeek (units?: Rule.UnitsInput): this\r\n\r\n  daysOfMonth (units?: Rule.UnitsInput): this\r\n  dayOfMonth (units?: Rule.UnitsInput): this\r\n\r\n  weeksOfMonth (units?: Rule.UnitsInput): this\r\n  weekOfMonth (units?: Rule.UnitsInput): this\r\n\r\n  weeksOfYear (units?: Rule.UnitsInput): this\r\n  weekOfYear (units?: Rule.UnitsInput): this\r\n\r\n  /**\r\n   * ```js\r\n   * // Will match any date that is in January of any year.\r\n   * cal = moment.recur().every(\"January\").monthsOfYear();\r\n   * ```\r\n   */\r\n  monthsOfYear (units?: Rule.UnitsInput): Recur\r\n  monthOfYear (units?: Rule.UnitsInput): Recur\r\n\r\n  /**\r\n   * A weekOfMonthByDay interval is available for combining with the daysOfWeek to\r\n   * achieve \"nth weekday of month\" recurrences. The following matches every 1st\r\n   * and 3rd Thursday of the month.\r\n   * > (Note this cannot be combined at the moment with every(x).months() expression)\r\n   *\r\n   * ```js\r\n   * cal = moment.recur()\r\n   *   .every(\"Thursday\").daysOfWeek()\r\n   *   .every([0, 2]).weeksOfMonthByDay();\r\n   * ```\r\n   * ```js\r\n   * cal = moment.recur()\r\n   *   .every(moment(\"01/01/2014\").day()).daysOfWeek()\r\n   *   .every(moment(\"01/01/2014\").monthWeekByDay()).weeksOfMonthByDay();\r\n   * ```\r\n   */\r\n  weeksOfMonthByDay (units?: Rule.UnitsInput): Recur\r\n  weekOfMonthByDay (units?: Rule.UnitsInput): Recur\r\n}\r\n\r\n/**\r\n * The main Recur object to provide an interface for settings, rules, and matching\r\n *\r\n * Creating Rules\r\n * --------------\r\n * moment-recur-ts uses rules to define when a date should recur. You can then generate future\r\n * or past recurrences based on these rules, or see if a specific date matches the rules.\r\n * Rules can also be overridden or removed.\r\n *\r\n * ### Length Intervals\r\n * moment-recur-ts supports intervals for days, weeks, months, and years. Measurements may be singular or\r\n * plural (ex: `day()` vs `days()`). Length Intervals **must** have a start date defined.\r\n *\r\n * Possible Length Intervals Include:\r\n * * day / days\r\n * * week / weeks\r\n * * month / months\r\n * * year / years\r\n *\r\n * ### Calendar Intervals\r\n * Calendar Intervals do not depend on a start date. They define a unit of another unit. For instance,\r\n * a day of a month, or a month of a year. Measurements may be singular or plural\r\n * (ex: `dayOfMonth()` vs `daysOfMonth()`).\r\n *\r\n * Possible Calendar Intervals Include:\r\n * * dayOfWeek / daysOfWeek\r\n * * dayOfMonth / daysOfMonth\r\n * * weekOfMonth / weeksOfMonth\r\n * * weekOfYear / weeksOfYear\r\n * * monthOfYear / monthsOfYear\r\n */\r\nexport class Recur implements Iterable<moment.Moment> {\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected start: Moment | null\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected end: Moment | null\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  protected from: Moment | null\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private rules: Rule[]\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private exceptions: Moment[]\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private units: Rule.UnitsInput\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private measure: Rule.MeasureInput\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private reversed = false\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private maximumYears = 1000\r\n\r\n  /**\r\n   * ### Recur Object Constrcutor\r\n   *\r\n   * From an instance of moment:\r\n   * ```js\r\n   * let recurrence;\r\n   *\r\n   * // Create a recurrence using today as the start date.\r\n   * recurrence = moment().recur();\r\n   *\r\n   * // Create a recurrence while passing the start and end dates to the recur function.\r\n   * // Note: passing an end date requires you to also pass a start date.\r\n   * recurrence = moment().recur( start, end );\r\n   *\r\n   * // You may pass a start date to the moment, or use an existing moment, to set the start date.\r\n   * // In this case, passing a date to the recur function sets and end date.\r\n   * recurrence = moment(start).recur( end );\r\n   *\r\n   * // Finally, you can create a recurrence and pass in an entire set of options.\r\n   * recurrence = moment().recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"01/01/2015\"\r\n   * });\r\n   * ```\r\n   * From static moment:\r\n   * ```js\r\n   * // Create recurrence without a start date. Note: this will not work with intervals.\r\n   * recurrence = moment.recur();\r\n   *\r\n   * // Create a recurrence, passing just the start, or the start and end dates.\r\n   * recurrence = moment.recur( start, end );\r\n   *\r\n   * // Create a recurrence, passing set of options.\r\n   * recurrence = moment.recur({\r\n   *   start: \"01/01/2014\",\r\n   *   end: \"01/01/2015\"\r\n   * });\r\n   * ```\r\n   */\r\n  constructor (options: Recur.Options) {\r\n    if (options.start) {\r\n      this.start = moment(options.start).dateOnly()\r\n    }\r\n\r\n    if (options.end) {\r\n      this.end = moment(options.end).dateOnly()\r\n    }\r\n\r\n    // Our list of rules, all of which must match\r\n    this.rules = (options.rules || []).map(rule => Rule.factory(rule.units, rule.measure, this.start))\r\n\r\n    // Our list of exceptions. Match always fails on these dates.\r\n    const exceptions = options.exceptions || []\r\n    this.exceptions = exceptions.map(ex => moment(ex).dateOnly())\r\n\r\n    // Temporary units integer, array, or object. Does not get imported/exported.\r\n    this.units = null\r\n\r\n    // Temporary measure type. Does not get imported/exported.\r\n    this.measure = null\r\n\r\n    // Temporary from date for next/previous. Does not get imported/exported.\r\n    this.from = null\r\n\r\n    this.addMeasureFunctions()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Get/Set the Start Date\r\n   * ```js\r\n   * recurrence.startDate(); // Get\r\n   * recurrence.startDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public startDate (): Moment\r\n  public startDate (date: MomentInput | null): Recur\r\n  public startDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.start = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.start = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.start) {\r\n      throw new Error('No start date defined for recurrence.')\r\n    }\r\n    return this.start\r\n  }\r\n\r\n  /**\r\n   * Get/Set the End Date\r\n   * ```js\r\n   * recurrence.endDate(); // Get\r\n   * recurrence.endDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public endDate (): Moment\r\n  public endDate (date: MomentInput | null): Recur\r\n  public endDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.end = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.end = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.end) {\r\n      throw new Error('No end date defined for recurrence.')\r\n    }\r\n    return this.end\r\n  }\r\n\r\n  /**\r\n   * Get/Set a temporary \"From Date\" for use with generating dates\r\n   * ```js\r\n   * recurrence.fromDate(); // Get\r\n   * recurrence.fromDate(\"01/01/2014\"); // Set\r\n   * ```\r\n   * @category getter/setter\r\n   */\r\n  public fromDate (): Moment\r\n  public fromDate (date: MomentInput | null): Recur\r\n  public fromDate (date?: MomentInput): Moment | Recur {\r\n    if (date === null) {\r\n      this.from = null\r\n      return this\r\n    }\r\n\r\n    if (date) {\r\n      this.from = moment(date).dateOnly()\r\n      return this\r\n    }\r\n\r\n    if (!this.from) {\r\n      throw new Error('No from date defined for recurrence.')\r\n    }\r\n    return this.from\r\n  }\r\n\r\n  /**\r\n   * Interval calculations will use a default of 1000 year limit when determining unbounded\r\n   * rules. Use this function to query or change the maximum limit.\r\n   */\r\n  public maxYears (): number\r\n  public maxYears (years: number): Recur\r\n  public maxYears (years?: number): number | Recur {\r\n    if (years) {\r\n      this.maximumYears = years\r\n      return this\r\n    } else {\r\n      return this.maximumYears\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use `save()` to export all options, rules, and exceptions as an object.\r\n   * This can be used to store recurrences in a database.\r\n   * > Note: This does not export the \"From Date\" which is considered a temporary option.\r\n   * ```js\r\n   * recurrence.save();\r\n   * ```\r\n   */\r\n  public save (): Recur.Options {\r\n    const data: Recur.Options = {}\r\n\r\n    if (this.start && moment(this.start).isValid()) {\r\n      data.start = this.start.format(ISO_DATE_FMT)\r\n    }\r\n\r\n    if (this.end && moment(this.end).isValid()) {\r\n      data.end = this.end.format(ISO_DATE_FMT)\r\n    }\r\n\r\n    data.exceptions = this.exceptions.map(date => date.format(ISO_DATE_FMT))\r\n\r\n    data.rules = this.rules\r\n\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Use `repeats()` to check if a recurrence has rules set.\r\n   * ```js\r\n   * recurrence.repeats(); // true/false\r\n   * ```\r\n   */\r\n  public repeats (): boolean {\r\n    return this.rules.length > 0\r\n  }\r\n\r\n  /**\r\n   * The `every()` function allows you to set the units and, optionally, the measurment type\r\n   * of the recurring date. It returns the recur object to allow chaining.\r\n   *\r\n   *  ```js\r\n   *  let myDate, recurrence;\r\n   *\r\n   *  // Create a date to start from\r\n   *  myDate = moment(\"01/01/2014\");\r\n   *\r\n   *  // You can pass the units to recur on, and the measurement type.\r\n   *  recurrence = myDate.recur().every(1, \"days\");\r\n   *\r\n   *  // You can also chain the measurement type instead of passing it to every.\r\n   *  recurrence = myDate.recur().every(1).day();\r\n   *\r\n   *  // It is also possible to pass an array of units.\r\n   *  recurrence = myDate.recur().every([3, 5]).days();\r\n   *\r\n   *  // When using the dayOfWeek measurement, you can pass days names.\r\n   *  recurrence = myDate.recur().every([\"Monday\", \"wed\"]).daysOfWeek();\r\n   *\r\n   *  // Month names also work when using monthOfYear.\r\n   *  recurrence = myDate.recur().every([\"Jan\", \"february\"], \"monthsOfYear\");\r\n   *  ```\r\n   *\r\n   *  `every()` will override the last \"every\" if a measurement was not provided.\r\n   *  The following line will create a recurrence for every 5 days.\r\n   *  ```js\r\n   *  recurrence  = myDate.recur().every(1).every(5).days();\r\n   *  ```\r\n   *  If you need to specify multiple units, pass an array to `every()`.\r\n   *\r\n   *  You may also pass the units directly to the interval functions (listed below)\r\n   *  instead of using `every()`.\r\n   *  ```js\r\n   *  let recurrence = moment.recur().monthOfYear(\"January\");\r\n   *  ```\r\n   */\r\n  public every (units: Rule.UnitsInput, measure?: Rule.MeasureInput): this {\r\n\r\n    if (units != null) {\r\n      this.units = units\r\n    }\r\n\r\n    if (measure != null) {\r\n      this.measure = measure\r\n    }\r\n\r\n    // Don't create the rule until measure is defined\r\n    if (!this.measure) {\r\n      return this\r\n    }\r\n\r\n    const rule = Rule.factory(this.units, this.measure, this.start)\r\n\r\n    if (rule.measure === 'weeksOfMonthByDay' && !this.hasRule('daysOfWeek')) {\r\n      throw new Error('weeksOfMonthByDay must be combined with daysOfWeek')\r\n    }\r\n\r\n    // Remove the temporary rule data\r\n    this.units = null\r\n    this.measure = null\r\n\r\n    // Remove existing rule based on measure\r\n    this.rules = this.rules.filter(oldRule => oldRule.measure !== rule.measure)\r\n\r\n    this.rules.push(rule)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * To prevent a date from matching that would normally match, use the `except()` function.\r\n   * ```js\r\n   * let recurrence = moment(\"01/01/2014\").recur().every(1).day().except(\"01/02/2014\");\r\n   * recurrence.matches(\"01/02/2014\"); // false\r\n   * ```\r\n   */\r\n  public except (date: MomentInput): this {\r\n    date = moment(date).dateOnly()\r\n    this.exceptions.push(date)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Forgets rules (by passing measure) and exceptions (by passing date)\r\n   * ```js\r\n   * // Exceptions can be removed by passing a date to the forget() function.\r\n   * recurrence.forget(\"01/03/2014\");\r\n   * ```\r\n   * ```js\r\n   * // Rules can be removed by passing the measurement to the forget() function.\r\n   * recurrence.forget(\"days\");\r\n   * ```\r\n   */\r\n  public forget (dateOrRule: MomentInput | Rule.MeasureInput, format?: string): this {\r\n\r\n    if (!dateOrRule) {\r\n      throw new Error('Invalid input for recurrence forget: ' + dateOrRule)\r\n    }\r\n\r\n    try {\r\n      const normMeasure = Rule.normalizeMeasure(dateOrRule)\r\n      this.rules = this.rules.filter(rule => rule.measure !== normMeasure)\r\n      return this\r\n\r\n    } catch (err) {\r\n\r\n      let date = moment(dateOrRule, format)\r\n\r\n      // If valid date, try to remove it from exceptions\r\n      if (date.isValid()) {\r\n        date = date.dateOnly() // change to date only for perfect comparison\r\n        this.exceptions = this.exceptions.filter(exception => !date.isSame(exception))\r\n        return this\r\n      } else {\r\n        throw new Error('Invalid input for recurrence forget: ' + dateOrRule)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a rule has been set on the chain\r\n   */\r\n  public hasRule (measure: Rule.MeasureInput): boolean {\r\n    return this.rules.findIndex(rule => rule.measure === Rule.normalizeMeasure(measure)) !== -1\r\n  }\r\n\r\n  /**\r\n   * The `matches()` function will test a date to check if all of the recurrence rules match.\r\n   * It returns `true` if the date matches, `false` otherwise.\r\n   * ```js\r\n   * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n   * interval.matches(\"01/02/2014\"); // false\r\n   * interval.matches(\"01/03/2014\"); // true\r\n   * ```\r\n   *\r\n   * You may also see if a date matches before the start date or after the end date by\r\n   * passing `true` as the second argument to `matches()`.\r\n   * ```js\r\n   * let interval = moment(\"01/01/2014\").recur().every(2).days();\r\n   * interval.matches(\"12/30/2013\"); // false\r\n   * interval.matches(\"12/30/2013\", true); // true\r\n   * ```\r\n   */\r\n  public matches (dateToMatch: MomentInput, ignoreStartEnd?: boolean): boolean {\r\n    const date = moment(dateToMatch).dateOnly()\r\n\r\n    if (!date.isValid()) {\r\n      throw Error('Invalid date supplied to match method: ' + dateToMatch)\r\n    }\r\n\r\n    if (!ignoreStartEnd && !this.inRange(date)) {\r\n      return false\r\n    }\r\n\r\n    if (this.isException(date)) {\r\n      return false\r\n    }\r\n\r\n    if (!this.matchAllRules(date)) {\r\n      return false\r\n    }\r\n\r\n    // if we passed everything above, then this date matches\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Iterate over moments matched by rules\r\n   * > Note if there is no end date, results are unbounded (you must manually terminate the iterator).\r\n   *\r\n   * > Also note, this exapmle intentionally ignores some complicated leap year math.\r\n   *\r\n   * ```js\r\n   * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n   * let leapYears = [...recurrence].map(m => m.year())\r\n   * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n   * ```\r\n   * Or, this is a bit faster...\r\n   * ```js\r\n   * let recurrence = moment('2012-01').recur('2032-01').every(4).years()\r\n   * let leapYears = []\r\n   * for (let date of recurrence) {\r\n   *   leapYears.push(date.year())\r\n   * }\r\n   * // leapYears = [ 2012, 2016, 2020, 2024, 2028, 2032 ]\r\n   * ```\r\n   */\r\n  public *[Symbol.iterator] (): IterableIterator<Moment> {\r\n\r\n    const startFrom = this.from || this.start\r\n    if (!startFrom || !startFrom.isValid()) {\r\n      throw Error('Cannot get occurrences without start or from date.')\r\n    }\r\n\r\n    if (this.end && (startFrom > this.end)) {\r\n      throw Error('Start date cannot be later than end date.')\r\n    }\r\n\r\n    let currentDate = startFrom.clone()\r\n\r\n    // yield the starting date if it's a match\r\n    if (this.matchAllRules(currentDate)) {\r\n      yield currentDate.clone()\r\n    }\r\n\r\n    while (true) {\r\n\r\n      try {\r\n        currentDate = this.reversed ?\r\n          this.findPreviousMatch(currentDate) :\r\n          this.findNextMatch(currentDate)\r\n      } catch (err) {\r\n        /* istanbul ignore else */\r\n        if (err instanceof RangeError) return undefined\r\n        else throw err\r\n      }\r\n\r\n      if (this.end && currentDate.isAfter(this.end)) break\r\n\r\n      if (!this.isException(currentDate)) {\r\n        yield currentDate.clone()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reverse iterator direction\r\n   * > Note since there is no end date, results are unbounded (you must manually terminate the iterator).\r\n   *\r\n   * ```js\r\n   * let mondays = []\r\n   * for (let monday of moment().recur().every('Monday').dayOfWeek().reverse()) {\r\n   *   lastThreeMondays.push(monday)\r\n   *   if (mondays.length > 10) break\r\n   * }\r\n   * ```\r\n   */\r\n  public reverse (): this {\r\n    this.reversed = !this.reversed\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * With both a start date and an end date set, you can generate all dates within\r\n   * that range that match the pattern (including the start/end dates).\r\n   *\r\n   * ```js\r\n   * let recurrence = moment().recur(\"01/01/2014\", \"01/07/2014\").every(2).days();\r\n   *\r\n   * // Outputs: [\"01/01/2014\", \"01/03/2014\", \"01/05/2014\", \"01/07/2014\"]\r\n   * allDates = recurrence.all(\"L\");\r\n   * ```\r\n   */\r\n  public all (): Moment[]\r\n  public all (format: string): string[]\r\n  public all (format?: string): (string | Moment)[] {\r\n\r\n    if (!this.end || !this.end.isValid()) {\r\n      throw Error('Cannot get all occurrences without an end date.')\r\n    }\r\n\r\n    this.reversed = false\r\n\r\n    const dates: (string | Moment)[] = []\r\n    for (const date of this) {\r\n      dates.push(format ? date.format(format) : date)\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * Get next N occurrences\r\n   * ```js\r\n   * // Generate the next three dates as moments\r\n   * // Outputs: [moment(\"01/03/2014\"), moment(\"01/05/2014\"), moment(\"01/07/2014\")]\r\n   * nextDates = recurrence.next(3);\r\n   * ```\r\n   * ```js\r\n   * // Generate the next three dates, formatted in local format\r\n   * // Outputs: [\"01/03/2014\", \"01/05/2014\", \"01/07/2014\"]\r\n   * nextDates = recurrence.next(3, \"L\");\r\n   * ```\r\n   */\r\n  public next (num: number): Moment[]\r\n  public next (num: number, format: string): string[]\r\n  public next (num: number, format?: string): (string | Moment)[] {\r\n    if (!num) return []\r\n    const dates: (string | Moment)[] = []\r\n    let count = 0\r\n    this.reversed = false\r\n    for (const date of this) {\r\n      if (!(this.start && date.isSame(this.start))) {\r\n        dates.push(format ? date.format(format) : date)\r\n        count++\r\n      }\r\n      if (count >= num) break\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * Get previous N occurrences\r\n   * ```js\r\n   * // Generate previous three dates, formatted in local format\r\n   * // Outputs: [\"12/30/2013\", \"12/28/2013\", \"12/26/2013\"]\r\n   * nextDates = recurrence.previous(3, \"L\");\r\n   * ```\r\n   */\r\n  public previous (num: number): Moment[]\r\n  public previous (num: number, format: string): string[]\r\n  public previous (num?: number, format?: string): (string | Moment)[] {\r\n    if (!num) return []\r\n    const dates: (string | Moment)[] = []\r\n    let count = 0\r\n    this.reversed = true\r\n    for (const date of this) {\r\n      if (!(this.start && date.isSame(this.start))) {\r\n        dates.push(format ? date.format(format) : date)\r\n        count++\r\n      }\r\n      if (count >= num) break\r\n    }\r\n    return dates\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private addMeasureFunctions (): void {\r\n    for (const measureSingle of Object.keys(Rule.MeasureSingleToPlural)) {\r\n      const measurePlural = Rule.MeasureSingleToPlural[measureSingle];\r\n      (Recur as any).prototype[measureSingle] = (units?: Rule.UnitsInput): this => {\r\n        this.every(units, measurePlural)\r\n        return this\r\n      }\r\n      (Recur as any).prototype[measurePlural] = (units?: Rule.UnitsInput): this => {\r\n        this.every(units, measurePlural)\r\n        return this\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to see if a date is within range of start/end\r\n   * @internal\r\n   */\r\n  private inRange (date: Moment): boolean {\r\n    if (this.start && date.isBefore(this.start)) {\r\n      return false\r\n    } else if (this.end && date.isAfter(this.end)) {\r\n      return false\r\n    } else {\r\n      return true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to check if a date is an exception\r\n   * @internal\r\n   */\r\n  private isException (date: MomentInput): boolean {\r\n\r\n    for (const exception of this.exceptions) {\r\n      if (moment(exception).isSame(date)) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private matchAllRules (date: Moment): boolean {\r\n\r\n    for (const rule of this.rules) {\r\n      if (!rule.match(date)) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private findNextMatch (currentDate: Moment): Moment {\r\n\r\n    let nextDate = currentDate.clone().add(1, 'day')\r\n    const limit = currentDate.clone().add(this.maximumYears, 'years')\r\n\r\n    let allRulesMatch = false\r\n    while (!allRulesMatch) {\r\n      // if (nextDate.year() >= currentDate.year() + this.maximumYears) {\r\n      //   throw new RangeError()\r\n      // }\r\n      nextDate.subtract(1, 'day')\r\n      const nextDates = this.rules.map(rule => rule.next(nextDate, limit))\r\n      nextDates.sort((a, b) => a.diff(b))\r\n      nextDate = nextDates[nextDates.length - 1]\r\n      allRulesMatch = nextDate.isSame(nextDates[0])\r\n    }\r\n\r\n    return nextDate\r\n  }\r\n\r\n  /**\r\n   * Private funtion to see if all rules match\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  private findPreviousMatch (currentDate: Moment): Moment {\r\n\r\n    let nextDate = currentDate.clone().subtract(1, 'day')\r\n    const limit = currentDate.clone().subtract(this.maximumYears, 'years')\r\n\r\n    let allRulesMatch = false\r\n    while (!allRulesMatch) {\r\n      // if (nextDate.year() <= currentDate.year() - this.maximumYears) {\r\n      //   throw new RangeError()\r\n      // }\r\n      nextDate.add(1, 'day')\r\n      const nextDates = this.rules.map(rule => rule.previous(nextDate, limit))\r\n      nextDates.sort((a, b) => b.diff(a))\r\n      nextDate = nextDates[nextDates.length - 1]\r\n      allRulesMatch = nextDate.isSame(nextDates[0])\r\n    }\r\n\r\n    return nextDate\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/recur.ts","import * as moment from 'moment'\r\nimport { Calendar } from './calendar'\r\nimport { Interval } from './interval'\r\n\r\nexport namespace Rule {\r\n  export type MeasureSingle =\r\n    'day'\r\n    | 'week'\r\n    | 'month'\r\n    | 'year'\r\n    | 'dayOfWeek'\r\n    | 'dayOfMonth'\r\n    | 'weekOfMonth'\r\n    | 'weekOfMonthByDay'\r\n    | 'weekOfYear'\r\n    | 'monthOfYear'\r\n\r\n  export type MeasurePlural =\r\n    'days'\r\n    | 'weeks'\r\n    | 'months'\r\n    | 'years'\r\n    | 'daysOfWeek'\r\n    | 'daysOfMonth'\r\n    | 'weeksOfMonth'\r\n    | 'weeksOfMonthByDay'\r\n    | 'weeksOfYear'\r\n    | 'monthsOfYear'\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export const MeasureSingleToPlural: {\r\n    [m: string]: MeasurePlural\r\n  } = {\r\n    day: 'days',\r\n    week: 'weeks',\r\n    month: 'months',\r\n    year: 'years',\r\n    dayOfWeek: 'daysOfWeek',\r\n    dayOfMonth: 'daysOfMonth',\r\n    weekOfMonth: 'weeksOfMonth',\r\n    weekOfMonthByDay: 'weeksOfMonthByDay',\r\n    weekOfYear: 'weeksOfYear',\r\n    monthOfYear: 'monthsOfYear'\r\n  }\r\n\r\n  export type UnitsInput = string | number | (string | number)[] | UnitsObject | undefined | null\r\n\r\n  /**\r\n   * @hidden\r\n   * @deprecated\r\n   */\r\n  export interface UnitsObject {\r\n    [unit: string]: boolean\r\n\r\n    [unit: number]: boolean\r\n  }\r\n\r\n  export type MeasureInput = MeasureSingle | MeasurePlural | undefined | null\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export function factory (units: UnitsInput, measure: MeasureInput, start: moment.Moment | null): Rule {\r\n\r\n    const normMeasure = normalizeMeasure(measure)\r\n\r\n    switch (normMeasure) {\r\n      case 'days':\r\n      case 'weeks':\r\n      case 'months':\r\n      case 'years':\r\n        return new Interval(unitsToArray(units), normMeasure, start)\r\n\r\n      case 'daysOfWeek':\r\n      case 'daysOfMonth':\r\n      case 'weeksOfMonth':\r\n      case 'weeksOfMonthByDay':\r\n      case 'weeksOfYear':\r\n      case 'monthsOfYear':\r\n        return new Calendar(unitsToArray(units), normMeasure)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  function unitsToArray (units: UnitsInput): (string | number)[] {\r\n\r\n    if (units == null) {\r\n      throw new Error('Units not defined for recurrence rule.')\r\n    } else if (Array.isArray(units)) {\r\n      return units\r\n    } else if (typeof units === 'object') {\r\n      return Object.keys(units)\r\n    } else if (typeof units === 'number') {\r\n      return [units]\r\n      // tslint:disable-next-line:strict-type-predicates\r\n    } else if (typeof units === 'string') {\r\n      return [units]\r\n    } else {\r\n      throw new Error('Provide an array, object, string or number when passing units!')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private function to pluralize measure names for use with dictionaries.\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  export function normalizeMeasure (measure: any): MeasurePlural {\r\n    if (typeof measure === 'string') {\r\n      if (MeasureSingleToPlural[measure]) {\r\n        return MeasureSingleToPlural[measure]\r\n      } else {\r\n        for (const key in MeasureSingleToPlural) {\r\n          if (MeasureSingleToPlural[key] === measure) return measure\r\n        }\r\n      }\r\n    }\r\n    throw new Error('Invalid Measure for recurrence: ' + measure)\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport interface Rule {\r\n\r\n  readonly units: number[]\r\n  readonly measure: Rule.MeasurePlural\r\n\r\n  /**\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  match (date: moment.Moment): boolean\r\n\r\n  next (current: moment.Moment, limit?: moment.Moment): moment.Moment\r\n\r\n  previous (current: moment.Moment, limit?: moment.Moment): moment.Moment\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/rule.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nexport type CalendarMeasure =\r\n  'daysOfWeek'\r\n  | 'daysOfMonth'\r\n  | 'weeksOfMonth'\r\n  | 'weeksOfMonthByDay'\r\n  | 'weeksOfYear'\r\n  | 'monthsOfYear'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\ntype TimeUnits = 'day' | 'month' | 'week' | 'year'\r\n\r\n/**\r\n * Calendar object for creating and matching calendar-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nexport class Calendar implements Rule {\r\n\r\n  private static readonly ranges: {\r\n    [key: string]: {\r\n      period: TimeUnits\r\n      range: TimeUnits\r\n      low: number\r\n      high: number\r\n    }\r\n  } = {\r\n    daysOfWeek: {\r\n      period: 'day',\r\n      range: 'week',\r\n      low: 0,\r\n      high: 6\r\n    },\r\n    daysOfMonth: {\r\n      period: 'day',\r\n      range: 'month',\r\n      low: 1,\r\n      high: 31\r\n    },\r\n    weeksOfMonth: {\r\n      period: 'week',\r\n      range: 'month',\r\n      low: 0,\r\n      high: 4\r\n    },\r\n    weeksOfMonthByDay: {\r\n      period: 'week',\r\n      range: 'month',\r\n      low: 0,\r\n      high: 4\r\n    },\r\n    weeksOfYear: {\r\n      period: 'week',\r\n      range: 'year',\r\n      low: 1,\r\n      high: 53\r\n    },\r\n    monthsOfYear: {\r\n      period: 'month',\r\n      range: 'year',\r\n      low: 0,\r\n      high: 11\r\n    }\r\n  }\r\n\r\n  public readonly units: number[]\r\n  public readonly measure: CalendarMeasure\r\n\r\n  private readonly range: TimeUnits\r\n  private readonly period: TimeUnits\r\n\r\n  constructor (units: (string | number)[], measure: CalendarMeasure) {\r\n\r\n    this.measure = measure\r\n    this.units = this.normalizeUnits(units)\r\n\r\n    this.range = Calendar.ranges[this.measure].range\r\n    this.period = Calendar.ranges[this.measure].period\r\n  }\r\n\r\n  public match (date: moment.Moment): boolean {\r\n\r\n    // Get the unit based on the required measure of the date\r\n    const unit = this.periodUnit(date)\r\n\r\n    // If the unit is in our list, return true, else return false\r\n    if (this.units.indexOf(unit) !== -1) {\r\n      return true\r\n    }\r\n    if ((this.units[0] === -1) &&\r\n      (unit === this.periodUnit(moment(date).endOf(this.range)))) {\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  public next (currentDateIn: moment.Moment, limit: moment.Moment): moment.Moment {\r\n\r\n    let currentDate = currentDateIn.clone()\r\n    // If still within our period, just give the next day\r\n    if (!this.isLastDayOfPeriod(currentDate)) {\r\n      const nextDateInPeriod = moment(currentDate).add(1, 'day')\r\n      if (this.match(nextDateInPeriod)) return nextDateInPeriod\r\n    }\r\n\r\n    while (true) {\r\n      // Get the next period based on the measure\r\n      const nextDate = this.nextPeriod(currentDate)\r\n      if (nextDate) {\r\n        return nextDate\r\n      } else {\r\n        // No more units found within this range,\r\n        // bump our range by one and try again.\r\n        currentDate = this.incrementRange(currentDate, 1)\r\n\r\n        // Check to see if next range starts on a valid period\r\n        if (this.match(currentDate)) {\r\n          return currentDate\r\n        }\r\n\r\n        if (currentDate.isSameOrAfter(limit)) {\r\n          throw new RangeError('Recurrence Year limit exceeded.')\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public previous (currentDateIn: moment.Moment, limit: moment.Moment): moment.Moment {\r\n\r\n    let currentDate = currentDateIn.clone()\r\n    // If still within our period, just give the next day\r\n    if (!this.isFirstDayOfPeriod(currentDate)) {\r\n      const nextDateInPeriod = moment(currentDate).subtract(1, 'day')\r\n      if (this.match(nextDateInPeriod)) return nextDateInPeriod\r\n    }\r\n\r\n    while (true) {\r\n      // Get the next period based on the measure\r\n      const nextDate = this.previousPeriod(currentDate)\r\n      if (nextDate) {\r\n        return nextDate\r\n      } else {\r\n        // No more units found within this range,\r\n        // bump our range by one and try again.\r\n        currentDate = this.decrementRange(currentDate, 1)\r\n\r\n        // Check to see if next range starts on a valid period\r\n        if (this.match(currentDate)) {\r\n          return currentDate\r\n        }\r\n\r\n        if (currentDate.isSameOrBefore(limit)) {\r\n          throw new RangeError('Recurrence Year limit exceeded.')\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private normalizeUnits (units: any[]): number[] {\r\n\r\n    const low = Calendar.ranges[this.measure].low\r\n    const high = Calendar.ranges[this.measure].high\r\n\r\n    return units.map(unitIn => {\r\n      if (unitIn === 'last') unitIn = -1\r\n      if (typeof unitIn !== 'number') {\r\n        // Convert day/month names to numbers, if needed\r\n        if (this.measure === 'daysOfWeek') {\r\n          unitIn = moment().set('days', unitIn).get('days')\r\n        } else if (this.measure === 'monthsOfYear') {\r\n          unitIn = moment().set('months', unitIn).get('months')\r\n        } else {\r\n          unitIn = +unitIn\r\n        }\r\n      }\r\n      if (!Number.isInteger(unitIn)) {\r\n        throw new TypeError('Invalid calendar unit in recurrence: ' + unitIn)\r\n      }\r\n      if ((unitIn < low || unitIn > high) && (unitIn !== -1)) {\r\n        throw new RangeError('Value should be in range ' + low + ' to ' + high)\r\n      }\r\n      return unitIn\r\n    }).sort((a, b) => a - b)\r\n  }\r\n\r\n  private periodUnit (date: moment.Moment): number\r\n  private periodUnit (date: moment.Moment, unit: number): moment.Moment\r\n  private periodUnit (date: moment.Moment, unit?: number): number | moment.Moment {\r\n    switch (this.measure) {\r\n      case 'daysOfWeek':\r\n        return date.day(unit!)\r\n      case 'daysOfMonth':\r\n        return date.date(unit!)\r\n      case 'weeksOfMonth':\r\n        return date.monthWeek(unit!)\r\n      case 'weeksOfMonthByDay':\r\n        return date.monthWeekByDay(unit!)\r\n      case 'weeksOfYear':\r\n        return date.week(unit!)\r\n      case 'monthsOfYear':\r\n        return date.month(unit!)\r\n    }\r\n  }\r\n\r\n  private nextPeriod (date: moment.Moment): moment.Moment | undefined {\r\n    // Get the next period based on the measure\r\n    const currentUnit = this.periodUnit(date)\r\n\r\n    const nextUnit = this.units\r\n      .map(unit => unit === -1 ? this.periodUnit(date.clone().endOf(this.range)) : unit)\r\n      .find(unit => unit > currentUnit)\r\n\r\n    if (nextUnit !== undefined) {\r\n      return this.periodUnit(date.clone(), nextUnit).startOf(this.period)\r\n    } else {\r\n\r\n      // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n      if (this.measure === 'weeksOfYear' && (this.units.indexOf(1) !== -1)) {\r\n        return date.clone().endOf('year').startOf('week')\r\n      }\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  private previousPeriod (date: moment.Moment): moment.Moment | undefined {\r\n    // Get the next period based on the measure\r\n    let currentUnit = this.periodUnit(date)\r\n    if (this.measure === 'weeksOfYear' && date.month() === 11 && date.week() === 1) currentUnit = 53\r\n\r\n    const nextUnit = this.units\r\n      .map(unit => unit === -1 ? this.periodUnit(date.clone().endOf(this.range)) : unit)\r\n      .reverse().find(unit => unit < currentUnit)\r\n\r\n    if (nextUnit !== undefined) {\r\n      if (this.measure === 'weeksOfYear' && currentUnit === 53) date.week(0)\r\n      return this.periodUnit(date.clone(), nextUnit).endOf(this.period)\r\n    } else {\r\n\r\n      // Weeks do not follow orderly periods, e.g. a year can begin and end on week 1\r\n      if (this.measure === 'weeksOfYear' &&\r\n        this.units.some(u => 52 >= u && u <= 53)) {\r\n        return date.clone().startOf('year').endOf('week')\r\n      }\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  private incrementRange (date: moment.Moment, count: number): moment.Moment {\r\n    return date.add(count, this.range).startOf(this.range)\r\n  }\r\n\r\n  private decrementRange (date: moment.Moment, count: number): moment.Moment {\r\n    return date.subtract(count, this.range).endOf(this.range)\r\n  }\r\n\r\n  private isLastDayOfPeriod (date: moment.Moment): boolean {\r\n    if (this.measure === 'weeksOfMonthByDay') {\r\n      return date.monthWeekByDay() !== moment(date).add(1, 'day').monthWeekByDay()\r\n    }\r\n\r\n    if (this.period === 'day') {\r\n      return true\r\n    } else {\r\n      return date.isSame(moment(date).endOf(this.period))\r\n    }\r\n  }\r\n\r\n  private isFirstDayOfPeriod (date: moment.Moment): boolean {\r\n    if (this.measure === 'weeksOfMonthByDay') {\r\n      return date.monthWeekByDay() !== moment(date).subtract(1, 'day').monthWeekByDay()\r\n    }\r\n\r\n    if (this.period === 'day') {\r\n      return true\r\n    } else {\r\n      return date.isSame(moment(date).startOf(this.period))\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/calendar.ts","import * as moment from 'moment'\r\nimport { Rule } from './rule'\r\n\r\n/**\r\n * @internal\r\n * @hidden\r\n */\r\nexport type IntervalMeasure = 'days' | 'weeks' | 'months' | 'years'\r\n\r\n/**\r\n * Interval object for creating and matching interval-based rules\r\n * @internal\r\n * @hidden\r\n */\r\nexport class Interval implements Rule {\r\n\r\n  public readonly units: number[]\r\n  public readonly measure: IntervalMeasure\r\n\r\n  private start: moment.Moment\r\n\r\n  constructor (units: (string | number)[], measure: IntervalMeasure, start: moment.Moment | null) {\r\n\r\n    if (!start) {\r\n      throw new Error('Must have a start date set to set an interval!')\r\n    }\r\n    this.start = start.clone()\r\n\r\n    this.measure = measure\r\n    this.units = this.normalizeUnits(units)\r\n  }\r\n\r\n  public match (date: moment.Moment): boolean {\r\n\r\n    const precise = this.measure !== 'days'\r\n    const diff = Math.abs(this.start.diff(date, this.measure, precise))\r\n\r\n    // Check to see if any of the units provided match the date\r\n    for (const unit of this.units) {\r\n      // If the units divide evenly into the difference, we have a match\r\n      if ((diff % unit) === 0) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  public next (currentDate: moment.Moment): moment.Moment {\r\n\r\n    // let precise = this.measure !== 'days'\r\n    // Get the multiple of the start\r\n    const diff = currentDate.diff(this.start, this.measure)\r\n\r\n    // Find the next muliple for each unit\r\n    const multiples = this.units.map(unit => (Math.floor(diff / unit) + 1) * unit)\r\n    multiples.sort((a, b) => a - b)\r\n\r\n    return this.start.clone().add(multiples[0], this.measure)\r\n  }\r\n\r\n  public previous (currentDate: moment.Moment): moment.Moment {\r\n\r\n    // let precise = this.measure !== 'days'\r\n    // Get the multiple of the start\r\n    const diff = this.start.diff(currentDate, this.measure)\r\n\r\n    // Find the next muliple for each unit\r\n    const multiples = this.units.map(unit => (Math.floor(diff / unit) + 1) * unit)\r\n    multiples.sort((a, b) => b - a)\r\n\r\n    return this.start.clone().subtract(multiples[0], this.measure)\r\n  }\r\n\r\n  private normalizeUnits (units: any[]): number[] {\r\n\r\n    // Make sure all of the units are integers greater than 0.\r\n    return units.map(unit => {\r\n      unit = +unit\r\n      if (unit <= 0) {\r\n        throw new Error('Intervals must be greater than zero.')\r\n      }\r\n      if (!Number.isInteger(unit)) {\r\n        throw new Error('Intervals must be integers.')\r\n      }\r\n      return unit\r\n    }).sort((a, b) => a - b)\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/interval.ts"],"sourceRoot":""}