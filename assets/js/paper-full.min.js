/*!
 * Paper.js v0.11.8 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Oct 17 17:00:54 2018 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2016 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var paper = (function (t, e) {
  t = t || require(`./node/self.js`); var n = t.window; var i = t.document; var r = new function () { function t (t, e, r, s, a) { function u (i, u) { u = u || (u = o(e, i)) && (u.get ? u : u.value), typeof u === `string` && u[0] === `#` && (u = t[u.substring(1)] || u); var c; var f = typeof u === `function`; var d = u; var _ = a || f && !u.base ? u && u.get ? i in t : t[i] : null; a && _ || (f && _ && (u.base = _), f && s !== !1 && (c = i.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (l[c[3].toLowerCase() + c[4]] = c[2]), d && !f && d.get && typeof d.get === `function` && n.isPlainObject(d) || (d = { value: d, writable: !0 }), (o(t, i) || { configurable: !0 }).configurable && (d.configurable = !0, d.enumerable = r != null ? r : !c), h(t, i, d)) } var l = {}; if (e) { for (var c in e) { e.hasOwnProperty(c) && !i.test(c) && u(c) } for (var c in l) { var f = l[c]; var d = t[`set` + f]; var _ = t[`get` + f] || d && t[`is` + f]; !_ || s !== !0 && _.length !== 0 || u(c, { get: _, set: d }) } } return t } function n () { for (var t = 0, e = arguments.length; t < e; t++) { var n = arguments[t]; n && c(this, n) } return this } var i = /^(statics|enumerable|beans|preserve)$/; var r = []; var s = r.slice; var a = Object.create; var o = Object.getOwnPropertyDescriptor; var h = Object.defineProperty; var u = r.forEach || function (t, e) { for (var n = 0, i = this.length; n < i; n++) { t.call(e, this[n], n, this) } }; var l = function (t, e) { for (var n in this) { this.hasOwnProperty(n) && t.call(e, this[n], n, this) } }; var c = Object.assign || function (t) { for (var e = 1, n = arguments.length; e < n; e++) { var i = arguments[e]; for (var r in i) { i.hasOwnProperty(r) && (t[r] = i[r]) } } return t }; var f = function (t, e, n) { if (t) { var i = o(t, `length`); (i && typeof i.value === `number` ? u : l).call(t, e, n = n || t) } return n }; return t(n, { inject: function (e) { if (e) { var n = e.statics === !0 ? e : e.statics; var i = e.beans; var r = e.preserve; n !== e && t(this.prototype, e, e.enumerable, i, r), t(this, n, null, i, r) } for (var s = 1, a = arguments.length; s < a; s++) { this.inject(arguments[s]) } return this }, extend: function () { for (var e, n, i, r = this, s = 0, o = arguments.length; s < o && (!e || !n); s++) { i = arguments[s], e = e || i.initialize, n = n || i.prototype } return e = e || function () { r.apply(this, arguments) }, n = e.prototype = n || a(this.prototype), h(n, `constructor`, { value: e, writable: !0, configurable: !0 }), t(e, this), arguments.length && this.inject.apply(e, arguments), e.base = r, e } }).inject({ enumerable: !1, initialize: n, set: n, inject: function () { for (var e = 0, n = arguments.length; e < n; e++) { var i = arguments[e]; i && t(this, i, i.enumerable, i.beans, i.preserve) } return this }, extend: function () { var t = a(this); return t.inject.apply(t, arguments) }, each: function (t, e) { return f(this, t, e) }, clone: function () { return new this.constructor(this) }, statics: { set: c, each: f, create: a, define: h, describe: o, clone: function (t) { return c(new t.constructor(), t) }, isPlainObject: function (t) { var e = t != null && t.constructor; return e && (e === Object || e === n || e.name === `Object`) }, pick: function (t, n) { return t !== e ? t : n }, slice: function (t, e, n) { return s.call(t, e, n) } } }) }(); typeof module !== `undefined` && (module.exports = r), r.inject({ enumerable: !1, toString: function () { return this._id != null ? (this._class || `Object`) + (this._name ? ` '` + this._name + `'` : ` @` + this._id) : `{ ` + r.each(this, function (t, e) { if (!/^_/.test(e)) { var n = typeof t; this.push(e + `: ` + (n === `number` ? h.instance.number(t) : n === `string` ? `'` + t + `'` : t)) } }, []).join(`, `) + ` }` }, getClassName: function () { return this._class || `` }, importJSON: function (t) { return r.importJSON(t, this) }, exportJSON: function (t) { return r.exportJSON(this, t) }, toJSON: function () { return r.serialize(this) }, set: function (t, e) { return t && r.filter(this, t, e, this._prioritize), this } }, { beans: !1, statics: { exports: {}, extend: function st () { var t = st.base.apply(this, arguments); var e = t.prototype._class; return e && !r.exports[e] && (r.exports[e] = t), t }, equals: function (t, e) { if (t === e) { return !0 } if (t && t.equals) { return t.equals(e) } if (e && e.equals) { return e.equals(t) } if (t && e && typeof t === `object` && typeof e === `object`) { if (Array.isArray(t) && Array.isArray(e)) { var n = t.length; if (n !== e.length) { return !1 } for (;n--;) { if (!r.equals(t[n], e[n])) { return !1 } } } else { var i = Object.keys(t); var n = i.length; if (n !== Object.keys(e).length) { return !1 } for (;n--;) { var s = i[n]; if (!e.hasOwnProperty(s) || !r.equals(t[s], e[s])) { return !1 } } } return !0 } return !1 }, read: function (t, n, i, s) { if (this === r) { var a = this.peek(t, n); return t.__index++, a } var o = this.prototype; var h = o._readIndex; var u = n || h && t.__index || 0; var l = t.length; var c = t[u]; if (s = s || l - u, c instanceof this || i && i.readNull && c == null && s <= 1) { return h && (t.__index = u + 1), c && i && i.clone ? c.clone() : c } if (c = r.create(o), h && (c.__read = !0), c = c.initialize.apply(c, u > 0 || u + s < l ? r.slice(t, u, u + s) : t) || c, h) { t.__index = u + c.__read; var f = c.__filtered; f && (t.__filtered = f, c.__filtered = e), c.__read = e } return c }, peek: function (t, e) { return t[t.__index = e || t.__index || 0] }, remain: function (t) { return t.length - (t.__index || 0) }, readList: function (t, e, n, i) { for (var r, s = [], a = e || 0, o = i ? a + i : t.length, h = a; h < o; h++) { s.push(Array.isArray(r = t[h]) ? this.read(r, 0, n) : this.read(t, h, n, 1)) } return s }, readNamed: function (t, n, i, s, a) { var o = this.getNamed(t, n); var h = o !== e; if (h) { var u = t.__filtered; u || (u = t.__filtered = r.create(t[0]), u.__unfiltered = t[0]), u[n] = e } var l = h ? [o] : t; var c = this.read(l, i, s, a); return c }, getNamed: function (t, n) { var i = t[0]; if (t._hasObject === e && (t._hasObject = t.length === 1 && r.isPlainObject(i)), t._hasObject) { return n ? i[n] : t.__filtered || i } }, hasNamed: function (t, e) { return !!this.getNamed(t, e) }, filter: function (t, n, i, r) { function s (r) { if (!(i && r in i || a && r in a)) { var s = n[r]; s !== e && (t[r] = s) } } var a; if (r) { for (var o, h = {}, u = 0, l = r.length; u < l; u++) { (o = r[u]) in n && (s(o), h[o] = !0) }a = h } return Object.keys(n.__unfiltered || n).forEach(s), t }, isPlainValue: function (t, e) { return r.isPlainObject(t) || Array.isArray(t) || e && typeof t === `string` }, serialize: function (t, e, n, i) { e = e || {}; var s; var a = !i; if (a && (e.formatter = new h(e.precision), i = { length: 0, definitions: {}, references: {}, add: function (t, e) { var n = `#` + t._id; var i = this.references[n]; if (!i) { this.length++; var r = e.call(t); var s = t._class; s && r[0] !== s && r.unshift(s), this.definitions[n] = r, i = this.references[n] = [n] } return i } }), t && t._serialize) { s = t._serialize(e, i); var o = t._class; !o || t._compactSerialize || !a && n || s[0] === o || s.unshift(o) } else if (Array.isArray(t)) { s = []; for (var u = 0, l = t.length; u < l; u++) { s[u] = r.serialize(t[u], e, n, i) } } else if (r.isPlainObject(t)) { s = {}; for (var c = Object.keys(t), u = 0, l = c.length; u < l; u++) { var f = c[u]; s[f] = r.serialize(t[f], e, n, i) } } else { s = typeof t === `number` ? e.formatter.number(t, e.precision) : t } return a && i.length > 0 ? [[`dictionary`, i.definitions], s] : s }, deserialize: function (t, e, n, i, s) { var a = t; var o = !n; var h = o && t && t.length && t[0][0] === `dictionary`; if (n = n || {}, Array.isArray(t)) { var u = t[0]; var l = u === `dictionary`; if (t.length == 1 && /^#/.test(u)) { return n.dictionary[u] }u = r.exports[u], a = []; for (var c = u ? 1 : 0, f = t.length; c < f; c++) { a.push(r.deserialize(t[c], e, n, l, h)) } if (u) { var d = a; a = e ? e(u, d, o || s) : new u(d) } } else if (r.isPlainObject(t)) { a = {}, i && (n.dictionary = a); for (var _ in t) { a[_] = r.deserialize(t[_], e, n) } } return h ? a[1] : a }, exportJSON: function (t, e) { var n = r.serialize(t, e); return e && e.asString == 0 ? n : JSON.stringify(n) }, importJSON: function (t, e) { return r.deserialize(typeof t === `string` ? JSON.parse(t) : t, (t, n, i) => { var s = i && e && e.constructor === t; var a = s ? e : r.create(t.prototype); if (n.length === 1 && a instanceof w && (s || !(a instanceof b))) { var o = n[0]; r.isPlainObject(o) && (o.insert = !1) } return (s ? a.set : t).apply(a, n), s && (e = null), a }) }, push: function (t, e) { var n = e.length; if (n < 4096) { t.push.apply(t, e) } else { var i = t.length; t.length += n; for (var r = 0; r < n; r++) { t[i + r] = e[r] } } return t }, splice: function (t, n, i, s) { var a = n && n.length; var o = i === e; i = o ? t.length : i, i > t.length && (i = t.length); for (var h = 0; h < a; h++) { n[h]._index = i + h } if (o) { return r.push(t, n), [] } var u = [i, s]; n && r.push(u, n); for (var l = t.splice.apply(t, u), h = 0, c = l.length; h < c; h++) { l[h]._index = e } for (var h = i + a, c = t.length; h < c; h++) { t[h]._index = h } return l }, capitalize: function (t) { return t.replace(/\b[a-z]/g, (t) => { return t.toUpperCase() }) }, camelize: function (t) { return t.replace(/-(.)/g, (t, e) => { return e.toUpperCase() }) }, hyphenate: function (t) { return t.replace(/([a-z])([A-Z])/g, `$1-$2`).toLowerCase() } } }); var s = { on: function (t, e) { if (typeof t !== `string`) { r.each(t, function (t, e) { this.on(e, t) }, this) } else { var n = this._eventTypes; var i = n && n[t]; var s = this._callbacks = this._callbacks || {}; s = s[t] = s[t] || [], s.indexOf(e) === -1 && (s.push(e), i && i.install && s.length === 1 && i.install.call(this, t)) } return this }, off: function (t, e) { if (typeof t !== `string`) { return void r.each(t, function (t, e) { this.off(e, t) }, this) } var n; var i = this._eventTypes; var s = i && i[t]; var a = this._callbacks && this._callbacks[t]; return a && (!e || (n = a.indexOf(e)) !== -1 && a.length === 1 ? (s && s.uninstall && s.uninstall.call(this, t), delete this._callbacks[t]) : n !== -1 && a.splice(n, 1)), this }, once: function (t, e) { return this.on(t, function () { e.apply(this, arguments), this.off(t, e) }) }, emit: function (t, e) { var n = this._callbacks && this._callbacks[t]; if (!n) { return !1 } var i = r.slice(arguments, 1); var s = e && e.target && !e.currentTarget; n = n.slice(), s && (e.currentTarget = this); for (var a = 0, o = n.length; a < o; a++) { if (n[a].apply(this, i) == 0) { e && e.stop && e.stop(); break } } return s && delete e.currentTarget, !0 }, responds: function (t) { return !(!this._callbacks || !this._callbacks[t]) }, attach: `#on`, detach: `#off`, fire: `#emit`, _installEvents: function (t) { var e = this._eventTypes; var n = this._callbacks; var i = t ? `install` : `uninstall`; if (e) { for (var r in n) { if (n[r].length > 0) { var s = e[r]; var a = s && s[i]; a && a.call(this, r) } } } }, statics: { inject: function at (t) { var e = t._events; if (e) { var n = {}; r.each(e, (e, i) => { var s = typeof e === `string`; var a = s ? e : i; var o = r.capitalize(a); var h = a.substring(2).toLowerCase(); n[h] = s ? {} : e, a = `_` + a, t[`get` + o] = function () { return this[a] }, t[`set` + o] = function (t) { var e = this[a]; e && this.off(h, e), t && this.on(h, t), this[a] = t } }), t._eventTypes = n } return at.base.apply(this, arguments) } } }; var a = r.extend({ _class: `PaperScope`, initialize: function ot () { rt = this, this.settings = new r({ applyMatrix: !0, insertItems: !0, handleSize: 4, hitTolerance: 0 }), this.project = null, this.projects = [], this.tools = [], this._id = ot._id++, ot._scopes[this._id] = this; var e = ot.prototype; if (!this.support) { var n = tt.getContext(1, 1) || {}; e.support = { nativeDash: `setLineDash` in n || `mozDash` in n, nativeBlendModes: et.nativeModes }, tt.release(n) } if (!this.agent) { var i = t.navigator.userAgent.toLowerCase(); var s = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(i) || [])[0]; var a = s === `darwin` ? `mac` : s; var o = e.agent = e.browser = { platform: a }; a && (o[a] = !0), i.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, (t, e, n, i, r) => { if (!o.chrome) { var s = e === `opera` ? i : /^(node|trident)$/.test(e) ? r : n; o.version = s, o.versionNumber = parseFloat(s), e = e === `trident` ? `msie` : e, o.name = e, o[e] = !0 } }), o.chrome && delete o.webkit, o.atom && delete o.chrome } }, version: `0.11.8`, getView: function () { var t = this.project; return t && t._view }, getPaper: function () { return this }, execute: function (t, e) { var n = rt.PaperScript.execute(t, this, e); return Z.updateFocus(), n }, install: function (t) { var e = this; r.each([`project`, `view`, `tool`], (n) => { r.define(t, n, { configurable: !0, get: function () { return e[n] } }) }); for (var n in this) { !/^_/.test(n) && this[n] && (t[n] = this[n]) } }, setup: function (t) { return rt = this, this.project = new y(t), this }, createCanvas: function (t, e) { return tt.getCanvas(t, e) }, activate: function () { rt = this }, clear: function () { for (var t = this.projects, e = this.tools, n = t.length - 1; n >= 0; n--) { t[n].remove() } for (var n = e.length - 1; n >= 0; n--) { e[n].remove() } }, remove: function () { this.clear(), delete a._scopes[this._id] }, statics: new function () { function t (t) { return t += `Attribute`, function (e, n) { return e[t](n) || e[t](`data-paper-` + n) } } return { _scopes: {}, _id: 0, get: function (t) { return this._scopes[t] || null }, getAttribute: t(`get`), hasAttribute: t(`has`) } }() }); var o = r.extend(s, { initialize: function (t) { this._scope = rt, this._index = this._scope[this._list].push(this) - 1, !t && this._scope[this._reference] || this.activate() }, activate: function () { if (!this._scope) { return !1 } var t = this._scope[this._reference]; return t && t !== this && t.emit(`deactivate`), this._scope[this._reference] = this, this.emit(`activate`, t), !0 }, isActive: function () { return this._scope[this._reference] === this }, remove: function () { return this._index != null && (r.splice(this._scope[this._list], null, this._index, 1), this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, !0) }, getView: function () { return this._scope.getView() } }); var h = r.extend({ initialize: function (t) { this.precision = r.pick(t, 5), this.multiplier = Math.pow(10, this.precision) }, number: function (t) { return this.precision < 16 ? Math.round(t * this.multiplier) / this.multiplier : t }, pair: function (t, e, n) { return this.number(t) + (n || `,`) + this.number(e) }, point: function (t, e) { return this.number(t.x) + (e || `,`) + this.number(t.y) }, size: function (t, e) { return this.number(t.width) + (e || `,`) + this.number(t.height) }, rectangle: function (t, e) { return this.point(t, e) + (e || `,`) + this.size(t, e) } }); h.instance = new h(); var u = new function () { function t (t, e, n) { return t < e ? e : t > n ? n : t } function e (t, e, n) { function i (t) { var e = 134217729 * t; var n = t - e; var i = n + e; var r = t - i; return [i, r] } var r = e * e - t * n; var a = e * e + t * n; if (3 * s(r) < a) { var o = i(t); var h = i(e); var u = i(n); var l = e * e; var c = h[0] * h[0] - l + 2 * h[0] * h[1] + h[1] * h[1]; var f = t * n; var d = o[0] * u[0] - f + o[0] * u[1] + o[1] * u[0] + o[1] * u[1]; r = l - f + (c - d) } return r } function n () { var t = Math.max.apply(Math, arguments); return t && (t < 1e-8 || t > 1e8) ? o(2, -Math.round(h(t))) : 0 } var i = [[0.5773502691896257], [0, 0.7745966692414834], [0.33998104358485626, 0.8611363115940526], [0, 0.5384693101056831, 0.906179845938664], [0.2386191860831969, 0.6612093864662645, 0.932469514203152], [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585], [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363], [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261], [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717], [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057], [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192], [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881], [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123], [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854], [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499]]; var r = [[1], [0.8888888888888888, 0.5555555555555556], [0.6521451548625461, 0.34785484513745385], [0.5688888888888889, 0.47862867049936647, 0.23692688505618908], [0.46791393457269104, 0.3607615730481386, 0.17132449237917036], [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697], [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626], [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441], [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814], [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366], [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183], [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588], [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186], [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727], [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096]]; var s = Math.abs; var a = Math.sqrt; var o = Math.pow; var h = Math.log2 || function (t) { return Math.log(t) * Math.LOG2E }; var l = 1e-12; var c = 1.12e-16; return { EPSILON: l, MACHINE_EPSILON: c, CURVETIME_EPSILON: 1e-8, GEOMETRIC_EPSILON: 1e-7, TRIGONOMETRIC_EPSILON: 1e-8, KAPPA: 4 * (a(2) - 1) / 3, isZero: function (t) { return t >= -l && t <= l }, clamp: t, integrate: function (t, e, n, s) { for (var a = i[s - 2], o = r[s - 2], h = 0.5 * (n - e), u = h + e, l = 0, c = s + 1 >> 1, f = 1 & s ? o[l++] * t(u) : 0; l < c;) { var d = h * a[l]; f += o[l++] * (t(u + d) + t(u - d)) } return h * f }, findRoot: function (e, n, i, r, a, o, h) { for (var u = 0; u < o; u++) { var l = e(i); var c = l / n(i); var f = i - c; if (s(c) < h) { i = f; break }l > 0 ? (a = i, i = f <= r ? 0.5 * (r + a) : f) : (r = i, i = f >= a ? 0.5 * (r + a) : f) } return t(i, r, a) }, solveQuadratic: function (i, r, o, h, u, f) { var d; var _ = 1 / 0; if (s(i) < l) { if (s(r) < l) { return s(o) < l ? -1 : 0 }d = -o / r } else { r *= -0.5; var g = e(i, r, o); if (g && s(g) < c) { var v = n(s(i), s(r), s(o)); v && (i *= v, r *= v, o *= v, g = e(i, r, o)) } if (g >= -c) { var p = g < 0 ? 0 : a(g); var m = r + (r < 0 ? -p : p); m === 0 ? (d = o / i, _ = -d) : (d = m / i, _ = o / m) } } var y = 0; var w = u == null; var x = u - l; var b = f + l; return isFinite(d) && (w || d > x && d < b) && (h[y++] = w ? d : t(d, u, f)), _ !== d && isFinite(_) && (w || _ > x && _ < b) && (h[y++] = w ? _ : t(_, u, f)), y }, solveCubic: function (e, i, r, h, f, d, _) { function g (t) { v = t; var n = e * v; p = n + i, m = p * v + r, y = (n + p) * v + m, w = m * v + h } var v; var p; var m; var y; var w; var x = n(s(e), s(i), s(r), s(h)); if (x && (e *= x, i *= x, r *= x, h *= x), s(e) < l) { e = i, p = r, m = h, v = 1 / 0 } else if (s(h) < l) { p = i, m = r, v = 0 } else { g(-(i / e) / 3); var b = w / e; var C = o(s(b), 1 / 3); var S = b < 0 ? -1 : 1; var k = -y / e; var I = k > 0 ? 1.324717957244746 * Math.max(C, a(k)) : C; var P = v - S * I; if (P !== v) { do { g(P), P = y === 0 ? v : v - w / y / (1 + c) } while (S * P > S * v);s(e) * v * v > s(h / v) && (m = -h / v, p = (m - r) / v) } } var M = u.solveQuadratic(e, p, m, f, d, _); var T = d == null; return isFinite(v) && (M === 0 || M > 0 && v !== f[0] && v !== f[1]) && (T || v > d - l && v < _ + l) && (f[M++] = T ? v : t(v, d, _)), M } } }(); var l = { _id: 1, _pools: {}, get: function (t) { if (t) { var e = this._pools[t]; return e || (e = this._pools[t] = { _id: 1 }), e._id++ } return this._id++ } }; var c = r.extend({ _class: `Point`, _readIndex: !0, initialize: function (t, e) { var n = typeof t; var i = this.__read; var r = 0; if (n === `number`) { var s = typeof e === `number`; this._set(t, s ? e : t), i && (r = s ? 2 : 1) } else if (n === `undefined` || t === null) { this._set(0, 0), i && (r = t === null ? 1 : 0) } else { var a = n === `string` ? t.split(/[\s,]+/) || [] : t; r = 1, Array.isArray(a) ? this._set(+a[0], +(a.length > 1 ? a[1] : a[0])) : `x` in a ? this._set(a.x || 0, a.y || 0) : `width` in a ? this._set(a.width || 0, a.height || 0) : `angle` in a ? (this._set(a.length || 0, 0), this.setAngle(a.angle || 0)) : (this._set(0, 0), r = 0) } return i && (this.__read = r), this }, set: `#initialize`, _set: function (t, e) { return this.x = t, this.y = e, this }, equals: function (t) { return this === t || t && (this.x === t.x && this.y === t.y || Array.isArray(t) && this.x === t[0] && this.y === t[1]) || !1 }, clone: function () { return new c(this.x, this.y) }, toString: function () { var t = h.instance; return `{ x: ` + t.number(this.x) + `, y: ` + t.number(this.y) + ` }` }, _serialize: function (t) { var e = t.formatter; return [e.number(this.x), e.number(this.y)] }, getLength: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, setLength: function (t) { if (this.isZero()) { var e = this._angle || 0; this._set(Math.cos(e) * t, Math.sin(e) * t) } else { var n = t / this.getLength(); u.isZero(n) && this.getAngle(), this._set(this.x * n, this.y * n) } }, getAngle: function () { return 180 * this.getAngleInRadians.apply(this, arguments) / Math.PI }, setAngle: function (t) { this.setAngleInRadians.call(this, t * Math.PI / 180) }, getAngleInDegrees: `#getAngle`, setAngleInDegrees: `#setAngle`, getAngleInRadians: function () { if (arguments.length) { var t = c.read(arguments); var e = this.getLength() * t.getLength(); if (u.isZero(e)) { return NaN } var n = this.dot(t) / e; return Math.acos(n < -1 ? -1 : n > 1 ? 1 : n) } return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x) }, setAngleInRadians: function (t) { if (this._angle = t, !this.isZero()) { var e = this.getLength(); this._set(Math.cos(t) * e, Math.sin(t) * e) } }, getQuadrant: function () { return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3 } }, { beans: !1, getDirectedAngle: function () { var t = c.read(arguments); return 180 * Math.atan2(this.cross(t), this.dot(t)) / Math.PI }, getDistance: function () { var t = c.read(arguments); var e = t.x - this.x; var n = t.y - this.y; var i = e * e + n * n; var s = r.read(arguments); return s ? i : Math.sqrt(i) }, normalize: function (t) { t === e && (t = 1); var n = this.getLength(); var i = n !== 0 ? t / n : 0; var r = new c(this.x * i, this.y * i); return i >= 0 && (r._angle = this._angle), r }, rotate: function (t, e) { if (t === 0) { return this.clone() }t = t * Math.PI / 180; var n = e ? this.subtract(e) : this; var i = Math.sin(t); var r = Math.cos(t); return n = new c(n.x * r - n.y * i, n.x * i + n.y * r), e ? n.add(e) : n }, transform: function (t) { return t ? t._transformPoint(this) : this }, add: function () { var t = c.read(arguments); return new c(this.x + t.x, this.y + t.y) }, subtract: function () { var t = c.read(arguments); return new c(this.x - t.x, this.y - t.y) }, multiply: function () { var t = c.read(arguments); return new c(this.x * t.x, this.y * t.y) }, divide: function () { var t = c.read(arguments); return new c(this.x / t.x, this.y / t.y) }, modulo: function () { var t = c.read(arguments); return new c(this.x % t.x, this.y % t.y) }, negate: function () { return new c((-this.x), (-this.y)) }, isInside: function () { return g.read(arguments).contains(this) }, isClose: function () { var t = c.read(arguments); var e = r.read(arguments); return this.getDistance(t) <= e }, isCollinear: function () { var t = c.read(arguments); return c.isCollinear(this.x, this.y, t.x, t.y) }, isColinear: `#isCollinear`, isOrthogonal: function () { var t = c.read(arguments); return c.isOrthogonal(this.x, this.y, t.x, t.y) }, isZero: function () { var t = u.isZero; return t(this.x) && t(this.y) }, isNaN: function () { return isNaN(this.x) || isNaN(this.y) }, isInQuadrant: function (t) { return this.x * (t > 1 && t < 4 ? -1 : 1) >= 0 && this.y * (t > 2 ? -1 : 1) >= 0 }, dot: function () { var t = c.read(arguments); return this.x * t.x + this.y * t.y }, cross: function () { var t = c.read(arguments); return this.x * t.y - this.y * t.x }, project: function () { var t = c.read(arguments); var e = t.isZero() ? 0 : this.dot(t) / t.dot(t); return new c(t.x * e, t.y * e) }, statics: { min: function () { var t = c.read(arguments); var e = c.read(arguments); return new c(Math.min(t.x, e.x), Math.min(t.y, e.y)) }, max: function () { var t = c.read(arguments); var e = c.read(arguments); return new c(Math.max(t.x, e.x), Math.max(t.y, e.y)) }, random: function () { return new c(Math.random(), Math.random()) }, isCollinear: function (t, e, n, i) { return Math.abs(t * i - e * n) <= 1e-8 * Math.sqrt((t * t + e * e) * (n * n + i * i)) }, isOrthogonal: function (t, e, n, i) { return Math.abs(t * n + e * i) <= 1e-8 * Math.sqrt((t * t + e * e) * (n * n + i * i)) } } }, r.each([`round`, `ceil`, `floor`, `abs`], function (t) { var e = Math[t]; this[t] = function () { return new c(e(this.x), e(this.y)) } }, {})); var f = c.extend({ initialize: function (t, e, n, i) { this._x = t, this._y = e, this._owner = n, this._setter = i }, _set: function (t, e, n) { return this._x = t, this._y = e, n || this._owner[this._setter](this), this }, getX: function () { return this._x }, setX: function (t) { this._x = t, this._owner[this._setter](this) }, getY: function () { return this._y }, setY: function (t) { this._y = t, this._owner[this._setter](this) }, isSelected: function () { return !!(this._owner._selection & this._getSelection()) }, setSelected: function (t) { this._owner._changeSelection(this._getSelection(), t) }, _getSelection: function () { return this._setter === `setPosition` ? 4 : 0 } }); var d = r.extend({ _class: `Size`, _readIndex: !0, initialize: function (t, e) { var n = typeof t; var i = this.__read; var r = 0; if (n === `number`) { var s = typeof e === `number`; this._set(t, s ? e : t), i && (r = s ? 2 : 1) } else if (n === `undefined` || t === null) { this._set(0, 0), i && (r = t === null ? 1 : 0) } else { var a = n === `string` ? t.split(/[\s,]+/) || [] : t; r = 1, Array.isArray(a) ? this._set(+a[0], +(a.length > 1 ? a[1] : a[0])) : `width` in a ? this._set(a.width || 0, a.height || 0) : `x` in a ? this._set(a.x || 0, a.y || 0) : (this._set(0, 0), r = 0) } return i && (this.__read = r), this }, set: `#initialize`, _set: function (t, e) { return this.width = t, this.height = e, this }, equals: function (t) { return t === this || t && (this.width === t.width && this.height === t.height || Array.isArray(t) && this.width === t[0] && this.height === t[1]) || !1 }, clone: function () { return new d(this.width, this.height) }, toString: function () { var t = h.instance; return `{ width: ` + t.number(this.width) + `, height: ` + t.number(this.height) + ` }` }, _serialize: function (t) { var e = t.formatter; return [e.number(this.width), e.number(this.height)] }, add: function () { var t = d.read(arguments); return new d(this.width + t.width, this.height + t.height) }, subtract: function () { var t = d.read(arguments); return new d(this.width - t.width, this.height - t.height) }, multiply: function () { var t = d.read(arguments); return new d(this.width * t.width, this.height * t.height) }, divide: function () { var t = d.read(arguments); return new d(this.width / t.width, this.height / t.height) }, modulo: function () { var t = d.read(arguments); return new d(this.width % t.width, this.height % t.height) }, negate: function () { return new d((-this.width), (-this.height)) }, isZero: function () { var t = u.isZero; return t(this.width) && t(this.height) }, isNaN: function () { return isNaN(this.width) || isNaN(this.height) }, statics: { min: function (t, e) { return new d(Math.min(t.width, e.width), Math.min(t.height, e.height)) }, max: function (t, e) { return new d(Math.max(t.width, e.width), Math.max(t.height, e.height)) }, random: function () { return new d(Math.random(), Math.random()) } } }, r.each([`round`, `ceil`, `floor`, `abs`], function (t) { var e = Math[t]; this[t] = function () { return new d(e(this.width), e(this.height)) } }, {})); var _ = d.extend({ initialize: function (t, e, n, i) { this._width = t, this._height = e, this._owner = n, this._setter = i }, _set: function (t, e, n) { return this._width = t, this._height = e, n || this._owner[this._setter](this), this }, getWidth: function () { return this._width }, setWidth: function (t) { this._width = t, this._owner[this._setter](this) }, getHeight: function () { return this._height }, setHeight: function (t) { this._height = t, this._owner[this._setter](this) } }); var g = r.extend({ _class: `Rectangle`, _readIndex: !0, beans: !0, initialize: function (t, n, i, s) { var a; var o = typeof t; if (o === `number` ? (this._set(t, n, i, s), a = 4) : o === `undefined` || t === null ? (this._set(0, 0, 0, 0), a = t === null ? 1 : 0) : arguments.length === 1 && (Array.isArray(t) ? (this._set.apply(this, t), a = 1) : t.x !== e || t.width !== e ? (this._set(t.x || 0, t.y || 0, t.width || 0, t.height || 0), a = 1) : t.from === e && t.to === e && (this._set(0, 0, 0, 0), r.filter(this, t), a = 1)), a === e) { var h; var u; var l = c.readNamed(arguments, `from`); var f = r.peek(arguments); var _ = l.x; var g = l.y; if (f && f.x !== e || r.hasNamed(arguments, `to`)) { var v = c.readNamed(arguments, `to`); h = v.x - _, u = v.y - g, h < 0 && (_ = v.x, h = -h), u < 0 && (g = v.y, u = -u) } else { var p = d.read(arguments); h = p.width, u = p.height } this._set(_, g, h, u), a = arguments.__index; var m = arguments.__filtered; m && (this.__filtered = m) } return this.__read && (this.__read = a), this }, set: `#initialize`, _set: function (t, e, n, i) { return this.x = t, this.y = e, this.width = n, this.height = i, this }, clone: function () { return new g(this.x, this.y, this.width, this.height) }, equals: function (t) { var e = r.isPlainValue(t) ? g.read(arguments) : t; return e === this || e && this.x === e.x && this.y === e.y && this.width === e.width && this.height === e.height || !1 }, toString: function () { var t = h.instance; return `{ x: ` + t.number(this.x) + `, y: ` + t.number(this.y) + `, width: ` + t.number(this.width) + `, height: ` + t.number(this.height) + ` }` }, _serialize: function (t) { var e = t.formatter; return [e.number(this.x), e.number(this.y), e.number(this.width), e.number(this.height)] }, getPoint: function (t) { var e = t ? c : f; return new e(this.x, this.y, this, `setPoint`) }, setPoint: function () { var t = c.read(arguments); this.x = t.x, this.y = t.y }, getSize: function (t) { var e = t ? d : _; return new e(this.width, this.height, this, `setSize`) }, _fw: 1, _fh: 1, setSize: function () { var t = d.read(arguments); var e = this._sx; var n = this._sy; var i = t.width; var r = t.height; e && (this.x += (this.width - i) * e), n && (this.y += (this.height - r) * n), this.width = i, this.height = r, this._fw = this._fh = 1 }, getLeft: function () { return this.x }, setLeft: function (t) { if (!this._fw) { var e = t - this.x; this.width -= this._sx === 0.5 ? 2 * e : e } this.x = t, this._sx = this._fw = 0 }, getTop: function () { return this.y }, setTop: function (t) { if (!this._fh) { var e = t - this.y; this.height -= this._sy === 0.5 ? 2 * e : e } this.y = t, this._sy = this._fh = 0 }, getRight: function () { return this.x + this.width }, setRight: function (t) { if (!this._fw) { var e = t - this.x; this.width = this._sx === 0.5 ? 2 * e : e } this.x = t - this.width, this._sx = 1, this._fw = 0 }, getBottom: function () { return this.y + this.height }, setBottom: function (t) { if (!this._fh) { var e = t - this.y; this.height = this._sy === 0.5 ? 2 * e : e } this.y = t - this.height, this._sy = 1, this._fh = 0 }, getCenterX: function () { return this.x + this.width / 2 }, setCenterX: function (t) { this._fw || this._sx === 0.5 ? this.x = t - this.width / 2 : (this._sx && (this.x += 2 * (t - this.x) * this._sx), this.width = 2 * (t - this.x)), this._sx = 0.5, this._fw = 0 }, getCenterY: function () { return this.y + this.height / 2 }, setCenterY: function (t) { this._fh || this._sy === 0.5 ? this.y = t - this.height / 2 : (this._sy && (this.y += 2 * (t - this.y) * this._sy), this.height = 2 * (t - this.y)), this._sy = 0.5, this._fh = 0 }, getCenter: function (t) { var e = t ? c : f; return new e(this.getCenterX(), this.getCenterY(), this, `setCenter`) }, setCenter: function () { var t = c.read(arguments); return this.setCenterX(t.x), this.setCenterY(t.y), this }, getArea: function () { return this.width * this.height }, isEmpty: function () { return this.width === 0 || this.height === 0 }, contains: function (t) { return t && t.width !== e || (Array.isArray(t) ? t : arguments).length === 4 ? this._containsRectangle(g.read(arguments)) : this._containsPoint(c.read(arguments)) }, _containsPoint: function (t) { var e = t.x; var n = t.y; return e >= this.x && n >= this.y && e <= this.x + this.width && n <= this.y + this.height }, _containsRectangle: function (t) { var e = t.x; var n = t.y; return e >= this.x && n >= this.y && e + t.width <= this.x + this.width && n + t.height <= this.y + this.height }, intersects: function () { var t = g.read(arguments); var e = r.read(arguments) || 0; return t.x + t.width > this.x - e && t.y + t.height > this.y - e && t.x < this.x + this.width + e && t.y < this.y + this.height + e }, intersect: function () { var t = g.read(arguments); var e = Math.max(this.x, t.x); var n = Math.max(this.y, t.y); var i = Math.min(this.x + this.width, t.x + t.width); var r = Math.min(this.y + this.height, t.y + t.height); return new g(e, n, i - e, r - n) }, unite: function () { var t = g.read(arguments); var e = Math.min(this.x, t.x); var n = Math.min(this.y, t.y); var i = Math.max(this.x + this.width, t.x + t.width); var r = Math.max(this.y + this.height, t.y + t.height); return new g(e, n, i - e, r - n) }, include: function () { var t = c.read(arguments); var e = Math.min(this.x, t.x); var n = Math.min(this.y, t.y); var i = Math.max(this.x + this.width, t.x); var r = Math.max(this.y + this.height, t.y); return new g(e, n, i - e, r - n) }, expand: function () { var t = d.read(arguments); var e = t.width; var n = t.height; return new g(this.x - e / 2, this.y - n / 2, this.width + e, this.height + n) }, scale: function (t, n) { return this.expand(this.width * t - this.width, this.height * (n === e ? t : n) - this.height) } }, r.each([[`Top`, `Left`], [`Top`, `Right`], [`Bottom`, `Left`], [`Bottom`, `Right`], [`Left`, `Center`], [`Top`, `Center`], [`Right`, `Center`], [`Bottom`, `Center`]], function (t, e) { var n = t.join(``); var i = /^[RL]/.test(n); e >= 4 && (t[1] += i ? `Y` : `X`); var r = t[i ? 0 : 1]; var s = t[i ? 1 : 0]; var a = `get` + r; var o = `get` + s; var h = `set` + r; var u = `set` + s; var l = `get` + n; var d = `set` + n; this[l] = function (t) { var e = t ? c : f; return new e(this[a](), this[o](), this, d) }, this[d] = function () { var t = c.read(arguments); this[h](t.x), this[u](t.y) } }, { beans: !0 })); var v = g.extend({ initialize: function (t, e, n, i, r, s) { this._set(t, e, n, i, !0), this._owner = r, this._setter = s }, _set: function (t, e, n, i, r) { return this._x = t, this._y = e, this._width = n, this._height = i, r || this._owner[this._setter](this), this } }, new function () { var t = g.prototype; return r.each([`x`, `y`, `width`, `height`], function (t) { var e = r.capitalize(t); var n = `_` + t; this[`get` + e] = function () { return this[n] }, this[`set` + e] = function (t) { this[n] = t, this._dontNotify || this._owner[this._setter](this) } }, r.each([`Point`, `Size`, `Center`, `Left`, `Top`, `Right`, `Bottom`, `CenterX`, `CenterY`, `TopLeft`, `TopRight`, `BottomLeft`, `BottomRight`, `LeftCenter`, `TopCenter`, `RightCenter`, `BottomCenter`], function (e) { var n = `set` + e; this[n] = function () { this._dontNotify = !0, t[n].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this) } }, { isSelected: function () { return !!(2 & this._owner._selection) }, setSelected: function (t) { var e = this._owner; e._changeSelection && e._changeSelection(2, t) } })) }()); var p = r.extend({ _class: `Matrix`,
    initialize: function ht (t, e) { var n = arguments.length; var i = !0; if (n >= 6 ? this._set.apply(this, arguments) : n === 1 || n === 2 ? t instanceof ht ? this._set(t._a, t._b, t._c, t._d, t._tx, t._ty, e) : Array.isArray(t) ? this._set.apply(this, e ? t.concat([e]) : t) : i = !1 : n ? i = !1 : this.reset(), !i) { throw new Error(`Unsupported matrix parameters`) } return this },
    set: `#initialize`,
    _set: function (t, e, n, i, r, s, a) { return this._a = t, this._b = e, this._c = n, this._d = i, this._tx = r, this._ty = s, a || this._changed(), this },
    _serialize: function (t, e) { return r.serialize(this.getValues(), t, !0, e) },
    _changed: function () { var t = this._owner; t && (t._applyMatrix ? t.transform(null, !0) : t._changed(25)) },
    clone: function () { return new p(this._a, this._b, this._c, this._d, this._tx, this._ty) },
    equals: function (t) { return t === this || t && this._a === t._a && this._b === t._b && this._c === t._c && this._d === t._d && this._tx === t._tx && this._ty === t._ty },
    toString: function () { var t = h.instance; return `[[` + [t.number(this._a), t.number(this._c), t.number(this._tx)].join(`, `) + `], [` + [t.number(this._b), t.number(this._d), t.number(this._ty)].join(`, `) + `]]` },
    reset: function (t) { return this._a = this._d = 1, this._b = this._c = this._tx = this._ty = 0, t || this._changed(), this },
    apply: function (t, e) { var n = this._owner; return !!n && (n.transform(null, !0, r.pick(t, !0), e), this.isIdentity()) },
    translate: function () { var t = c.read(arguments); var e = t.x; var n = t.y; return this._tx += e * this._a + n * this._c, this._ty += e * this._b + n * this._d, this._changed(), this },
    scale: function () {
      var t = c.read(arguments); var e = c.read(arguments, 0, { readNull: !0 }); return e && this.translate(e), this._a *= t.x, this._b *= t.x, this._c *= t.y,
      this._d *= t.y, e && this.translate(e.negate()), this._changed(), this
    },
    rotate: function (t) { t *= Math.PI / 180; var e = c.read(arguments, 1); var n = e.x; var i = e.y; var r = Math.cos(t); var s = Math.sin(t); var a = n - n * r + i * s; var o = i - n * s - i * r; var h = this._a; var u = this._b; var l = this._c; var f = this._d; return this._a = r * h + s * l, this._b = r * u + s * f, this._c = -s * h + r * l, this._d = -s * u + r * f, this._tx += a * h + o * l, this._ty += a * u + o * f, this._changed(), this },
    shear: function () { var t = c.read(arguments); var e = c.read(arguments, 0, { readNull: !0 }); e && this.translate(e); var n = this._a; var i = this._b; return this._a += t.y * this._c, this._b += t.y * this._d, this._c += t.x * n, this._d += t.x * i, e && this.translate(e.negate()), this._changed(), this },
    skew: function () { var t = c.read(arguments); var e = c.read(arguments, 0, { readNull: !0 }); var n = Math.PI / 180; var i = new c(Math.tan(t.x * n), Math.tan(t.y * n)); return this.shear(i, e) },
    append: function (t, e) { if (t) { var n = this._a; var i = this._b; var r = this._c; var s = this._d; var a = t._a; var o = t._c; var h = t._b; var u = t._d; var l = t._tx; var c = t._ty; this._a = a * n + h * r, this._c = o * n + u * r, this._b = a * i + h * s, this._d = o * i + u * s, this._tx += l * n + c * r, this._ty += l * i + c * s, e || this._changed() } return this },
    prepend: function (t, e) { if (t) { var n = this._a; var i = this._b; var r = this._c; var s = this._d; var a = this._tx; var o = this._ty; var h = t._a; var u = t._c; var l = t._b; var c = t._d; var f = t._tx; var d = t._ty; this._a = h * n + u * i, this._c = h * r + u * s, this._b = l * n + c * i, this._d = l * r + c * s, this._tx = h * a + u * o + f, this._ty = l * a + c * o + d, e || this._changed() } return this },
    appended: function (t) { return this.clone().append(t) },
    prepended: function (t) { return this.clone().prepend(t) },
    invert: function () { var t = this._a; var e = this._b; var n = this._c; var i = this._d; var r = this._tx; var s = this._ty; var a = t * i - e * n; var o = null; return a && !isNaN(a) && isFinite(r) && isFinite(s) && (this._a = i / a, this._b = -e / a, this._c = -n / a, this._d = t / a, this._tx = (n * s - i * r) / a, this._ty = (e * r - t * s) / a, o = this), o },
    inverted: function () { return this.clone().invert() },
    concatenate: `#append`,
    preConcatenate: `#prepend`,
    chain: `#appended`,
    _shiftless: function () { return new p(this._a, this._b, this._c, this._d, 0, 0) },
    _orNullIfIdentity: function () { return this.isIdentity() ? null : this },
    isIdentity: function () { return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0 },
    isInvertible: function () { var t = this._a * this._d - this._c * this._b; return t && !isNaN(t) && isFinite(this._tx) && isFinite(this._ty) },
    isSingular: function () { return !this.isInvertible() },
    transform: function (t, e, n) { return arguments.length < 3 ? this._transformPoint(c.read(arguments)) : this._transformCoordinates(t, e, n) },
    _transformPoint: function (t, e, n) { var i = t.x; var r = t.y; return e || (e = new c()), e._set(i * this._a + r * this._c + this._tx, i * this._b + r * this._d + this._ty, n) },
    _transformCoordinates: function (t, e, n) { for (var i = 0, r = 2 * n; i < r; i += 2) { var s = t[i]; var a = t[i + 1]; e[i] = s * this._a + a * this._c + this._tx, e[i + 1] = s * this._b + a * this._d + this._ty } return e },
    _transformCorners: function (t) { var e = t.x; var n = t.y; var i = e + t.width; var r = n + t.height; var s = [e, n, i, n, i, r, e, r]; return this._transformCoordinates(s, s, 4) },
    _transformBounds: function (t, e, n) { for (var i = this._transformCorners(t), r = i.slice(0, 2), s = r.slice(), a = 2; a < 8; a++) { var o = i[a]; var h = 1 & a; o < r[h] ? r[h] = o : o > s[h] && (s[h] = o) } return e || (e = new g()), e._set(r[0], r[1], s[0] - r[0], s[1] - r[1], n) },
    inverseTransform: function () { return this._inverseTransform(c.read(arguments)) },
    _inverseTransform: function (t, e, n) { var i = this._a; var r = this._b; var s = this._c; var a = this._d; var o = this._tx; var h = this._ty; var u = i * a - r * s; var l = null; if (u && !isNaN(u) && isFinite(o) && isFinite(h)) { var f = t.x - this._tx; var d = t.y - this._ty; e || (e = new c()), l = e._set((f * a - d * s) / u, (d * i - f * r) / u, n) } return l },
    decompose: function () { var t; var e; var n; var i = this._a; var r = this._b; var s = this._c; var a = this._d; var o = i * a - r * s; var h = Math.sqrt; var u = Math.atan2; var l = 180 / Math.PI; if (i !== 0 || r !== 0) { var f = h(i * i + r * r); t = Math.acos(i / f) * (r > 0 ? 1 : -1), e = [f, o / f], n = [u(i * s + r * a, f * f), 0] } else if (s !== 0 || a !== 0) { var d = h(s * s + a * a); t = Math.asin(s / d) * (a > 0 ? 1 : -1), e = [o / d, d], n = [0, u(i * s + r * a, d * d)] } else { t = 0, n = e = [0, 0] } return { translation: this.getTranslation(), rotation: t * l, scaling: new c(e), skewing: new c(n[0] * l, n[1] * l) } },
    getValues: function () { return [this._a, this._b, this._c, this._d, this._tx, this._ty] },
    getTranslation: function () { return new c(this._tx, this._ty) },
    getScaling: function () { return (this.decompose() || {}).scaling },
    getRotation: function () { return (this.decompose() || {}).rotation },
    applyToContext: function (t) { this.isIdentity() || t.transform(this._a, this._b, this._c, this._d, this._tx, this._ty) } }, r.each([`a`, `b`, `c`, `d`, `tx`, `ty`], function (t) { var e = r.capitalize(t); var n = `_` + t; this[`get` + e] = function () { return this[n] }, this[`set` + e] = function (t) { this[n] = t, this._changed() } }, {})); var m = r.extend({ _class: `Line`, initialize: function (t, e, n, i, r) { var s = !1; arguments.length >= 4 ? (this._px = t, this._py = e, this._vx = n, this._vy = i, s = r) : (this._px = t.x, this._py = t.y, this._vx = e.x, this._vy = e.y, s = n), s || (this._vx -= this._px, this._vy -= this._py) }, getPoint: function () { return new c(this._px, this._py) }, getVector: function () { return new c(this._vx, this._vy) }, getLength: function () { return this.getVector().getLength() }, intersect: function (t, e) { return m.intersect(this._px, this._py, this._vx, this._vy, t._px, t._py, t._vx, t._vy, !0, e) }, getSide: function (t, e) { return m.getSide(this._px, this._py, this._vx, this._vy, t.x, t.y, !0, e) }, getDistance: function (t) { return Math.abs(this.getSignedDistance(t)) }, getSignedDistance: function (t) { return m.getSignedDistance(this._px, this._py, this._vx, this._vy, t.x, t.y, !0) }, isCollinear: function (t) { return c.isCollinear(this._vx, this._vy, t._vx, t._vy) }, isOrthogonal: function (t) { return c.isOrthogonal(this._vx, this._vy, t._vx, t._vy) }, statics: { intersect: function (t, e, n, i, r, s, a, o, h, l) { h || (n -= t, i -= e, a -= r, o -= s); var f = n * o - i * a; if (!u.isZero(f)) { var d = t - r; var _ = e - s; var g = (a * _ - o * d) / f; var v = (n * _ - i * d) / f; var p = 1e-12; var m = -p; var y = 1 + p; if (l || m < g && g < y && m < v && v < y) { return l || (g = g <= 0 ? 0 : g >= 1 ? 1 : g), new c(t + g * n, e + g * i) } } }, getSide: function (t, e, n, i, r, s, a, o) { a || (n -= t, i -= e); var h = r - t; var l = s - e; var c = h * i - l * n; return !o && u.isZero(c) && (c = (h * n + h * n) / (n * n + i * i), c >= 0 && c <= 1 && (c = 0)), c < 0 ? -1 : c > 0 ? 1 : 0 }, getSignedDistance: function (t, e, n, i, r, s, a) { return a || (n -= t, i -= e), n === 0 ? i > 0 ? r - t : t - r : i === 0 ? n < 0 ? s - e : e - s : ((r - t) * i - (s - e) * n) / Math.sqrt(n * n + i * i) }, getDistance: function (t, e, n, i, r, s, a) { return Math.abs(m.getSignedDistance(t, e, n, i, r, s, a)) } } }); var y = o.extend({ _class: `Project`, _list: `projects`, _reference: `project`, _compactSerialize: !0, initialize: function (t) { o.call(this, !0), this._children = [], this._namedChildren = {}, this._activeLayer = null, this._currentStyle = new V(null, null, this), this._view = Z.create(this, t || tt.getCanvas(1, 1)), this._selectionItems = {}, this._selectionCount = 0, this._updateVersion = 0 }, _serialize: function (t, e) { return r.serialize(this._children, t, !0, e) }, _changed: function (t, e) { if (1 & t) { var n = this._view; n && (n._needsUpdate = !0, !n._requested && n._autoUpdate && n.requestUpdate()) } var i = this._changes; if (i && e) { var r = this._changesById; var s = e._id; var a = r[s]; a ? a.flags |= t : i.push(r[s] = { item: e, flags: t }) } }, clear: function () { for (var t = this._children, e = t.length - 1; e >= 0; e--) { t[e].remove() } }, isEmpty: function () { return !this._children.length }, remove: function ut () { return !!ut.base.call(this) && (this._view && this._view.remove(), !0) }, getView: function () { return this._view }, getCurrentStyle: function () { return this._currentStyle }, setCurrentStyle: function (t) { this._currentStyle.set(t) }, getIndex: function () { return this._index }, getOptions: function () { return this._scope.settings }, getLayers: function () { return this._children }, getActiveLayer: function () { return this._activeLayer || new b({ project: this, insert: !0 }) }, getSymbolDefinitions: function () { var t = []; var e = {}; return this.getItems({ class: k, match: function (n) { var i = n._definition; var r = i._id; return e[r] || (e[r] = !0, t.push(i)), !1 } }), t }, getSymbols: `getSymbolDefinitions`, getSelectedItems: function () { var t = this._selectionItems; var e = []; for (var n in t) { var i = t[n]; var r = i._selection; 1 & r && i.isInserted() ? e.push(i) : r || this._updateSelection(i) } return e }, _updateSelection: function (t) { var e = t._id; var n = this._selectionItems; t._selection ? n[e] !== t && (this._selectionCount++, n[e] = t) : n[e] === t && (this._selectionCount--, delete n[e]) }, selectAll: function () { for (var t = this._children, e = 0, n = t.length; e < n; e++) { t[e].setFullySelected(!0) } }, deselectAll: function () { var t = this._selectionItems; for (var e in t) { t[e].setFullySelected(!1) } }, addLayer: function (t) { return this.insertLayer(e, t) }, insertLayer: function (t, e) { if (e instanceof b) { e._remove(!1, !0), r.splice(this._children, [e], t, 0), e._setProject(this, !0); var n = e._name; n && e.setName(n), this._changes && e._changed(5), this._activeLayer || (this._activeLayer = e) } else { e = null } return e }, _insertItem: function (t, n, i) { return n = this.insertLayer(t, n) || (this._activeLayer || this._insertItem(e, new b(w.NO_INSERT), !0)).insertChild(t, n), i && n.activate && n.activate(), n }, getItems: function (t) { return w._getItems(this, t) }, getItem: function (t) { return w._getItems(this, t, null, null, !0)[0] || null }, importJSON: function (t) { this.activate(); var e = this._activeLayer; return r.importJSON(t, e && e.isEmpty() && e) }, removeOn: function (t) { var e = this._removeSets; if (e) { t === `mouseup` && (e.mousedrag = null); var n = e[t]; if (n) { for (var i in n) { var r = n[i]; for (var s in e) { var a = e[s]; a && a != n && delete a[r._id] }r.remove() }e[t] = null } } }, draw: function (t, e, n) { this._updateVersion++, t.save(), e.applyToContext(t); for (var i = this._children, s = new r({ offset: new c(0, 0), pixelRatio: n, viewMatrix: e.isIdentity() ? null : e, matrices: [new p()], updateMatrix: !0 }), a = 0, o = i.length; a < o; a++) { i[a].draw(t, s) } if (t.restore(), this._selectionCount > 0) { t.save(), t.strokeWidth = 1; var h = this._selectionItems; var u = this._scope.settings.handleSize; var l = this._updateVersion; for (var f in h) { h[f]._drawSelection(t, e, u, h, l) }t.restore() } } }); var w = r.extend(s, { statics: { extend: function lt (t) { return t._serializeFields && (t._serializeFields = r.set({}, this.prototype._serializeFields, t._serializeFields)), lt.base.apply(this, arguments) }, NO_INSERT: { insert: !1 } }, _class: `Item`, _name: null, _applyMatrix: !0, _canApplyMatrix: !0, _canScaleStroke: !1, _pivot: null, _visible: !0, _blendMode: `normal`, _opacity: 1, _locked: !1, _guide: !1, _clipMask: !1, _selection: 0, _selectBounds: !0, _selectChildren: !1, _serializeFields: { name: null, applyMatrix: null, matrix: new p(), pivot: null, visible: !0, blendMode: `normal`, opacity: 1, locked: !1, guide: !1, clipMask: !1, selected: !1, data: {} }, _prioritize: [`applyMatrix`] }, new function () { var t = [`onMouseDown`, `onMouseUp`, `onMouseDrag`, `onClick`, `onDoubleClick`, `onMouseMove`, `onMouseEnter`, `onMouseLeave`]; return r.each(t, function (t) { this._events[t] = { install: function (t) { this.getView()._countItemEvent(t, 1) }, uninstall: function (t) { this.getView()._countItemEvent(t, -1) } } }, { _events: { onFrame: { install: function () { this.getView()._animateItem(this, !0) }, uninstall: function () { this.getView()._animateItem(this, !1) } }, onLoad: {}, onError: {} }, statics: { _itemHandlers: t } }) }(), { initialize: function () {}, _initialize: function (t, n) { var i = t && r.isPlainObject(t); var s = i && t.internal === !0; var a = this._matrix = new p(); var o = i && t.project || rt.project; var h = rt.settings; return this._id = s ? null : l.get(), this._parent = this._index = null, this._applyMatrix = this._canApplyMatrix && h.applyMatrix, n && a.translate(n), a._owner = this, this._style = new V(o._currentStyle, this, o), s || i && t.insert == 0 || !h.insertItems && (!i || t.insert !== !0) ? this._setProject(o) : (i && t.parent || o)._insertItem(e, this, !0), i && t !== w.NO_INSERT && this.set(t, { internal: !0, insert: !0, project: !0, parent: !0 }), i }, _serialize: function (t, e) { function n (n) { for (var a in n) { var o = s[a]; r.equals(o, a === `leading` ? 1.2 * n.fontSize : n[a]) || (i[a] = r.serialize(o, t, a !== `data`, e)) } } var i = {}; var s = this; return n(this._serializeFields), this instanceof x || n(this._style._defaults), [this._class, i] }, _changed: function (t) { var n = this._symbol; var i = this._parent || n; var r = this._project; 8 & t && (this._bounds = this._position = this._decomposed = e), 16 & t && (this._globalMatrix = e), i && 72 & t && w._clearBoundsCache(i), 2 & t && w._clearBoundsCache(this), r && r._changed(t, this), n && n._changed(t) }, getId: function () { return this._id }, getName: function () { return this._name }, setName: function (t) { if (this._name && this._removeNamed(), t === +t + ``) { throw new Error(`Names consisting only of numbers are not supported.`) } var n = this._getOwner(); if (t && n) { var i = n._children; var r = n._namedChildren; (r[t] = r[t] || []).push(this), t in i || (i[t] = this) } this._name = t || e, this._changed(256) }, getStyle: function () { return this._style }, setStyle: function (t) { this.getStyle().set(t) } }, r.each([`locked`, `visible`, `blendMode`, `opacity`, `guide`], function (t) { var e = r.capitalize(t); var n = `_` + t; var i = { locked: 256, visible: 265 }; this[`get` + e] = function () { return this[n] }, this[`set` + e] = function (e) { e != this[n] && (this[n] = e, this._changed(i[t] || 257)) } }, {}), { beans: !0, getSelection: function () { return this._selection }, setSelection: function (t) { if (t !== this._selection) { this._selection = t; var e = this._project; e && (e._updateSelection(this), this._changed(257)) } }, _changeSelection: function (t, e) { var n = this._selection; this.setSelection(e ? n | t : n & ~t) }, isSelected: function () { if (this._selectChildren) { for (var t = this._children, e = 0, n = t.length; e < n; e++) { if (t[e].isSelected()) { return !0 } } } return !!(1 & this._selection) }, setSelected: function (t) { if (this._selectChildren) { for (var e = this._children, n = 0, i = e.length; n < i; n++) { e[n].setSelected(t) } } this._changeSelection(1, t) }, isFullySelected: function () { var t = this._children; var e = !!(1 & this._selection); if (t && e) { for (var n = 0, i = t.length; n < i; n++) { if (!t[n].isFullySelected()) { return !1 } } return !0 } return e }, setFullySelected: function (t) { var e = this._children; if (e) { for (var n = 0, i = e.length; n < i; n++) { e[n].setFullySelected(t) } } this._changeSelection(1, t) }, isClipMask: function () { return this._clipMask }, setClipMask: function (t) { this._clipMask != (t = !!t) && (this._clipMask = t, t && (this.setFillColor(null), this.setStrokeColor(null)), this._changed(257), this._parent && this._parent._changed(2048)) }, getData: function () { return this._data || (this._data = {}), this._data }, setData: function (t) { this._data = t }, getPosition: function (t) { var e = t ? c : f; var n = this._position || (this._position = this._getPositionFromBounds()); return new e(n.x, n.y, this, `setPosition`) }, setPosition: function () { this.translate(c.read(arguments).subtract(this.getPosition(!0))) }, _getPositionFromBounds: function (t) { return this._pivot ? this._matrix._transformPoint(this._pivot) : (t || this.getBounds()).getCenter(!0) }, getPivot: function () { var t = this._pivot; return t ? new f(t.x, t.y, this, `setPivot`) : null }, setPivot: function () { this._pivot = c.read(arguments, 0, { clone: !0, readNull: !0 }), this._position = e } }, r.each({ getStrokeBounds: { stroke: !0 }, getHandleBounds: { handle: !0 }, getInternalBounds: { internal: !0 } }, function (t, e) { this[e] = function (e) { return this.getBounds(e, t) } }, { beans: !0, getBounds: function (t, e) { var n = e || t instanceof p; var i = r.set({}, n ? e : t, this._boundsOptions); i.stroke && !this.getStrokeScaling() || (i.cacheItem = this); var s = this._getCachedBounds(n && t, i).rect; return arguments.length ? s : new v(s.x, s.y, s.width, s.height, this, `setBounds`) }, setBounds: function () { var t = g.read(arguments); var e = this.getBounds(); var n = this._matrix; var i = new p(); var r = t.getCenter(); i.translate(r), t.width == e.width && t.height == e.height || (n.isInvertible() || (n.set(n._backup || (new p()).translate(n.getTranslation())), e = this.getBounds()), i.scale(e.width !== 0 ? t.width / e.width : 0, e.height !== 0 ? t.height / e.height : 0)), r = e.getCenter(), i.translate(-r.x, -r.y), this.transform(i) }, _getBounds: function (t, e) { var n = this._children; return n && n.length ? (w._updateBoundsCache(this, e.cacheItem), w._getBounds(n, t, e)) : new g() }, _getBoundsCacheKey: function (t, e) { return [t.stroke ? 1 : 0, t.handle ? 1 : 0, e ? 1 : 0].join(``) }, _getCachedBounds: function (t, e, n) { t = t && t._orNullIfIdentity(); var i = e.internal && !n; var r = e.cacheItem; var s = i ? null : this._matrix._orNullIfIdentity(); var a = r && (!t || t.equals(s)) && this._getBoundsCacheKey(e, i); var o = this._bounds; if (w._updateBoundsCache(this._parent || this._symbol, r), a && o && a in o) { var h = o[a]; return { rect: h.rect.clone(), nonscaling: h.nonscaling } } var u = this._getBounds(t || s, e); var l = u.rect || u; var c = this._style; var f = u.nonscaling || c.hasStroke() && !c.getStrokeScaling(); if (a) { o || (this._bounds = o = {}); var h = o[a] = { rect: l.clone(), nonscaling: f, internal: i } } return { rect: l, nonscaling: f } }, _getStrokeMatrix: function (t, e) { var n = this.getStrokeScaling() ? null : e && e.internal ? this : this._parent || this._symbol && this._symbol._item; var i = n ? n.getViewMatrix().invert() : t; return i && i._shiftless() }, statics: { _updateBoundsCache: function (t, e) { if (t && e) { var n = e._id; var i = t._boundsCache = t._boundsCache || { ids: {}, list: [] }; i.ids[n] || (i.list.push(e), i.ids[n] = e) } }, _clearBoundsCache: function (t) { var n = t._boundsCache; if (n) { t._bounds = t._position = t._boundsCache = e; for (var i = 0, r = n.list, s = r.length; i < s; i++) { var a = r[i]; a !== t && (a._bounds = a._position = e, a._boundsCache && w._clearBoundsCache(a)) } } }, _getBounds: function (t, e, n) { var i = 1 / 0; var r = -i; var s = i; var a = r; var o = !1; n = n || {}; for (var h = 0, u = t.length; h < u; h++) { var l = t[h]; if (l._visible && !l.isEmpty()) { var c = l._getCachedBounds(e && e.appended(l._matrix), n, !0); var f = c.rect; i = Math.min(f.x, i), s = Math.min(f.y, s), r = Math.max(f.x + f.width, r), a = Math.max(f.y + f.height, a), c.nonscaling && (o = !0) } } return { rect: isFinite(i) ? new g(i, s, r - i, a - s) : new g(), nonscaling: o } } } }), { beans: !0, _decompose: function () { return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose()) }, getRotation: function () { var t = this._decompose(); return t ? t.rotation : 0 }, setRotation: function (t) { var e = this.getRotation(); if (e != null && t != null) { var n = this._decomposed; this.rotate(t - e), n && (n.rotation = t, this._decomposed = n) } }, getScaling: function () { var t = this._decompose(); var e = t && t.scaling; return new f(e ? e.x : 1, e ? e.y : 1, this, `setScaling`) }, setScaling: function () { var t = this.getScaling(); var e = c.read(arguments, 0, { clone: !0, readNull: !0 }); if (t && e && !t.equals(e)) { var n = this.getRotation(); var i = this._decomposed; var r = new p(); var s = this.getPosition(!0); r.translate(s), n && r.rotate(n), r.scale(e.x / t.x, e.y / t.y), n && r.rotate(-n), r.translate(s.negate()), this.transform(r), i && (i.scaling = e, this._decomposed = i) } }, getMatrix: function () { return this._matrix }, setMatrix: function () { var t = this._matrix; t.initialize.apply(t, arguments) }, getGlobalMatrix: function (t) { var e = this._globalMatrix; if (e) { for (var n = this._parent, i = []; n;) { if (!n._globalMatrix) { e = null; for (var r = 0, s = i.length; r < s; r++) { i[r]._globalMatrix = null } break }i.push(n), n = n._parent } } if (!e) { e = this._globalMatrix = this._matrix.clone(); var n = this._parent; n && e.prepend(n.getGlobalMatrix(!0)) } return t ? e : e.clone() }, getViewMatrix: function () { return this.getGlobalMatrix().prepend(this.getView()._matrix) }, getApplyMatrix: function () { return this._applyMatrix }, setApplyMatrix: function (t) { (this._applyMatrix = this._canApplyMatrix && !!t) && this.transform(null, !0) }, getTransformContent: `#getApplyMatrix`, setTransformContent: `#setApplyMatrix` }, { getProject: function () { return this._project }, _setProject: function (t, e) { if (this._project !== t) { this._project && this._installEvents(!1), this._project = t; for (var n = this._children, i = 0, r = n && n.length; i < r; i++) { n[i]._setProject(t) }e = !0 }e && this._installEvents(!0) }, getView: function () { return this._project._view }, _installEvents: function ct (t) { ct.base.call(this, t); for (var e = this._children, n = 0, i = e && e.length; n < i; n++) { e[n]._installEvents(t) } }, getLayer: function () { for (var t = this; t = t._parent;) { if (t instanceof b) { return t } } return null }, getParent: function () { return this._parent }, setParent: function (t) { return t.addChild(this) }, _getOwner: `#getParent`, getChildren: function () { return this._children }, setChildren: function (t) { this.removeChildren(), this.addChildren(t) }, getFirstChild: function () { return this._children && this._children[0] || null }, getLastChild: function () { return this._children && this._children[this._children.length - 1] || null }, getNextSibling: function () { var t = this._getOwner(); return t && t._children[this._index + 1] || null }, getPreviousSibling: function () { var t = this._getOwner(); return t && t._children[this._index - 1] || null }, getIndex: function () { return this._index }, equals: function (t) { return t === this || t && this._class === t._class && this._style.equals(t._style) && this._matrix.equals(t._matrix) && this._locked === t._locked && this._visible === t._visible && this._blendMode === t._blendMode && this._opacity === t._opacity && this._clipMask === t._clipMask && this._guide === t._guide && this._equals(t) || !1 }, _equals: function (t) { return r.equals(this._children, t._children) }, clone: function (t) { var n = new this.constructor(w.NO_INSERT); var i = this._children; var s = r.pick(t ? t.insert : e, t === e || t === !0); var a = r.pick(t ? t.deep : e, !0); i && n.copyAttributes(this), i && !a || n.copyContent(this), i || n.copyAttributes(this), s && n.insertAbove(this); var o = this._name; var h = this._parent; if (o && h) { for (var i = h._children, u = o, l = 1; i[o];) { o = u + ` ` + l++ }o !== u && n.setName(o) } return n }, copyContent: function (t) { for (var e = t._children, n = 0, i = e && e.length; n < i; n++) { this.addChild(e[n].clone(!1), !0) } }, copyAttributes: function (t, e) { this.setStyle(t._style); for (var n = [`_locked`, `_visible`, `_blendMode`, `_opacity`, `_clipMask`, `_guide`], i = 0, s = n.length; i < s; i++) { var a = n[i]; t.hasOwnProperty(a) && (this[a] = t[a]) }e || this._matrix.set(t._matrix, !0), this.setApplyMatrix(t._applyMatrix), this.setPivot(t._pivot), this.setSelection(t._selection); var o = t._data; var h = t._name; this._data = o ? r.clone(o) : null, h && this.setName(h) }, rasterize: function (t, n) { var i = this.getStrokeBounds(); var s = (t || this.getView().getResolution()) / 72; var a = i.getTopLeft().floor(); var o = i.getBottomRight().ceil(); var h = new d(o.subtract(a)); var u = new S(w.NO_INSERT); if (!h.isZero()) { var l = tt.getCanvas(h.multiply(s)); var c = l.getContext(`2d`); var f = (new p()).scale(s).translate(a.negate()); c.save(), f.applyToContext(c), this.draw(c, new r({ matrices: [f] })), c.restore(), u.setCanvas(l) } return u.transform((new p()).translate(a.add(h.divide(2))).scale(1 / s)), (n === e || n) && u.insertAbove(this), u }, contains: function () { return !!this._contains(this._matrix._inverseTransform(c.read(arguments))) }, _contains: function (t) { var e = this._children; if (e) { for (var n = e.length - 1; n >= 0; n--) { if (e[n].contains(t)) { return !0 } } return !1 } return t.isInside(this.getInternalBounds()) }, isInside: function () { return g.read(arguments).contains(this.getBounds()) }, _asPathItem: function () { return new L.Rectangle({ rectangle: this.getInternalBounds(), matrix: this._matrix, insert: !1 }) }, intersects: function (t, e) { return t instanceof w && this._asPathItem().getIntersections(t._asPathItem(), null, e, !0).length > 0 } }, new function () { function t () { return this._hitTest(c.read(arguments), P.getOptions(arguments)) } function e () { var t = c.read(arguments); var e = P.getOptions(arguments); var n = []; return this._hitTest(t, r.set({ all: n }, e)), n } function n (t, e, n, i) { var r = this._children; if (r) { for (var s = r.length - 1; s >= 0; s--) { var a = r[s]; var o = a !== i && a._hitTest(t, e, n); if (o && !e.all) { return o } } } return null } return y.inject({ hitTest: t, hitTestAll: e, _hitTest: n }), { hitTest: t, hitTestAll: e, _hitTestChildren: n } }(), { _hitTest: function (t, e, n) { function i (t) { return t && _ && !_(t) && (t = null), t && e.all && e.all.push(t), t } function s (e, n) { var i = n ? l[`get` + n]() : g.getPosition(); if (t.subtract(i).divide(u).length <= 1) { return new P(e, g, { name: n ? r.hyphenate(n) : e, point: i }) } } if (this._locked || !this._visible || this._guide && !e.guides || this.isEmpty()) { return null } var a = this._matrix; var o = n ? n.appended(a) : this.getGlobalMatrix().prepend(this.getView()._matrix); var h = Math.max(e.tolerance, 1e-12); var u = e._tolerancePadding = new d(L._getStrokePadding(h, a._shiftless().invert())); if (t = a._inverseTransform(t), !t || !this._children && !this.getBounds({ internal: !0, stroke: !0, handle: !0 }).expand(u.multiply(2))._containsPoint(t)) { return null } var l; var c; var f = !(e.guides && !this._guide || e.selected && !this.isSelected() || e.type && e.type !== r.hyphenate(this._class) || e[`class`] && !(this instanceof e[`class`])); var _ = e.match; var g = this; var v = e.position; var p = e.center; var m = e.bounds; if (f && this._parent && (v || p || m)) { if ((p || m) && (l = this.getInternalBounds()), c = v && s(`position`) || p && s(`center`, `Center`), !c && m) { for (var y = [`TopLeft`, `TopRight`, `BottomLeft`, `BottomRight`, `LeftCenter`, `TopCenter`, `RightCenter`, `BottomCenter`], w = 0; w < 8 && !c; w++) { c = s(`bounds`, y[w]) } }c = i(c) } return c || (c = this._hitTestChildren(t, e, o) || f && i(this._hitTestSelf(t, e, o, this.getStrokeScaling() ? null : o._shiftless().invert())) || null), c && c.point && (c.point = a.transform(c.point)), c }, _hitTestSelf: function (t, e) { if (e.fill && this.hasFill() && this._contains(t)) { return new P(`fill`, this) } }, matches: function (t, e) { function n (t, e) { for (var i in t) { if (t.hasOwnProperty(i)) { var s = t[i]; var a = e[i]; if (r.isPlainObject(s) && r.isPlainObject(a)) { if (!n(s, a)) { return !1 } } else if (!r.equals(s, a)) { return !1 } } } return !0 } var i = typeof t; if (i === `object`) { for (var s in t) { if (t.hasOwnProperty(s) && !this.matches(s, t[s])) { return !1 } } return !0 } if (i === `function`) { return t(this) } if (t === `match`) { return e(this) } var a = /^(empty|editable)$/.test(t) ? this[`is` + r.capitalize(t)]() : t === `type` ? r.hyphenate(this._class) : this[t]; if (t === `class`) { if (typeof e === `function`) { return this instanceof e }a = this._class } if (typeof e === `function`) { return !!e(a) } if (e) { if (e.test) { return e.test(a) } if (r.isPlainObject(e)) { return n(e, a) } } return r.equals(a, e) }, getItems: function (t) { return w._getItems(this, t, this._matrix) }, getItem: function (t) { return w._getItems(this, t, this._matrix, null, !0)[0] || null }, statics: { _getItems: function ft (t, e, n, i, s) { if (!i) { var a = typeof e === `object` && e; var o = a && a.overlapping; var h = a && a.inside; var u = o || h; var l = u && g.read([u]); i = { items: [], recursive: a && a.recursive !== !1, inside: !!h, overlapping: !!o, rect: l, path: o && new L.Rectangle({ rectangle: l, insert: !1 }) }, a && (e = r.filter({}, e, { recursive: !0, inside: !0, overlapping: !0 })) } var c = t._children; var f = i.items; var l = i.rect; n = l && (n || new p()); for (var d = 0, _ = c && c.length; d < _; d++) { var v = c[d]; var m = n && n.appended(v._matrix); var y = !0; if (l) { var u = v.getBounds(m); if (!l.intersects(u)) { continue }l.contains(u) || i.overlapping && (u.contains(l) || i.path.intersects(v, m)) || (y = !1) } if (y && v.matches(e) && (f.push(v), s)) { break } if (i.recursive !== !1 && ft(v, e, m, i, s), s && f.length > 0) { break } } return f } } }, { importJSON: function (t) { var e = r.importJSON(t, this); return e !== this ? this.addChild(e) : e }, addChild: function (t) { return this.insertChild(e, t) }, insertChild: function (t, e) { var n = e ? this.insertChildren(t, [e]) : null; return n && n[0] }, addChildren: function (t) { return this.insertChildren(this._children.length, t) }, insertChildren: function (t, e) { var n = this._children; if (n && e && e.length > 0) { e = r.slice(e); for (var i = {}, s = e.length - 1; s >= 0; s--) { var a = e[s]; var o = a && a._id; !a || i[o] ? e.splice(s, 1) : (a._remove(!1, !0), i[o] = !0) }r.splice(n, e, t, 0); for (var h = this._project, u = h._changes, s = 0, l = e.length; s < l; s++) { var a = e[s]; var c = a._name; a._parent = this, a._setProject(h, !0), c && a.setName(c), u && a._changed(5) } this._changed(11) } else { e = null } return e }, _insertItem: `#insertChild`, _insertAt: function (t, e) { var n = t && t._getOwner(); var i = t !== this && n ? this : null; return i && (i._remove(!1, !0), n._insertItem(t._index + e, i)), i }, insertAbove: function (t) { return this._insertAt(t, 1) }, insertBelow: function (t) { return this._insertAt(t, 0) }, sendToBack: function () { var t = this._getOwner(); return t ? t._insertItem(0, this) : null }, bringToFront: function () { var t = this._getOwner(); return t ? t._insertItem(e, this) : null }, appendTop: `#addChild`, appendBottom: function (t) { return this.insertChild(0, t) }, moveAbove: `#insertAbove`, moveBelow: `#insertBelow`, addTo: function (t) { return t._insertItem(e, this) }, copyTo: function (t) { return this.clone(!1).addTo(t) }, reduce: function (t) { var e = this._children; if (e && e.length === 1) { var n = e[0].reduce(t); return this._parent ? (n.insertAbove(this), this.remove()) : n.remove(), n } return this }, _removeNamed: function () { var t = this._getOwner(); if (t) { var e = t._children; var n = t._namedChildren; var i = this._name; var r = n[i]; var s = r ? r.indexOf(this) : -1; s !== -1 && (e[i] == this && delete e[i], r.splice(s, 1), r.length ? e[i] = r[0] : delete n[i]) } }, _remove: function (t, e) { var n = this._getOwner(); var i = this._project; var s = this._index; return this._style && this._style._dispose(), !!n && (this._name && this._removeNamed(), s != null && (i._activeLayer === this && (i._activeLayer = this.getNextSibling() || this.getPreviousSibling()), r.splice(n._children, null, s, 1)), this._installEvents(!1), t && i._changes && this._changed(5), e && n._changed(11, this), this._parent = null, !0) }, remove: function () { return this._remove(!0, !0) }, replaceWith: function (t) { var e = t && t.insertBelow(this); return e && this.remove(), e }, removeChildren: function (t, e) { if (!this._children) { return null }t = t || 0, e = r.pick(e, this._children.length); for (var n = r.splice(this._children, null, t, e - t), i = n.length - 1; i >= 0; i--) { n[i]._remove(!0, !1) } return n.length > 0 && this._changed(11), n }, clear: `#removeChildren`, reverseChildren: function () { if (this._children) { this._children.reverse(); for (var t = 0, e = this._children.length; t < e; t++) { this._children[t]._index = t } this._changed(11) } }, isEmpty: function () { var t = this._children; return !t || !t.length }, isEditable: function () { for (var t = this; t;) { if (!t._visible || t._locked) { return !1 }t = t._parent } return !0 }, hasFill: function () { return this.getStyle().hasFill() }, hasStroke: function () { return this.getStyle().hasStroke() }, hasShadow: function () { return this.getStyle().hasShadow() }, _getOrder: function (t) { function e (t) { var e = []; do { e.unshift(t) } while (t = t._parent);return e } for (var n = e(this), i = e(t), r = 0, s = Math.min(n.length, i.length); r < s; r++) { if (n[r] != i[r]) { return n[r]._index < i[r]._index ? 1 : -1 } } return 0 }, hasChildren: function () { return this._children && this._children.length > 0 }, isInserted: function () { return !!this._parent && this._parent.isInserted() }, isAbove: function (t) { return this._getOrder(t) === -1 }, isBelow: function (t) { return this._getOrder(t) === 1 }, isParent: function (t) { return this._parent === t }, isChild: function (t) { return t && t._parent === this }, isDescendant: function (t) { for (var e = this; e = e._parent;) { if (e === t) { return !0 } } return !1 }, isAncestor: function (t) { return !!t && t.isDescendant(this) }, isSibling: function (t) { return this._parent === t._parent }, isGroupedWith: function (t) { for (var e = this._parent; e;) { if (e._parent && /^(Group|Layer|CompoundPath)$/.test(e._class) && t.isDescendant(e)) { return !0 }e = e._parent } return !1 } }, r.each([`rotate`, `scale`, `shear`, `skew`], function (t) { var e = t === `rotate`; this[t] = function () { var n = (e ? r : c).read(arguments); var i = c.read(arguments, 0, { readNull: !0 }); return this.transform((new p())[t](n, i || this.getPosition(!0))) } }, { translate: function () { var t = new p(); return this.transform(t.translate.apply(t, arguments)) }, transform: function (t, e, n, i) { var r = this._matrix; var s = t && !t.isIdentity(); var a = (e || this._applyMatrix) && (!r.isIdentity() || s || e && n && this._children); if (!s && !a) { return this } if (s) { !t.isInvertible() && r.isInvertible() && (r._backup = r.getValues()), r.prepend(t, !0); var o = this._style; var h = o.getFillColor(!0); var u = o.getStrokeColor(!0); h && h.transform(t), u && u.transform(t) } if (a && (a = this._transformContent(r, n, i))) { var l = this._pivot; l && r._transformPoint(l, l, !0), r.reset(!0), i && this._canApplyMatrix && (this._applyMatrix = !0) } var c = this._bounds; var f = this._position; (s || a) && this._changed(25); var d = s && c && t.decompose(); if (d && d.skewing.isZero() && d.rotation % 90 === 0) { for (var _ in c) { var g = c[_]; if (g.nonscaling) { delete c[_] } else if (a || !g.internal) { var v = g.rect; t._transformBounds(v, v) } } this._bounds = c; var p = c[this._getBoundsCacheKey(this._boundsOptions || {})]; p && (this._position = this._getPositionFromBounds(p.rect)) } else { s && f && this._pivot && (this._position = t._transformPoint(f, f)) } return this }, _transformContent: function (t, e, n) { var i = this._children; if (i) { for (var r = 0, s = i.length; r < s; r++) { i[r].transform(t, !0, e, n) } return !0 } }, globalToLocal: function () { return this.getGlobalMatrix(!0)._inverseTransform(c.read(arguments)) }, localToGlobal: function () { return this.getGlobalMatrix(!0)._transformPoint(c.read(arguments)) }, parentToLocal: function () { return this._matrix._inverseTransform(c.read(arguments)) }, localToParent: function () { return this._matrix._transformPoint(c.read(arguments)) }, fitBounds: function (t, e) { t = g.read(arguments); var n = this.getBounds(); var i = n.height / n.width; var r = t.height / t.width; var s = (e ? i > r : i < r) ? t.width / n.width : t.height / n.height; var a = new g(new c(), new d(n.width * s, n.height * s)); a.setCenter(t.getCenter()), this.setBounds(a) } }), { _setStyles: function (t, e, n) { var i = this._style; var r = this._matrix; if (i.hasFill() && (t.fillStyle = i.getFillColor().toCanvasStyle(t, r)), i.hasStroke()) { t.strokeStyle = i.getStrokeColor().toCanvasStyle(t, r), t.lineWidth = i.getStrokeWidth(); var s = i.getStrokeJoin(); var a = i.getStrokeCap(); var o = i.getMiterLimit(); if (s && (t.lineJoin = s), a && (t.lineCap = a), o && (t.miterLimit = o), rt.support.nativeDash) { var h = i.getDashArray(); var u = i.getDashOffset(); h && h.length && (`setLineDash` in t ? (t.setLineDash(h), t.lineDashOffset = u) : (t.mozDash = h, t.mozDashOffset = u)) } } if (i.hasShadow()) { var l = e.pixelRatio || 1; var f = n._shiftless().prepend((new p()).scale(l, l)); var d = f.transform(new c(i.getShadowBlur(), 0)); var _ = f.transform(this.getShadowOffset()); t.shadowColor = i.getShadowColor().toCanvasStyle(t), t.shadowBlur = d.getLength(), t.shadowOffsetX = _.x, t.shadowOffsetY = _.y } },
    draw: function (t, e, n) {
      this._updateVersion = this._project._updateVersion; if (this._visible && this._opacity !== 0) {
        var i = e.matrices; var r = e.viewMatrix; var s = this._matrix; var a = i[i.length - 1].appended(s); if (a.isInvertible()) {
          r = r ? r.appended(a) : a, i.push(a), e.updateMatrix && (this._globalMatrix = a); var o; var h; var u; var l = this._blendMode; var c = this._opacity; var f = l === `normal`; var d = et.nativeModes[l]; var _ = f && c === 1 || e.dontStart || e.clip || (d || f && c < 1) && this._canComposite(); var g = e.pixelRatio || 1; if (!_) { var v = this.getStrokeBounds(r); if (!v.width || !v.height) { return void i.pop() }u = e.offset, h = e.offset = v.getTopLeft().floor(), o = t, t = tt.getContext(v.getSize().ceil().add(1).multiply(g)), g !== 1 && t.scale(g, g) }t.save(); var p = n ? n.appended(s) : this._canScaleStroke && !this.getStrokeScaling(!0) && r; var m = !_ && e.clipItem; var y = !p || m
          if (_ ? (t.globalAlpha = c, d && (t.globalCompositeOperation = l)) : y && t.translate(-h.x, -h.y), y && (_ ? s : r).applyToContext(t), m && e.clipItem.draw(t, e.extend({ clip: !0 })), p) { t.setTransform(g, 0, 0, g, 0, 0); var w = e.offset; w && t.translate(-w.x, -w.y) } this._draw(t, e, r, p), t.restore(), i.pop(), e.clip && !e.dontFinish && t.clip(), _ || (et.process(l, t, o, c, h.subtract(u).multiply(g)), tt.release(t), e.offset = u)
        }
      }
    },
    _isUpdated: function (t) { var e = this._parent; if (e instanceof E) { return e._isUpdated(t) } var n = this._updateVersion === t; return !n && e && e._visible && e._isUpdated(t) && (this._updateVersion = t, n = !0), n },
    _drawSelection: function (t, e, n, i, r) { var s = this._selection; var a = 1 & s; var o = 2 & s || a && this._selectBounds; var h = 4 & s; if (this._drawSelected || (a = !1), (a || o || h) && this._isUpdated(r)) { var u; var l = this.getSelectedColor(!0) || (u = this.getLayer()) && u.getSelectedColor(!0); var c = e.appended(this.getGlobalMatrix(!0)); var f = n / 2; if (t.strokeStyle = t.fillStyle = l ? l.toCanvasStyle(t) : `#009dec`, a && this._drawSelected(t, c, i), h) { var d = this.getPosition(!0); var _ = this._parent; var g = _ ? _.localToGlobal(d) : d; var v = g.x; var p = g.y; t.beginPath(), t.arc(v, p, f, 0, 2 * Math.PI, !0), t.stroke(); for (var m = [[0, -1], [1, 0], [0, 1], [-1, 0]], y = f, w = n + 1, x = 0; x < 4; x++) { var b = m[x]; var C = b[0]; var S = b[1]; t.moveTo(v + C * y, p + S * y), t.lineTo(v + C * w, p + S * w), t.stroke() } } if (o) { var k = c._transformCorners(this.getInternalBounds()); t.beginPath(); for (var x = 0; x < 8; x++) { t[x ? `lineTo` : `moveTo`](k[x], k[++x]) }t.closePath(), t.stroke(); for (var x = 0; x < 8; x++) { t.fillRect(k[x] - f, k[++x] - f, n, n) } } } },
    _canComposite: function () { return !1 } }, r.each([`down`, `drag`, `up`, `move`], function (t) { this[`removeOn` + r.capitalize(t)] = function () { var e = {}; return e[t] = !0, this.removeOn(e) } }, { removeOn: function (t) { for (var e in t) { if (t[e]) { var n = `mouse` + e; var i = this._project; var r = i._removeSets = i._removeSets || {}; r[n] = r[n] || {}, r[n][this._id] = this } } return this } })); var x = w.extend({ _class: `Group`, _selectBounds: !1, _selectChildren: !0, _serializeFields: { children: [] }, initialize: function (t) { this._children = [], this._namedChildren = {}, this._initialize(t) || this.addChildren(Array.isArray(t) ? t : arguments) }, _changed: function dt (t) { dt.base.call(this, t), 2050 & t && (this._clipItem = e) }, _getClipItem: function () { var t = this._clipItem; if (t === e) { t = null; for (var n = this._children, i = 0, r = n.length; i < r; i++) { if (n[i]._clipMask) { t = n[i]; break } } this._clipItem = t } return t }, isClipped: function () { return !!this._getClipItem() }, setClipped: function (t) { var e = this.getFirstChild(); e && e.setClipMask(t) }, _getBounds: function _t (t, e) { var n = this._getClipItem(); return n ? n._getCachedBounds(t && t.appended(n._matrix), r.set({}, e, { stroke: !1 })) : _t.base.call(this, t, e) }, _hitTestChildren: function gt (t, e, n) { var i = this._getClipItem(); return (!i || i.contains(t)) && gt.base.call(this, t, e, n, i) }, _draw: function (t, e) { var n = e.clip; var i = !n && this._getClipItem(); e = e.extend({ clipItem: i, clip: !1 }), n ? (t.beginPath(), e.dontStart = e.dontFinish = !0) : i && i.draw(t, e.extend({ clip: !0 })); for (var r = this._children, s = 0, a = r.length; s < a; s++) { var o = r[s]; o !== i && o.draw(t, e) } } }); var b = x.extend({ _class: `Layer`, initialize: function () { x.apply(this, arguments) }, _getOwner: function () { return this._parent || this._index != null && this._project }, isInserted: function vt () { return this._parent ? vt.base.call(this) : this._index != null }, activate: function () { this._project._activeLayer = this }, _hitTestSelf: function () {} }); var C = w.extend({ _class: `Shape`, _applyMatrix: !1, _canApplyMatrix: !1, _canScaleStroke: !0, _serializeFields: { type: null, size: null, radius: null }, initialize: function (t, e) { this._initialize(t, e) }, _equals: function (t) { return this._type === t._type && this._size.equals(t._size) && r.equals(this._radius, t._radius) }, copyContent: function (t) { this.setType(t._type), this.setSize(t._size), this.setRadius(t._radius) }, getType: function () { return this._type }, setType: function (t) { this._type = t }, getShape: `#getType`, setShape: `#setType`, getSize: function () { var t = this._size; return new _(t.width, t.height, this, `setSize`) }, setSize: function () { var t = d.read(arguments); if (this._size) { if (!this._size.equals(t)) { var e = this._type; var n = t.width; var i = t.height; e === `rectangle` ? this._radius.set(d.min(this._radius, t.divide(2))) : e === `circle` ? (n = i = (n + i) / 2, this._radius = n / 2) : e === `ellipse` && this._radius._set(n / 2, i / 2), this._size._set(n, i), this._changed(9) } } else { this._size = t.clone() } }, getRadius: function () { var t = this._radius; return this._type === `circle` ? t : new _(t.width, t.height, this, `setRadius`) }, setRadius: function (t) { var e = this._type; if (e === `circle`) { if (t === this._radius) { return } var n = 2 * t; this._radius = t, this._size._set(n, n) } else if (t = d.read(arguments), this._radius) { if (this._radius.equals(t)) { return } if (this._radius.set(t), e === `rectangle`) { var n = d.max(this._size, t.multiply(2)); this._size.set(n) } else { e === `ellipse` && this._size._set(2 * t.width, 2 * t.height) } } else { this._radius = t.clone() } this._changed(9) }, isEmpty: function () { return !1 }, toPath: function (t) { var n = new (L[r.capitalize(this._type)])({ center: new c(), size: this._size, radius: this._radius, insert: !1 }); return n.copyAttributes(this), rt.settings.applyMatrix && n.setApplyMatrix(!0), (t === e || t) && n.insertAbove(this), n }, toShape: `#clone`, _asPathItem: function () { return this.toPath(!1) }, _draw: function (t, e, n, i) { var r = this._style; var s = r.hasFill(); var a = r.hasStroke(); var o = e.dontFinish || e.clip; var h = !i; if (s || a || o) { var u = this._type; var l = this._radius; var c = u === `circle`; if (e.dontStart || t.beginPath(), h && c) { t.arc(0, 0, l, 0, 2 * Math.PI, !0) } else { var f = c ? l : l.width; var d = c ? l : l.height; var _ = this._size; var g = _.width; var v = _.height; if (h && u === `rectangle` && f === 0 && d === 0) { t.rect(-g / 2, -v / 2, g, v) } else { var p = g / 2; var m = v / 2; var y = 0.44771525016920644; var w = f * y; var x = d * y; var b = [-p, -m + d, -p, -m + x, -p + w, -m, -p + f, -m, p - f, -m, p - w, -m, p, -m + x, p, -m + d, p, m - d, p, m - x, p - w, m, p - f, m, -p + f, m, -p + w, m, -p, m - x, -p, m - d]; i && i.transform(b, b, 32), t.moveTo(b[0], b[1]), t.bezierCurveTo(b[2], b[3], b[4], b[5], b[6], b[7]), p !== f && t.lineTo(b[8], b[9]), t.bezierCurveTo(b[10], b[11], b[12], b[13], b[14], b[15]), m !== d && t.lineTo(b[16], b[17]), t.bezierCurveTo(b[18], b[19], b[20], b[21], b[22], b[23]), p !== f && t.lineTo(b[24], b[25]), t.bezierCurveTo(b[26], b[27], b[28], b[29], b[30], b[31]) } }t.closePath() }o || !s && !a || (this._setStyles(t, e, n), s && (t.fill(r.getFillRule()), t.shadowColor = `rgba(0,0,0,0)`), a && t.stroke()) }, _canComposite: function () { return !(this.hasFill() && this.hasStroke()) }, _getBounds: function (t, e) { var n = new g(this._size).setCenter(0, 0); var i = this._style; var r = e.stroke && i.hasStroke() && i.getStrokeWidth(); return t && (n = t._transformBounds(n)), r ? n.expand(L._getStrokePadding(r, this._getStrokeMatrix(t, e))) : n } }, new function () { function t (t, e, n) { var i = t._radius; if (!i.isZero()) { for (var r = t._size.divide(2), s = 1; s <= 4; s++) { var a = new c(s > 1 && s < 4 ? -1 : 1, s > 2 ? -1 : 1); var o = a.multiply(r); var h = o.subtract(a.multiply(i)); var u = new g(n ? o.add(a.multiply(n)) : o, h); if (u.contains(e)) { return { point: h, quadrant: s } } } } } function e (t, e, n, i) { var r = t.divide(e); return (!i || r.isInQuadrant(i)) && r.subtract(r.normalize()).multiply(e).divide(n).length <= 1 } return { _contains: function n (e) { if (this._type === `rectangle`) { var i = t(this, e); return i ? e.subtract(i.point).divide(this._radius).getLength() <= 1 : n.base.call(this, e) } return e.divide(this.size).getLength() <= 0.5 }, _hitTestSelf: function i (n, r, s, a) { var o = !1; var h = this._style; var u = r.stroke && h.hasStroke(); var l = r.fill && h.hasFill(); if (u || l) { var c = this._type; var f = this._radius; var d = u ? h.getStrokeWidth() / 2 : 0; var _ = r._tolerancePadding.add(L._getStrokePadding(d, !h.getStrokeScaling() && a)); if (c === `rectangle`) { var v = _.multiply(2); var p = t(this, n, v); if (p) { o = e(n.subtract(p.point), f, _, p.quadrant) } else { var m = new g(this._size).setCenter(0, 0); var y = m.expand(v); var w = m.expand(v.negate()); o = y._containsPoint(n) && !w._containsPoint(n) } } else { o = e(n, f, _) } } return o ? new P(u ? `stroke` : `fill`, this) : i.base.apply(this, arguments) } } }(), { statics: new function () { function t (t, e, n, i, s) { var a = new C(r.getNamed(s), e); return a._type = t, a._size = n, a._radius = i, a } return { Circle: function () { var e = c.readNamed(arguments, `center`); var n = r.readNamed(arguments, `radius`); return t(`circle`, e, new d(2 * n), n, arguments) }, Rectangle: function () { var e = g.readNamed(arguments, `rectangle`); var n = d.min(d.readNamed(arguments, `radius`), e.getSize(!0).divide(2)); return t(`rectangle`, e.getCenter(!0), e.getSize(!0), n, arguments) }, Ellipse: function () { var e = C._readEllipse(arguments); var n = e.radius; return t(`ellipse`, e.center, n.multiply(2), n, arguments) }, _readEllipse: function (t) { var e; var n; if (r.hasNamed(t, `radius`)) { e = c.readNamed(t, `center`), n = d.readNamed(t, `radius`) } else { var i = g.readNamed(t, `rectangle`); e = i.getCenter(!0), n = i.getSize(!0).divide(2) } return { center: e, radius: n } } } }() }); var S = w.extend({ _class: `Raster`, _applyMatrix: !1, _canApplyMatrix: !1, _boundsOptions: { stroke: !1, handle: !1 }, _serializeFields: { crossOrigin: null, source: null }, _prioritize: [`crossOrigin`], _smoothing: !0, initialize: function (t, n) { if (!this._initialize(t, n !== e && c.read(arguments, 1))) { var r = typeof t === `string` ? i.getElementById(t) : t; r ? this.setImage(r) : this.setSource(t) } this._size || (this._size = new d(), this._loaded = !1) }, _equals: function (t) { return this.getSource() === t.getSource() }, copyContent: function (t) { var e = t._image; var n = t._canvas; if (e) { this._setImage(e) } else if (n) { var i = tt.getCanvas(t._size); i.getContext(`2d`).drawImage(n, 0, 0), this._setImage(i) } this._crossOrigin = t._crossOrigin }, getSize: function () { var t = this._size; return new _(t ? t.width : 0, t ? t.height : 0, this, `setSize`) }, setSize: function () { var t = d.read(arguments); if (!t.equals(this._size)) { if (t.width > 0 && t.height > 0) { var e = this.getElement(); this._setImage(tt.getCanvas(t)), e && this.getContext(!0).drawImage(e, 0, 0, t.width, t.height) } else { this._canvas && tt.release(this._canvas), this._size = t.clone() } } }, getWidth: function () { return this._size ? this._size.width : 0 }, setWidth: function (t) { this.setSize(t, this.getHeight()) }, getHeight: function () { return this._size ? this._size.height : 0 }, setHeight: function (t) { this.setSize(this.getWidth(), t) }, getLoaded: function () { return this._loaded }, isEmpty: function () { var t = this._size; return !t || t.width === 0 && t.height === 0 }, getResolution: function () { var t = this._matrix; var e = new c(0, 0).transform(t); var n = new c(1, 0).transform(t).subtract(e); var i = new c(0, 1).transform(t).subtract(e); return new d(72 / n.getLength(), 72 / i.getLength()) }, getPpi: `#getResolution`, getImage: function () { return this._image }, setImage: function (t) { function e (t) { var e = n.getView(); var i = t && t.type || `load`; e && n.responds(i) && (rt = e._scope, n.emit(i, new $(t))) } var n = this; this._setImage(t), this._loaded ? setTimeout(e, 0) : t && H.add(t, { load: function (i) { n._setImage(t), e(i) }, error: e }) }, _setImage: function (t) { this._canvas && tt.release(this._canvas), t && t.getContext ? (this._image = null, this._canvas = t, this._loaded = !0) : (this._image = t, this._canvas = null, this._loaded = !!(t && t.src && t.complete)), this._size = new d(t ? t.naturalWidth || t.width : 0, t ? t.naturalHeight || t.height : 0), this._context = null, this._changed(1033) }, getCanvas: function () { if (!this._canvas) { var t = tt.getContext(this._size); try { this._image && t.drawImage(this._image, 0, 0), this._canvas = t.canvas } catch (e) { tt.release(t) } } return this._canvas }, setCanvas: `#setImage`, getContext: function (t) { return this._context || (this._context = this.getCanvas().getContext(`2d`)), t && (this._image = null, this._changed(1025)), this._context }, setContext: function (t) { this._context = t }, getSource: function () { var t = this._image; return t && t.src || this.toDataURL() }, setSource: function (e) { var n = new t.Image(); var i = this._crossOrigin; i && (n.crossOrigin = i), n.src = e, this.setImage(n) }, getCrossOrigin: function () { var t = this._image; return t && t.crossOrigin || this._crossOrigin || `` }, setCrossOrigin: function (t) { this._crossOrigin = t; var e = this._image; e && (e.crossOrigin = t) }, getSmoothing: function () { return this._smoothing }, setSmoothing: function (t) { this._smoothing = t, this._changed(257) }, getElement: function () { return this._canvas || this._loaded && this._image } }, { beans: !1, getSubCanvas: function () { var t = g.read(arguments); var e = tt.getContext(t.getSize()); return e.drawImage(this.getCanvas(), t.x, t.y, t.width, t.height, 0, 0, t.width, t.height), e.canvas }, getSubRaster: function () { var t = g.read(arguments); var e = new S(w.NO_INSERT); return e._setImage(this.getSubCanvas(t)), e.translate(t.getCenter().subtract(this.getSize().divide(2))), e._matrix.prepend(this._matrix), e.insertAbove(this), e }, toDataURL: function () { var t = this._image; var e = t && t.src; if (/^data:/.test(e)) { return e } var n = this.getCanvas(); return n ? n.toDataURL.apply(n, arguments) : null }, drawImage: function (t) { var e = c.read(arguments, 1); this.getContext(!0).drawImage(t, e.x, e.y) }, getAverageColor: function (t) { var e; var n; if (t ? t instanceof O ? (n = t, e = t.getBounds()) : typeof t === `object` && (`width` in t ? e = new g(t) : `x` in t && (e = new g(t.x - 0.5, t.y - 0.5, 1, 1))) : e = this.getBounds(), !e) { return null } var i = 32; var s = Math.min(e.width, i); var a = Math.min(e.height, i); var o = S._sampleContext; o ? o.clearRect(0, 0, i + 1, i + 1) : o = S._sampleContext = tt.getContext(new d(i)), o.save(); var h = (new p()).scale(s / e.width, a / e.height).translate(-e.x, -e.y); h.applyToContext(o), n && n.draw(o, new r({ clip: !0, matrices: [h] })), this._matrix.applyToContext(o); var u = this.getElement(); var l = this._size; u && o.drawImage(u, -l.width / 2, -l.height / 2), o.restore(); for (var c = o.getImageData(0.5, 0.5, Math.ceil(s), Math.ceil(a)).data, f = [0, 0, 0], _ = 0, v = 0, m = c.length; v < m; v += 4) { var y = c[v + 3]; _ += y, y /= 255, f[0] += c[v] * y, f[1] += c[v + 1] * y, f[2] += c[v + 2] * y } for (var v = 0; v < 3; v++) { f[v] /= _ } return _ ? D.read(f) : null }, getPixel: function () { var t = c.read(arguments); var e = this.getContext().getImageData(t.x, t.y, 1, 1).data; return new D(`rgb`, [e[0] / 255, e[1] / 255, e[2] / 255], e[3] / 255) }, setPixel: function () { var t = c.read(arguments); var e = D.read(arguments); var n = e._convert(`rgb`); var i = e._alpha; var r = this.getContext(!0); var s = r.createImageData(1, 1); var a = s.data; a[0] = 255 * n[0], a[1] = 255 * n[1], a[2] = 255 * n[2], a[3] = i != null ? 255 * i : 255, r.putImageData(s, t.x, t.y) }, createImageData: function () { var t = d.read(arguments); return this.getContext().createImageData(t.width, t.height) }, getImageData: function () { var t = g.read(arguments); return t.isEmpty() && (t = new g(this._size)), this.getContext().getImageData(t.x, t.y, t.width, t.height) }, setImageData: function (t) { var e = c.read(arguments, 1); this.getContext(!0).putImageData(t, e.x, e.y) }, _getBounds: function (t, e) { var n = new g(this._size).setCenter(0, 0); return t ? t._transformBounds(n) : n }, _hitTestSelf: function (t) { if (this._contains(t)) { var e = this; return new P(`pixel`, e, { offset: t.add(e._size.divide(2)).round(), color: { get: function () { return e.getPixel(this.offset) } } }) } }, _draw: function (t, e, n) { var i = this.getElement(); i && (t.globalAlpha = this._opacity, this._setStyles(t, e, n), U.setPrefixed(t, `imageSmoothingEnabled`, this._smoothing), t.drawImage(i, -this._size.width / 2, -this._size.height / 2)) }, _canComposite: function () { return !0 } }); var k = w.extend({ _class: `SymbolItem`, _applyMatrix: !1, _canApplyMatrix: !1, _boundsOptions: { stroke: !0 }, _serializeFields: { symbol: null }, initialize: function (t, n) { this._initialize(t, n !== e && c.read(arguments, 1)) || this.setDefinition(t instanceof I ? t : new I(t)) }, _equals: function (t) { return this._definition === t._definition }, copyContent: function (t) { this.setDefinition(t._definition) }, getDefinition: function () { return this._definition }, setDefinition: function (t) { this._definition = t, this._changed(9) }, getSymbol: `#getDefinition`, setSymbol: `#setDefinition`, isEmpty: function () { return this._definition._item.isEmpty() }, _getBounds: function (t, e) { var n = this._definition._item; return n._getCachedBounds(n._matrix.prepended(t), e) }, _hitTestSelf: function (t, e, n) { var i = this._definition._item._hitTest(t, e, n); return i && (i.item = this), i }, _draw: function (t, e) { this._definition._item.draw(t, e) } }); var I = r.extend({ _class: `SymbolDefinition`, initialize: function (t, e) { this._id = l.get(), this.project = rt.project, t && this.setItem(t, e) }, _serialize: function (t, e) { return e.add(this, function () { return r.serialize([this._class, this._item], t, !1, e) }) }, _changed: function (t) { 8 & t && w._clearBoundsCache(this), 1 & t && this.project._changed(t) }, getItem: function () { return this._item }, setItem: function (t, e) { t._symbol && (t = t.clone()), this._item && (this._item._symbol = null), this._item = t, t.remove(), t.setSelected(!1), e || t.setPosition(new c()), t._symbol = this, this._changed(9) }, getDefinition: `#getItem`, setDefinition: `#setItem`, place: function (t) { return new k(this, t) }, clone: function () { return new I(this._item.clone(!1)) }, equals: function (t) { return t === this || t && this._item.equals(t._item) || !1 } }); var P = r.extend({ _class: `HitResult`, initialize: function (t, e, n) { this.type = t, this.item = e, n && this.inject(n) }, statics: { getOptions: function (t) { var e = t && r.read(t); return r.set({ type: null, tolerance: rt.settings.hitTolerance, fill: !e, stroke: !e, segments: !e, handles: !1, ends: !1, position: !1, center: !1, bounds: !1, guides: !1, selected: !1 }, e) } } }); var M = r.extend({ _class: `Segment`, beans: !0, _selection: 0, initialize: function (t, n, i, r, s, a) { var o; var h; var u; var l; var c = arguments.length; c > 0 && (t == null || typeof t === `object` ? c === 1 && t && `point` in t ? (o = t.point, h = t.handleIn, u = t.handleOut, l = t.selection) : (o = t, h = n, u = i, l = r) : (o = [t, n], h = i !== e ? [i, r] : null, u = s !== e ? [s, a] : null)), new T(o, this, `_point`), new T(h, this, `_handleIn`), new T(u, this, `_handleOut`), l && this.setSelection(l) }, _serialize: function (t, e) { var n = this._point; var i = this._selection; var s = i || this.hasHandles() ? [n, this._handleIn, this._handleOut] : n; return i && s.push(i), r.serialize(s, t, !0, e) }, _changed: function (t) { var e = this._path; if (e) { var n; var i = e._curves; var r = this._index; i && (t && t !== this._point && t !== this._handleIn || !(n = r > 0 ? i[r - 1] : e._closed ? i[i.length - 1] : null) || n._changed(), t && t !== this._point && t !== this._handleOut || !(n = i[r]) || n._changed()), e._changed(41) } }, getPoint: function () { return this._point }, setPoint: function () { this._point.set(c.read(arguments)) }, getHandleIn: function () { return this._handleIn }, setHandleIn: function () { this._handleIn.set(c.read(arguments)) }, getHandleOut: function () { return this._handleOut }, setHandleOut: function () { this._handleOut.set(c.read(arguments)) }, hasHandles: function () { return !this._handleIn.isZero() || !this._handleOut.isZero() }, isSmooth: function () { var t = this._handleIn; var e = this._handleOut; return !t.isZero() && !e.isZero() && t.isCollinear(e) }, clearHandles: function () { this._handleIn._set(0, 0), this._handleOut._set(0, 0) }, getSelection: function () { return this._selection }, setSelection: function (t) { var e = this._selection; var n = this._path; this._selection = t = t || 0, n && t !== e && (n._updateSelection(this, e, t), n._changed(257)) }, _changeSelection: function (t, e) { var n = this._selection; this.setSelection(e ? n | t : n & ~t) }, isSelected: function () { return !!(7 & this._selection) }, setSelected: function (t) { this._changeSelection(7, t) }, getIndex: function () { return this._index !== e ? this._index : null }, getPath: function () { return this._path || null }, getCurve: function () { var t = this._path; var e = this._index; return t ? (e > 0 && !t._closed && e === t._segments.length - 1 && e--, t.getCurves()[e] || null) : null }, getLocation: function () { var t = this.getCurve(); return t ? new z(t, this === t._segment1 ? 0 : 1) : null }, getNext: function () { var t = this._path && this._path._segments; return t && (t[this._index + 1] || this._path._closed && t[0]) || null }, smooth: function (t, n, i) { var r = t || {}; var s = r.type; var a = r.factor; var o = this.getPrevious(); var h = this.getNext(); var u = (o || this)._point; var l = this._point; var f = (h || this)._point; var d = u.getDistance(l); var _ = l.getDistance(f); if (s && s !== `catmull-rom`) { if (s !== `geometric`) { throw new Error(`Smoothing method '` + s + `' not supported.`) } if (o && h) { var g = u.subtract(f); var v = a === e ? 0.4 : a; var p = v * d / (d + _); n || this.setHandleIn(g.multiply(p)), i || this.setHandleOut(g.multiply(p - v)) } } else { var m = a === e ? 0.5 : a; var y = Math.pow(d, m); var w = y * y; var x = Math.pow(_, m); var b = x * x; if (!n && o) { var C = 2 * b + 3 * x * y + w; var S = 3 * x * (x + y); this.setHandleIn(S !== 0 ? new c((b * u._x + C * l._x - w * f._x) / S - l._x, (b * u._y + C * l._y - w * f._y) / S - l._y) : new c()) } if (!i && h) { var C = 2 * w + 3 * y * x + b; var S = 3 * y * (y + x); this.setHandleOut(S !== 0 ? new c((w * f._x + C * l._x - b * u._x) / S - l._x, (w * f._y + C * l._y - b * u._y) / S - l._y) : new c()) } } }, getPrevious: function () { var t = this._path && this._path._segments; return t && (t[this._index - 1] || this._path._closed && t[t.length - 1]) || null }, isFirst: function () { return !this._index }, isLast: function () { var t = this._path; return t && this._index === t._segments.length - 1 || !1 }, reverse: function () { var t = this._handleIn; var e = this._handleOut; var n = t.clone(); t.set(e), e.set(n) }, reversed: function () { return new M(this._point, this._handleOut, this._handleIn) }, remove: function () { return !!this._path && !!this._path.removeSegment(this._index) }, clone: function () { return new M(this._point, this._handleIn, this._handleOut) }, equals: function (t) { return t === this || t && this._class === t._class && this._point.equals(t._point) && this._handleIn.equals(t._handleIn) && this._handleOut.equals(t._handleOut) || !1 }, toString: function () { var t = [`point: ` + this._point]; return this._handleIn.isZero() || t.push(`handleIn: ` + this._handleIn), this._handleOut.isZero() || t.push(`handleOut: ` + this._handleOut), `{ ` + t.join(`, `) + ` }` }, transform: function (t) { this._transformCoordinates(t, new Array(6), !0), this._changed() }, interpolate: function (t, e, n) { var i = 1 - n; var r = n; var s = t._point; var a = e._point; var o = t._handleIn; var h = e._handleIn; var u = e._handleOut; var l = t._handleOut; this._point._set(i * s._x + r * a._x, i * s._y + r * a._y, !0), this._handleIn._set(i * o._x + r * h._x, i * o._y + r * h._y, !0), this._handleOut._set(i * l._x + r * u._x, i * l._y + r * u._y, !0), this._changed() }, _transformCoordinates: function (t, e, n) { var i = this._point; var r = n && this._handleIn.isZero() ? null : this._handleIn; var s = n && this._handleOut.isZero() ? null : this._handleOut; var a = i._x; var o = i._y; var h = 2; return e[0] = a, e[1] = o, r && (e[h++] = r._x + a, e[h++] = r._y + o), s && (e[h++] = s._x + a, e[h++] = s._y + o), t && (t._transformCoordinates(e, e, h / 2), a = e[0], o = e[1], n ? (i._x = a, i._y = o, h = 2, r && (r._x = e[h++] - a, r._y = e[h++] - o), s && (s._x = e[h++] - a, s._y = e[h++] - o)) : (r || (e[h++] = a, e[h++] = o), s || (e[h++] = a, e[h++] = o))), e } }); var T = c.extend({ initialize: function (t, n, i) { var r; var s; var a; if (t) { if ((r = t[0]) !== e) { s = t[1] } else { var o = t; (r = o.x) === e && (o = c.read(arguments), r = o.x), s = o.y, a = o.selected } } else { r = s = 0 } this._x = r, this._y = s, this._owner = n, n[i] = this, a && this.setSelected(!0) }, _set: function (t, e) { return this._x = t, this._y = e, this._owner._changed(this), this }, getX: function () { return this._x }, setX: function (t) { this._x = t, this._owner._changed(this) }, getY: function () { return this._y }, setY: function (t) { this._y = t, this._owner._changed(this) }, isZero: function () { var t = u.isZero; return t(this._x) && t(this._y) }, isSelected: function () { return !!(this._owner._selection & this._getSelection()) }, setSelected: function (t) { this._owner._changeSelection(this._getSelection(), t) }, _getSelection: function () { var t = this._owner; return this === t._point ? 1 : this === t._handleIn ? 2 : this === t._handleOut ? 4 : 0 } }); var A = r.extend({ _class: `Curve`, beans: !0, initialize: function (t, e, n, i, r, s, a, o) { var h; var u; var l; var c; var f; var d; var _ = arguments.length; _ === 3 ? (this._path = t, h = e, u = n) : _ ? _ === 1 ? `segment1` in t ? (h = new M(t.segment1), u = new M(t.segment2)) : `point1` in t ? (l = t.point1, f = t.handle1, d = t.handle2, c = t.point2) : Array.isArray(t) && (l = [t[0], t[1]], c = [t[6], t[7]], f = [t[2] - t[0], t[3] - t[1]], d = [t[4] - t[6], t[5] - t[7]]) : _ === 2 ? (h = new M(t), u = new M(e)) : _ === 4 ? (l = t, f = e, d = n, c = i) : _ === 8 && (l = [t, e], c = [a, o], f = [n - t, i - e], d = [r - a, s - o]) : (h = new M(), u = new M()), this._segment1 = h || new M(l, null, f), this._segment2 = u || new M(c, d, null) }, _serialize: function (t, e) { return r.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], t, !0, e) }, _changed: function () { this._length = this._bounds = e }, clone: function () { return new A(this._segment1, this._segment2) }, toString: function () { var t = [`point1: ` + this._segment1._point]; return this._segment1._handleOut.isZero() || t.push(`handle1: ` + this._segment1._handleOut), this._segment2._handleIn.isZero() || t.push(`handle2: ` + this._segment2._handleIn), t.push(`point2: ` + this._segment2._point), `{ ` + t.join(`, `) + ` }` }, classify: function () { return A.classify(this.getValues()) }, remove: function () { var t = !1; if (this._path) { var e = this._segment2; var n = e._handleOut; t = e.remove(), t && this._segment1._handleOut.set(n) } return t }, getPoint1: function () { return this._segment1._point }, setPoint1: function () { this._segment1._point.set(c.read(arguments)) }, getPoint2: function () { return this._segment2._point }, setPoint2: function () { this._segment2._point.set(c.read(arguments)) }, getHandle1: function () { return this._segment1._handleOut }, setHandle1: function () { this._segment1._handleOut.set(c.read(arguments)) }, getHandle2: function () { return this._segment2._handleIn }, setHandle2: function () { this._segment2._handleIn.set(c.read(arguments)) }, getSegment1: function () { return this._segment1 }, getSegment2: function () { return this._segment2 }, getPath: function () { return this._path }, getIndex: function () { return this._segment1._index }, getNext: function () { var t = this._path && this._path._curves; return t && (t[this._segment1._index + 1] || this._path._closed && t[0]) || null }, getPrevious: function () { var t = this._path && this._path._curves; return t && (t[this._segment1._index - 1] || this._path._closed && t[t.length - 1]) || null }, isFirst: function () { return !this._segment1._index }, isLast: function () { var t = this._path; return t && this._segment1._index === t._curves.length - 1 || !1 }, isSelected: function () { return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected() }, setSelected: function (t) { this.getPoint1().setSelected(t), this.getHandle1().setSelected(t), this.getHandle2().setSelected(t), this.getPoint2().setSelected(t) }, getValues: function (t) { return A.getValues(this._segment1, this._segment2, t) }, getPoints: function () { for (var t = this.getValues(), e = [], n = 0; n < 8; n += 2) { e.push(new c(t[n], t[n + 1])) } return e } }, { getLength: function () { return this._length == null && (this._length = A.getLength(this.getValues(), 0, 1)), this._length }, getArea: function () { return A.getArea(this.getValues()) }, getLine: function () { return new m(this._segment1._point, this._segment2._point) }, getPart: function (t, e) { return new A(A.getPart(this.getValues(), t, e)) }, getPartLength: function (t, e) { return A.getLength(this.getValues(), t, e) }, divideAt: function (t) { return this.divideAtTime(t && t.curve === this ? t.time : this.getTimeAt(t)) }, divideAtTime: function (t, e) { var n = 1e-8; var i = 1 - n; var r = null; if (t >= n && t <= i) { var s = A.subdivide(this.getValues(), t); var a = s[0]; var o = s[1]; var h = e || this.hasHandles(); var u = this._segment1; var l = this._segment2; var f = this._path; h && (u._handleOut._set(a[2] - a[0], a[3] - a[1]), l._handleIn._set(o[4] - o[6], o[5] - o[7])); var d = a[6]; var _ = a[7]; var g = new M(new c(d, _), h && new c(a[4] - d, a[5] - _), h && new c(o[2] - d, o[3] - _)); f ? (f.insert(u._index + 1, g), r = this.getNext()) : (this._segment2 = g, this._changed(), r = new A(g, l)) } return r }, splitAt: function (t) { var e = this._path; return e ? e.splitAt(t) : null }, splitAtTime: function (t) { return this.splitAt(this.getLocationAtTime(t)) }, divide: function (t, n) { return this.divideAtTime(t === e ? 0.5 : n ? t : this.getTimeAt(t)) }, split: function (t, n) { return this.splitAtTime(t === e ? 0.5 : n ? t : this.getTimeAt(t)) }, reversed: function () { return new A(this._segment2.reversed(), this._segment1.reversed()) }, clearHandles: function () { this._segment1._handleOut._set(0, 0), this._segment2._handleIn._set(0, 0) }, statics: { getValues: function (t, e, n, i) { var r = t._point; var s = t._handleOut; var a = e._handleIn; var o = e._point; var h = r.x; var u = r.y; var l = o.x; var c = o.y; var f = i ? [h, u, h, u, l, c, l, c] : [h, u, h + s._x, u + s._y, l + a._x, c + a._y, l, c]; return n && n._transformCoordinates(f, f, 4), f }, subdivide: function (t, n) { var i = t[0]; var r = t[1]; var s = t[2]; var a = t[3]; var o = t[4]; var h = t[5]; var u = t[6]; var l = t[7]; n === e && (n = 0.5); var c = 1 - n; var f = c * i + n * s; var d = c * r + n * a; var _ = c * s + n * o; var g = c * a + n * h; var v = c * o + n * u; var p = c * h + n * l; var m = c * f + n * _; var y = c * d + n * g; var w = c * _ + n * v; var x = c * g + n * p; var b = c * m + n * w; var C = c * y + n * x; return [[i, r, f, d, m, y, b, C], [b, C, w, x, v, p, u, l]] }, getMonoCurves: function (t, e) { var n = []; var i = e ? 0 : 1; var r = t[i + 0]; var s = t[i + 2]; var a = t[i + 4]; var o = t[i + 6]; if (r >= s == s >= a && s >= a == a >= o || A.isStraight(t)) { n.push(t) } else { var h = 3 * (s - a) - r + o; var l = 2 * (r + a) - 4 * s; var c = s - r; var f = 1e-8; var d = 1 - f; var _ = []; var g = u.solveQuadratic(h, l, c, _, f, d); if (g) { _.sort(); var v = _[0]; var p = A.subdivide(t, v); n.push(p[0]), g > 1 && (v = (_[1] - v) / (1 - v), p = A.subdivide(p[1], v), n.push(p[0])), n.push(p[1]) } else { n.push(t) } } return n }, solveCubic: function (t, e, n, i, r, s) { var a = t[e]; var o = t[e + 2]; var h = t[e + 4]; var l = t[e + 6]; var c = 0; if (!(a < n && l < n && o < n && h < n || a > n && l > n && o > n && h > n)) { var f = 3 * (o - a); var d = 3 * (h - o) - f; var _ = l - a - f - d; c = u.solveCubic(_, d, f, a - n, i, r, s) } return c }, getTimeOf: function (t, e) { var n = new c(t[0], t[1]); var i = new c(t[6], t[7]); var r = 1e-12; var s = 1e-7; var a = e.isClose(n, r) ? 0 : e.isClose(i, r) ? 1 : null; if (a === null) { for (var o = [e.x, e.y], h = [], u = 0; u < 2; u++) { for (var l = A.solveCubic(t, u, o[u], h, 0, 1), f = 0; f < l; f++) { var d = h[f]; if (e.isClose(A.getPoint(t, d), s)) { return d } } } } return e.isClose(n, s) ? 0 : e.isClose(i, s) ? 1 : null }, getNearestTime: function (t, e) { function n (n) { if (n >= 0 && n <= 1) { var i = e.getDistance(A.getPoint(t, n), !0); if (i < d) { return d = i, _ = n, !0 } } } if (A.isStraight(t)) { var i = t[0]; var r = t[1]; var s = t[6]; var a = t[7]; var o = s - i; var h = a - r; var u = o * o + h * h; if (u === 0) { return 0 } var l = ((e.x - i) * o + (e.y - r) * h) / u; return l < 1e-12 ? 0 : l > 0.999999999999 ? 1 : A.getTimeOf(t, new c(i + l * o, r + l * h)) } for (var f = 100, d = 1 / 0, _ = 0, g = 0; g <= f; g++) { n(g / f) } for (var v = 1 / (2 * f); v > 1e-8;) { n(_ - v) || n(_ + v) || (v /= 2) } return _ }, getPart: function (t, e, n) { var i = e > n; if (i) { var r = e; e = n, n = r } return e > 0 && (t = A.subdivide(t, e)[1]), n < 1 && (t = A.subdivide(t, (n - e) / (1 - e))[0]), i ? [t[6], t[7], t[4], t[5], t[2], t[3], t[0], t[1]] : t }, isFlatEnough: function (t, e) { var n = t[0]; var i = t[1]; var r = t[2]; var s = t[3]; var a = t[4]; var o = t[5]; var h = t[6]; var u = t[7]; var l = 3 * r - 2 * n - h; var c = 3 * s - 2 * i - u; var f = 3 * a - 2 * h - n; var d = 3 * o - 2 * u - i; return Math.max(l * l, f * f) + Math.max(c * c, d * d) <= 16 * e * e }, getArea: function (t) { var e = t[0]; var n = t[1]; var i = t[2]; var r = t[3]; var s = t[4]; var a = t[5]; var o = t[6]; var h = t[7]; return 3 * ((h - n) * (i + s) - (o - e) * (r + a) + r * (e - s) - i * (n - a) + h * (s + e / 3) - o * (a + n / 3)) / 20 }, getBounds: function (t) { for (var e = t.slice(0, 2), n = e.slice(), i = [0, 0], r = 0; r < 2; r++) { A._addBounds(t[r], t[r + 2], t[r + 4], t[r + 6], r, 0, e, n, i) } return new g(e[0], e[1], n[0] - e[0], n[1] - e[1]) }, _addBounds: function (t, e, n, i, r, s, a, o, h) { function l (t, e) { var n = t - e; var i = t + e; n < a[r] && (a[r] = n), i > o[r] && (o[r] = i) }s /= 2; var c = a[r] - s; var f = o[r] + s; if (t < c || e < c || n < c || i < c || t > f || e > f || n > f || i > f) { if (e < t != e < i && n < t != n < i) { l(t, s), l(i, s) } else { var d = 3 * (e - n) - t + i; var _ = 2 * (t + n) - 4 * e; var g = e - t; var v = u.solveQuadratic(d, _, g, h); var p = 1e-8; var m = 1 - p; l(i, 0); for (var y = 0; y < v; y++) { var w = h[y]; var x = 1 - w; p <= w && w <= m && l(x * x * x * t + 3 * x * x * w * e + 3 * x * w * w * n + w * w * w * i, s) } } } } } }, r.each([`getBounds`, `getStrokeBounds`, `getHandleBounds`], function (t) { this[t] = function () { this._bounds || (this._bounds = {}); var e = this._bounds[t]; return e || (e = this._bounds[t] = L[t]([this._segment1, this._segment2], !1, this._path)), e.clone() } }, {}), r.each({ isStraight: function (t, e, n, i) { if (e.isZero() && n.isZero()) { return !0 } var r = i.subtract(t); if (r.isZero()) { return !1 } if (r.isCollinear(e) && r.isCollinear(n)) { var s = new m(t, i); var a = 1e-7; if (s.getDistance(t.add(e)) < a && s.getDistance(i.add(n)) < a) { var o = r.dot(r); var h = r.dot(e) / o; var u = r.dot(n) / o; return h >= 0 && h <= 1 && u <= 0 && u >= -1 } } return !1 }, isLinear: function (t, e, n, i) { var r = i.subtract(t).divide(3); return e.equals(r) && n.negate().equals(r) } }, function (t, e) { this[e] = function (e) { var n = this._segment1; var i = this._segment2; return t(n._point, n._handleOut, i._handleIn, i._point, e) }, this.statics[e] = function (e, n) { var i = e[0]; var r = e[1]; var s = e[6]; var a = e[7]; return t(new c(i, r), new c(e[2] - i, e[3] - r), new c(e[4] - s, e[5] - a), new c(s, a), n) } }, { statics: {}, hasHandles: function () { return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero() }, hasLength: function (t) { return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (t || 0) }, isCollinear: function (t) { return t && this.isStraight() && t.isStraight() && this.getLine().isCollinear(t.getLine()) }, isHorizontal: function () { return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8 }, isVertical: function () { return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8 } }), { beans: !1, getLocationAt: function (t, e) { return this.getLocationAtTime(e ? t : this.getTimeAt(t)) }, getLocationAtTime: function (t) { return t != null && t >= 0 && t <= 1 ? new z(this, t) : null }, getTimeAt: function (t, e) { return A.getTimeAt(this.getValues(), t, e) }, getParameterAt: `#getTimeAt`, getTimesWithTangent: function () { var t = c.read(arguments); return t.isZero() ? [] : A.getTimesWithTangent(this.getValues(), t) }, getOffsetAtTime: function (t) { return this.getPartLength(0, t) }, getLocationOf: function () { return this.getLocationAtTime(this.getTimeOf(c.read(arguments))) }, getOffsetOf: function () { var t = this.getLocationOf.apply(this, arguments); return t ? t.getOffset() : null }, getTimeOf: function () { return A.getTimeOf(this.getValues(), c.read(arguments)) }, getParameterOf: `#getTimeOf`, getNearestLocation: function () { var t = c.read(arguments); var e = this.getValues(); var n = A.getNearestTime(e, t); var i = A.getPoint(e, n); return new z(this, n, i, null, t.getDistance(i)) }, getNearestPoint: function () { var t = this.getNearestLocation.apply(this, arguments); return t ? t.getPoint() : t } }, new function () { var t = [`getPoint`, `getTangent`, `getNormal`, `getWeightedTangent`, `getWeightedNormal`, `getCurvature`]; return r.each(t, function (t) { this[t + `At`] = function (e, n) { var i = this.getValues(); return A[t](i, n ? e : A.getTimeAt(i, e)) }, this[t + `AtTime`] = function (e) { return A[t](this.getValues(), e) } }, { statics: { _evaluateMethods: t } }) }(), new function () {
    function t (t) { var e = t[0]; var n = t[1]; var i = t[2]; var r = t[3]; var s = t[4]; var a = t[5]; var o = t[6]; var h = t[7]; var u = 9 * (i - s) + 3 * (o - e); var l = 6 * (e + s) - 12 * i; var c = 3 * (i - e); var f = 9 * (r - a) + 3 * (h - n); var d = 6 * (n + a) - 12 * r; var _ = 3 * (r - n); return function (t) { var e = (u * t + l) * t + c; var n = (f * t + d) * t + _; return Math.sqrt(e * e + n * n) } } function n (t, e) { return Math.max(2, Math.min(16, Math.ceil(32 * Math.abs(e - t)))) } function i (t, e, n, i) {
      if (e == null || e < 0 || e > 1) { return null } var r = t[0]; var s = t[1]; var a = t[2]; var o = t[3]; var h = t[4]; var l = t[5]; var f = t[6]; var d = t[7]; var _ = u.isZero
      _(a - r) && _(o - s) && (a = r, o = s), _(h - f) && _(l - d) && (h = f, l = d); var g; var v; var p = 3 * (a - r); var m = 3 * (h - a) - p; var y = f - r - p - m; var w = 3 * (o - s); var x = 3 * (l - o) - w; var b = d - s - w - x; if (n === 0) { g = e === 0 ? r : e === 1 ? f : ((y * e + m) * e + p) * e + r, v = e === 0 ? s : e === 1 ? d : ((b * e + x) * e + w) * e + s } else { var C = 1e-8; var S = 1 - C; if (e < C ? (g = p, v = w) : e > S ? (g = 3 * (f - h), v = 3 * (d - l)) : (g = (3 * y * e + 2 * m) * e + p, v = (3 * b * e + 2 * x) * e + w), i) { g === 0 && v === 0 && (e < C || e > S) && (g = h - a, v = l - o); var k = Math.sqrt(g * g + v * v); k && (g /= k, v /= k) } if (n === 3) { var h = 6 * y * e + 2 * m; var l = 6 * b * e + 2 * x; var I = Math.pow(g * g + v * v, 1.5); g = I !== 0 ? (g * l - v * h) / I : 0, v = 0 } } return n === 2 ? new c(v, (-g)) : new c(g, v)
    } return { statics: { classify: function (t) { function n (t, n, i) { var r = n !== e; var s = r && n > 0 && n < 1; var a = r && i > 0 && i < 1; return !r || (s || a) && (t !== `loop` || s && a) || (t = `arch`, s = a = !1), { type: t, roots: s || a ? s && a ? n < i ? [n, i] : [i, n] : [s ? n : i] : null } } var i = t[0]; var r = t[1]; var s = t[2]; var a = t[3]; var o = t[4]; var h = t[5]; var l = t[6]; var c = t[7]; var f = i * (c - h) + r * (o - l) + l * h - c * o; var d = s * (r - c) + a * (l - i) + i * c - r * l; var _ = o * (a - r) + h * (i - s) + s * r - a * i; var g = 3 * _; var v = g - d; var p = v - d + f; var m = Math.sqrt(p * p + v * v + g * g); var y = m !== 0 ? 1 / m : 0; var w = u.isZero; var x = `serpentine`; if (p *= y, v *= y, g *= y, w(p)) { return w(v) ? n(w(g) ? `line` : `quadratic`) : n(x, g / (3 * v)) } var b = 3 * v * v - 4 * p * g; if (w(b)) { return n(`cusp`, v / (2 * p)) } var C = b > 0 ? Math.sqrt(b / 3) : Math.sqrt(-b); var S = 2 * p; return n(b > 0 ? x : `loop`, (v + C) / S, (v - C) / S) }, getLength: function (i, r, s, a) { if (r === e && (r = 0), s === e && (s = 1), A.isStraight(i)) { var o = i; s < 1 && (o = A.subdivide(o, s)[0], r /= s), r > 0 && (o = A.subdivide(o, r)[1]); var h = o[6] - o[0]; var l = o[7] - o[1]; return Math.sqrt(h * h + l * l) } return u.integrate(a || t(i), r, s, n(r, s)) }, getTimeAt: function (i, r, s) { function a (t) { return p += u.integrate(d, s, t, n(s, t)), s = t, p - r } if (s === e && (s = r < 0 ? 1 : 0), r === 0) { return s } var o = Math.abs; var h = 1e-12; var l = r > 0; var c = l ? s : 0; var f = l ? 1 : s; var d = t(i); var _ = A.getLength(i, c, f, d); var g = o(r) - _; if (o(g) < h) { return l ? f : c } if (g > h) { return null } var v = r / _; var p = 0; return u.findRoot(a, d, s + v, c, f, 32, 1e-12) }, getPoint: function (t, e) { return i(t, e, 0, !1) }, getTangent: function (t, e) { return i(t, e, 1, !0) }, getWeightedTangent: function (t, e) { return i(t, e, 1, !1) }, getNormal: function (t, e) { return i(t, e, 2, !0) }, getWeightedNormal: function (t, e) { return i(t, e, 2, !1) }, getCurvature: function (t, e) { return i(t, e, 3, !1).x }, getPeaks: function (t) { var e = t[0]; var n = t[1]; var i = t[2]; var r = t[3]; var s = t[4]; var a = t[5]; var o = t[6]; var h = t[7]; var l = -e + 3 * i - 3 * s + o; var c = 3 * e - 6 * i + 3 * s; var f = -3 * e + 3 * i; var d = -n + 3 * r - 3 * a + h; var _ = 3 * n - 6 * r + 3 * a; var g = -3 * n + 3 * r; var v = 1e-8; var p = 1 - v; var m = []; return u.solveCubic(9 * (l * l + d * d), 9 * (l * c + _ * d), 2 * (c * c + _ * _) + 3 * (f * l + g * d), f * c + _ * g, m, v, p), m.sort() } } }
  }(), new function () { function t (t, e, n, i, r, s, a) { var o = !a && n.getPrevious() === r; var h = !a && n !== r && n.getNext() === r; var u = 1e-8; var l = 1 - u; if (i !== null && i >= (o ? u : 0) && i <= (h ? l : 1) && s !== null && s >= (h ? u : 0) && s <= (o ? l : 1)) { var c = new z(n, i, null, a); var f = new z(r, s, null, a); c._intersection = f, f._intersection = c, e && !e(c) || z.insert(t, c, !0) } } function e (r, s, a, o, h, u, l, c, f, d, _, g, v) { if (++f >= 4096 || ++c >= 40) { return f } var p; var y; var w = 1e-9; var x = s[0]; var b = s[1]; var C = s[6]; var S = s[7]; var k = m.getSignedDistance; var I = k(x, b, C, S, s[2], s[3]); var P = k(x, b, C, S, s[4], s[5]); var M = I * P > 0 ? 0.75 : 4 / 9; var T = M * Math.min(0, I, P); var z = M * Math.max(0, I, P); var O = k(x, b, C, S, r[0], r[1]); var L = k(x, b, C, S, r[2], r[3]); var E = k(x, b, C, S, r[4], r[5]); var N = k(x, b, C, S, r[6], r[7]); var B = n(O, L, E, N); var F = B[0]; var j = B[1]; if (I === 0 && P === 0 && O === 0 && L === 0 && E === 0 && N === 0 || (p = i(F, j, T, z)) == null || (y = i(F.reverse(), j.reverse(), T, z)) == null) { return f } var D = d + (_ - d) * p; var R = d + (_ - d) * y; if (Math.max(v - g, R - D) < w) { var q = (D + R) / 2; var V = (g + v) / 2; t(h, u, l ? o : a, l ? V : q, l ? a : o, l ? q : V) } else if (r = A.getPart(r, p, y), y - p > 0.8) { if (R - D > v - g) { var U = A.subdivide(r, 0.5); var q = (D + R) / 2; f = e(s, U[0], o, a, h, u, !l, c, f, g, v, D, q), f = e(s, U[1], o, a, h, u, !l, c, f, g, v, q, R) } else { var U = A.subdivide(s, 0.5); var V = (g + v) / 2; f = e(U[0], r, o, a, h, u, !l, c, f, g, V, D, R), f = e(U[1], r, o, a, h, u, !l, c, f, V, v, D, R) } } else { f = v - g >= w ? e(s, r, o, a, h, u, !l, c, f, g, v, D, R) : e(r, s, a, o, h, u, l, c, f, D, R, g, v) } return f } function n (t, e, n, i) { var r; var s = [0, t]; var a = [1 / 3, e]; var o = [2 / 3, n]; var h = [1, i]; var u = e - (2 * t + i) / 3; var l = n - (t + 2 * i) / 3; if (u * l < 0) { r = [[s, a, h], [s, o, h]] } else { var c = u / l; r = [c >= 2 ? [s, a, h] : c <= 0.5 ? [s, o, h] : [s, a, o, h], [s, h]] } return (u || l) < 0 ? r.reverse() : r } function i (t, e, n, i) { return t[0][1] < n ? s(t, !0, n) : e[0][1] > i ? s(e, !1, i) : t[0][0] } function s (t, e, n) { for (var i = t[0][0], r = t[0][1], s = 1, a = t.length; s < a; s++) { var o = t[s][0]; var h = t[s][1]; if (e ? h >= n : h <= n) { return h === n ? o : i + (n - r) * (o - i) / (h - r) }i = o, r = h } return null } function a (t, e, n, i, r) { var s = u.isZero; if (s(i) && s(r)) { var a = A.getTimeOf(t, new c(e, n)); return a === null ? [] : [a] } for (var o = Math.atan2(-r, i), h = Math.sin(o), l = Math.cos(o), f = [], d = [], _ = 0; _ < 8; _ += 2) { var g = t[_] - e; var v = t[_ + 1] - n; f.push(g * l - v * h, g * h + v * l) } return A.solveCubic(f, 1, 0, d, 0, 1), d } function o (e, n, i, r, s, o, h) { for (var u = n[0], l = n[1], c = n[6], f = n[7], d = a(e, u, l, c - u, f - l), _ = 0, g = d.length; _ < g; _++) { var v = d[_]; var p = A.getPoint(e, v); var m = A.getTimeOf(n, p); m !== null && t(s, o, h ? r : i, h ? m : v, h ? i : r, h ? v : m) } } function h (e, n, i, r, s, a) { var o = m.intersect(e[0], e[1], e[6], e[7], n[0], n[1], n[6], n[7]); o && t(s, a, i, A.getTimeOf(e, o), r, A.getTimeOf(n, o)) } function l (n, i, r, s, a, u) { var l = 1e-12; var f = Math.min; var d = Math.max; if (d(n[0], n[2], n[4], n[6]) + l > f(i[0], i[2], i[4], i[6]) && f(n[0], n[2], n[4], n[6]) - l < d(i[0], i[2], i[4], i[6]) && d(n[1], n[3], n[5], n[7]) + l > f(i[1], i[3], i[5], i[7]) && f(n[1], n[3], n[5], n[7]) - l < d(i[1], i[3], i[5], i[7])) { var g = _(n, i); if (g) { for (var v = 0; v < 2; v++) { var p = g[v]; t(a, u, r, p[0], s, p[1], !0) } } else { var m = A.isStraight(n); var y = A.isStraight(i); var w = m && y; var x = m && !y; var b = a.length; if ((w ? h : m || y ? o : e)(x ? i : n, x ? n : i, x ? s : r, x ? r : s, a, u, x, 0, 0, 0, 1, 0, 1), !w || a.length === b) { for (var v = 0; v < 4; v++) { var C = v >> 1; var S = 1 & v; var k = 6 * C; var I = 6 * S; var P = new c(n[k], n[k + 1]); var M = new c(i[I], i[I + 1]); P.isClose(M, l) && t(a, u, r, C, s, S) } } } } return a } function f (e, n, i, r) { var s = A.classify(e); if (s.type === `loop`) { var a = s.roots; t(i, r, n, a[0], n, a[1]) } return i } function d (t, e, n, i, s, a) { var o = !e; o && (e = t); for (var h, u, c = t.length, d = e.length, _ = [], g = [], v = 0; v < d; v++) { _[v] = e[v].getValues(s) } for (var v = 0; v < c; v++) { var p = t[v]; var m = o ? _[v] : p.getValues(i); var y = p.getPath(); y !== u && (u = y, h = [], g.push(h)), o && f(m, p, h, n); for (var w = o ? v + 1 : 0; w < d; w++) { if (a && h.length) { return h }l(m, _[w], p, e[w], h, n) } }h = []; for (var v = 0, x = g.length; v < x; v++) { r.push(h, g[v]) } return h } function _ (t, e) { function n (t) { var e = t[6] - t[0]; var n = t[7] - t[1]; return e * e + n * n } var i = Math.abs; var r = m.getDistance; var s = 1e-8; var a = 1e-7; var o = A.isStraight(t); var h = A.isStraight(e); var u = o && h; var l = n(t) < n(e); var f = l ? e : t; var d = l ? t : e; var _ = f[0]; var g = f[1]; var v = f[6] - _; var p = f[7] - g; if (r(_, g, v, p, d[0], d[1], !0) < a && r(_, g, v, p, d[6], d[7], !0) < a) { !u && r(_, g, v, p, f[2], f[3], !0) < a && r(_, g, v, p, f[4], f[5], !0) < a && r(_, g, v, p, d[2], d[3], !0) < a && r(_, g, v, p, d[4], d[5], !0) < a && (o = h = u = !0) } else if (u) { return null } if (o ^ h) { return null } for (var y = [t, e], w = [], x = 0; x < 4 && w.length < 2; x++) { var b = 1 & x; var C = 1 ^ b; var S = x >> 1; var k = A.getTimeOf(y[b], new c(y[C][S ? 6 : 0], y[C][S ? 7 : 1])); if (k != null) { var I = b ? [S, k] : [k, S]; (!w.length || i(I[0] - w[0][0]) > s && i(I[1] - w[0][1]) > s) && w.push(I) } if (x > 2 && !w.length) { break } } if (w.length !== 2) { w = null } else if (!u) { var P = A.getPart(t, w[0][0], w[1][0]); var M = A.getPart(e, w[0][1], w[1][1]); (i(M[2] - P[2]) > a || i(M[3] - P[3]) > a || i(M[4] - P[4]) > a || i(M[5] - P[5]) > a) && (w = null) } return w } function g (t, e) { var n = t[0]; var i = t[1]; var r = t[2]; var s = t[3]; var a = t[4]; var o = t[5]; var h = t[6]; var l = t[7]; var c = e.normalize(); var f = c.x; var d = c.y; var _ = 3 * h - 9 * a + 9 * r - 3 * n; var g = 3 * l - 9 * o + 9 * s - 3 * i; var v = 6 * a - 12 * r + 6 * n; var p = 6 * o - 12 * s + 6 * i; var m = 3 * r - 3 * n; var y = 3 * s - 3 * i; var w = 2 * _ * d - 2 * g * f; var x = []; if (Math.abs(w) < u.CURVETIME_EPSILON) { var b = _ * y - g * m; var w = _ * p - g * v; if (w != 0) { var C = -b / w; C >= 0 && C <= 1 && x.push(C) } } else { var S = (v * v - 4 * _ * m) * d * d + (-2 * v * p + 4 * g * m + 4 * _ * y) * f * d + (p * p - 4 * g * y) * f * f; var k = v * d - p * f; if (S >= 0 && w != 0) { var I = Math.sqrt(S); var P = -(k + I) / w; var M = (-k + I) / w; P >= 0 && P <= 1 && x.push(P), M >= 0 && M <= 1 && x.push(M) } } return x } return { getIntersections: function (t) { var e = this.getValues(); var n = t && t !== this && t.getValues(); return n ? l(e, n, this, t, []) : f(e, this, []) }, statics: { getOverlaps: _, getIntersections: d, getCurveLineIntersections: a, getTimesWithTangent: g } } }()); var z = r.extend({ _class: `CurveLocation`, initialize: function (t, e, n, i, r) { if (e >= 0.99999999) { var s = t.getNext(); s && (e = 0, t = s) } this._setCurve(t), this._time = e, this._point = n || t.getPointAtTime(e), this._overlap = i, this._distance = r, this._intersection = this._next = this._previous = null }, _setCurve: function (t) { var e = t._path; this._path = e, this._version = e ? e._version : 0, this._curve = t, this._segment = null, this._segment1 = t._segment1, this._segment2 = t._segment2 }, _setSegment: function (t) { this._setCurve(t.getCurve()), this._segment = t, this._time = t === this._segment1 ? 0 : 1, this._point = t._point.clone() }, getSegment: function () { var t = this._segment; if (!t) { var e = this.getCurve(); var n = this.getTime(); n === 0 ? t = e._segment1 : n === 1 ? t = e._segment2 : n != null && (t = e.getPartLength(0, n) < e.getPartLength(n, 1) ? e._segment1 : e._segment2), this._segment = t } return t }, getCurve: function () { function t (t) { var e = t && t.getCurve(); if (e && (n._time = e.getTimeOf(n._point)) != null) { return n._setCurve(e), e } } var e = this._path; var n = this; return e && e._version !== this._version && (this._time = this._offset = this._curveOffset = this._curve = null), this._curve || t(this._segment) || t(this._segment1) || t(this._segment2.getPrevious()) }, getPath: function () { var t = this.getCurve(); return t && t._path }, getIndex: function () { var t = this.getCurve(); return t && t.getIndex() }, getTime: function () { var t = this.getCurve(); var e = this._time; return t && e == null ? this._time = t.getTimeOf(this._point) : e }, getParameter: `#getTime`, getPoint: function () { return this._point }, getOffset: function () { var t = this._offset; if (t == null) { t = 0; var e = this.getPath(); var n = this.getIndex(); if (e && n != null) { for (var i = e.getCurves(), r = 0; r < n; r++) { t += i[r].getLength() } } this._offset = t += this.getCurveOffset() } return t }, getCurveOffset: function () { var t = this._curveOffset; if (t == null) { var e = this.getCurve(); var n = this.getTime(); this._curveOffset = t = n != null && e && e.getPartLength(0, n) } return t }, getIntersection: function () { return this._intersection }, getDistance: function () { return this._distance }, divide: function () { var t = this.getCurve(); var e = t && t.divideAtTime(this.getTime()); return e && this._setSegment(e._segment1), e }, split: function () { var t = this.getCurve(); var e = t._path; var n = t && t.splitAtTime(this.getTime()); return n && this._setSegment(e.getLastSegment()), n }, equals: function (t, e) { var n = this === t; if (!n && t instanceof z) { var i = this.getCurve(); var r = t.getCurve(); var s = i._path; var a = r._path; if (s === a) { var o = Math.abs; var h = 1e-7; var u = o(this.getOffset() - t.getOffset()); var l = !e && this._intersection; var c = !e && t._intersection; n = (u < h || s && o(s.getLength() - u) < h) && (!l && !c || l && c && l.equals(c, !0)) } } return n }, toString: function () { var t = []; var e = this.getPoint(); var n = h.instance; e && t.push(`point: ` + e); var i = this.getIndex(); i != null && t.push(`index: ` + i); var r = this.getTime(); return r != null && t.push(`time: ` + n.number(r)), this._distance != null && t.push(`distance: ` + n.number(this._distance)), `{ ` + t.join(`, `) + ` }` }, isTouching: function () { var t = this._intersection; if (t && this.getTangent().isCollinear(t.getTangent())) { var e = this.getCurve(); var n = t.getCurve(); return !(e.isStraight() && n.isStraight() && e.getLine().intersect(n.getLine())) } return !1 }, isCrossing: function () { function t (t, e) { var n = t.getValues(); var i = A.classify(n).roots || A.getPeaks(n); var r = i.length; var s = e && r > 1 ? i[r - 1] : r > 0 ? i[0] : 0.5; d.push(A.getLength(n, e ? s : 0, e ? 1 : s) / 2) } function e (t, e, n) { return e < n ? t > e && t < n : t > e || t < n } var n = this._intersection; if (!n) { return !1 } var i = this.getTime(); var r = n.getTime(); var s = 1e-8; var a = 1 - s; var o = i >= s && i <= a; var h = r >= s && r <= a; if (o && h) { return !this.isTouching() } var u = this.getCurve(); var l = i < s ? u.getPrevious() : u; var c = n.getCurve(); var f = r < s ? c.getPrevious() : c; if (i > a && (u = u.getNext()), r > a && (c = c.getNext()), !(l && u && f && c)) { return !1 } var d = []; o || (t(l, !0), t(u, !1)), h || (t(f, !0), t(c, !1)); var _ = this.getPoint(); var g = Math.min.apply(Math, d); var v = o ? u.getTangentAtTime(i) : u.getPointAt(g).subtract(_); var p = o ? v.negate() : l.getPointAt(-g).subtract(_); var m = h ? c.getTangentAtTime(r) : c.getPointAt(g).subtract(_); var y = h ? m.negate() : f.getPointAt(-g).subtract(_); var w = p.getAngle(); var x = v.getAngle(); var b = y.getAngle(); var C = m.getAngle(); return !!(o ? e(w, b, C) ^ e(x, b, C) && e(w, C, b) ^ e(x, C, b) : e(b, w, x) ^ e(C, w, x) && e(b, x, w) ^ e(C, x, w)) }, hasOverlap: function () { return !!this._overlap } }, r.each(A._evaluateMethods, function (t) { var e = t + `At`; this[t] = function () { var t = this.getCurve(); var n = this.getTime(); return n != null && t && t[e](n, !0) } }, { preserve: !0 }), new function () { function t (t, e, n) { function i (n, i) { for (var s = n + i; s >= -1 && s <= r; s += i) { var a = t[(s % r + r) % r]; if (!e.getPoint().isClose(a.getPoint(), 1e-7)) { break } if (e.equals(a)) { return a } } return null } for (var r = t.length, s = 0, a = r - 1; s <= a;) { var o; var h = s + a >>> 1; var u = t[h]; if (n && (o = e.equals(u) ? u : i(h, -1) || i(h, 1))) { return e._overlap && (o._overlap = o._intersection._overlap = !0), o } var l = e.getPath(); var c = u.getPath(); var f = l !== c ? l._id - c._id : e.getIndex() + e.getTime() - (u.getIndex() + u.getTime()); f < 0 ? a = h - 1 : s = h + 1 } return t.splice(s, 0, e), e } return { statics: { insert: t, expand: function (e) { for (var n = e.slice(), i = e.length - 1; i >= 0; i--) { t(n, e[i]._intersection, !1) } return n } } } }()); var O = w.extend({ _class: `PathItem`, _selectBounds: !1, _canScaleStroke: !0, beans: !0, initialize: function () {}, statics: { create: function (t) { var e; var n; var i; if (r.isPlainObject(t) ? (n = t.segments, e = t.pathData) : Array.isArray(t) ? n = t : typeof t === `string` && (e = t), n) { var s = n[0]; i = s && Array.isArray(s[0]) } else { e && (i = (e.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(e)) } var a = i ? E : L; return new a(t) } }, _asPathItem: function () { return this }, isClockwise: function () { return this.getArea() >= 0 }, setClockwise: function (t) { this.isClockwise() != (t = !!t) && this.reverse() }, setPathData: function (t) { function e (t, e) { var n = +i[t]; return o && (n += h[e]), n } function n (t) { return new c(e(t, `x`), e(t + 1, `y`)) } var i; var r; var s; var a = t && t.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi); var o = !1; var h = new c(); var u = new c(); this.clear(); for (var l = 0, f = a && a.length; l < f; l++) { var _ = a[l]; var g = _[0]; var v = g.toLowerCase(); i = _.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g); var p = i && i.length; switch (o = g === v, r !== `z` || /[mz]/.test(v) || this.moveTo(h), v) { case `m`:case `l`:for (var m = v === `m`, y = 0; y < p; y += 2) { this[m ? `moveTo` : `lineTo`](h = n(y)), m && (u = h, m = !1) }s = h; break; case `h`:case `v`:var w = v === `h` ? `x` : `y`; h = h.clone(); for (var y = 0; y < p; y++) { h[w] = e(y, w), this.lineTo(h) }s = h; break; case `c`:for (var y = 0; y < p; y += 6) { this.cubicCurveTo(n(y), s = n(y + 2), h = n(y + 4)) } break; case `s`:for (var y = 0; y < p; y += 4) { this.cubicCurveTo(/[cs]/.test(r) ? h.multiply(2).subtract(s) : h, s = n(y), h = n(y + 2)), r = v } break; case `q`:for (var y = 0; y < p; y += 4) { this.quadraticCurveTo(s = n(y), h = n(y + 2)) } break; case `t`:for (var y = 0; y < p; y += 2) { this.quadraticCurveTo(s = /[qt]/.test(r) ? h.multiply(2).subtract(s) : h, h = n(y)), r = v } break; case `a`:for (var y = 0; y < p; y += 7) { this.arcTo(h = n(y + 5), new d((+i[y]), (+i[y + 1])), +i[y + 2], +i[y + 4], +i[y + 3]) } break; case `z`:this.closePath(1e-12), h = u }r = v } }, _canComposite: function () { return !(this.hasFill() && this.hasStroke()) }, _contains: function (t) { var e = t.isInside(this.getBounds({ internal: !0, handle: !0 })) ? this._getWinding(t) : {}; return e.onPath || !!(this.getFillRule() === `evenodd` ? 1 & e.windingL || 1 & e.windingR : e.winding) }, getIntersections: function (t, e, n, i) { var r = this === t || !t; var s = this._matrix._orNullIfIdentity(); var a = r ? s : (n || t._matrix)._orNullIfIdentity(); return r || this.getBounds(s).intersects(t.getBounds(a), 1e-12) ? A.getIntersections(this.getCurves(), !r && t.getCurves(), e, s, a, i) : [] }, getCrossings: function (t) { return this.getIntersections(t, (t) => { return t.hasOverlap() || t.isCrossing() }) }, getNearestLocation: function () { for (var t = c.read(arguments), e = this.getCurves(), n = 1 / 0, i = null, r = 0, s = e.length; r < s; r++) { var a = e[r].getNearestLocation(t); a._distance < n && (n = a._distance, i = a) } return i }, getNearestPoint: function () { var t = this.getNearestLocation.apply(this, arguments); return t ? t.getPoint() : t }, interpolate: function (t, e, n) { var i = !this._children; var r = i ? `_segments` : `_children`; var s = t[r]; var a = e[r]; var o = this[r]; if (!s || !a || s.length !== a.length) { throw new Error(`Invalid operands in interpolate() call: ` + t + `, ` + e) } var h = o.length; var u = a.length; if (h < u) { for (var l = i ? M : L, c = h; c < u; c++) { this.add(new l()) } } else { h > u && this[i ? `removeSegments` : `removeChildren`](u, h) } for (var c = 0; c < u; c++) { o[c].interpolate(s[c], a[c], n) }i && (this.setClosed(t._closed), this._changed(9)) }, compare: function (t) { var e = !1; if (t) { var n = this._children || [this]; var i = t._children ? t._children.slice() : [t]; var r = n.length; var s = i.length; var a = []; var o = 0; e = !0; for (var h = r - 1; h >= 0 && e; h--) { var u = n[h]; e = !1; for (var l = s - 1; l >= 0 && !e; l--) { u.compare(i[l]) && (a[l] || (a[l] = !0, o++), e = !0) } }e = e && o === s } return e } }); var L = O.extend({ _class: `Path`, _serializeFields: { segments: [], closed: !1 }, initialize: function (t) { this._closed = !1, this._segments = [], this._version = 0; var n = Array.isArray(t) ? typeof t[0] === `object` ? t : arguments : !t || t.size !== e || t.x === e && t.point === e ? null : arguments; n && n.length > 0 ? this.setSegments(n) : (this._curves = e, this._segmentSelection = 0, n || typeof t !== `string` || (this.setPathData(t), t = null)), this._initialize(!n && t) }, _equals: function (t) { return this._closed === t._closed && r.equals(this._segments, t._segments) }, copyContent: function (t) { this.setSegments(t._segments), this._closed = t._closed }, _changed: function pt (t) { if (pt.base.call(this, t), 8 & t) { if (this._length = this._area = e, 32 & t) { this._version++ } else if (this._curves) { for (var n = 0, i = this._curves.length; n < i; n++) { this._curves[n]._changed() } } } else { 64 & t && (this._bounds = e) } }, getStyle: function () { var t = this._parent; return (t instanceof E ? t : this)._style }, getSegments: function () { return this._segments }, setSegments: function (t) { var n = this.isFullySelected(); var i = t && t.length; if (this._segments.length = 0, this._segmentSelection = 0, this._curves = e, i) { var r = t[i - 1]; typeof r === `boolean` && (this.setClosed(r), i--), this._add(M.readList(t, 0, {}, i)) }n && this.setFullySelected(!0) }, getFirstSegment: function () { return this._segments[0] }, getLastSegment: function () { return this._segments[this._segments.length - 1] }, getCurves: function () { var t = this._curves; var e = this._segments; if (!t) { var n = this._countCurves(); t = this._curves = new Array(n); for (var i = 0; i < n; i++) { t[i] = new A(this, e[i], e[i + 1] || e[0]) } } return t }, getFirstCurve: function () { return this.getCurves()[0] }, getLastCurve: function () { var t = this.getCurves(); return t[t.length - 1] }, isClosed: function () { return this._closed }, setClosed: function (t) { if (this._closed != (t = !!t)) { if (this._closed = t, this._curves) { var e = this._curves.length = this._countCurves(); t && (this._curves[e - 1] = new A(this, this._segments[e - 1], this._segments[0])) } this._changed(41) } } }, { beans: !0, getPathData: function (t, e) { function n (e, n) { if (e._transformCoordinates(t, g), i = g[0], r = g[1], v) { p.push(`M` + _.pair(i, r)), v = !1 } else if (o = g[2], u = g[3], o === i && u === r && l === s && c === a) { if (!n) { var h = i - s; var f = r - a; p.push(h === 0 ? `v` + _.number(f) : f === 0 ? `h` + _.number(h) : `l` + _.pair(h, f)) } } else { p.push(`c` + _.pair(l - s, c - a) + ` ` + _.pair(o - s, u - a) + ` ` + _.pair(i - s, r - a)) }s = i, a = r, l = g[4], c = g[5] } var i; var r; var s; var a; var o; var u; var l; var c; var f = this._segments; var d = f.length; var _ = new h(e); var g = new Array(6); var v = !0; var p = []; if (!d) { return `` } for (var m = 0; m < d; m++) { n(f[m]) } return this._closed && d > 0 && (n(f[0], !0), p.push(`z`)), p.join(``) }, isEmpty: function () { return !this._segments.length }, _transformContent: function (t) { for (var e = this._segments, n = new Array(6), i = 0, r = e.length; i < r; i++) { e[i]._transformCoordinates(t, n, !0) } return !0 }, _add: function (t, e) { for (var n = this._segments, i = this._curves, s = t.length, a = e == null, e = a ? n.length : e, o = 0; o < s; o++) { var h = t[o]; h._path && (h = t[o] = h.clone()), h._path = this, h._index = e + o, h._selection && this._updateSelection(h, 0, h._selection) } if (a) { r.push(n, t) } else { n.splice.apply(n, [e, 0].concat(t)); for (var o = e + s, u = n.length; o < u; o++) { n[o]._index = o } } if (i) { var l = this._countCurves(); var c = e > 0 && e + s - 1 === l ? e - 1 : e; var f = c; var d = Math.min(c + s, l); t._curves && (i.splice.apply(i, [c, 0].concat(t._curves)), f += t._curves.length); for (var o = f; o < d; o++) { i.splice(o, 0, new A(this, null, null)) } this._adjustCurves(c, d) } return this._changed(41), t }, _adjustCurves: function (t, e) { for (var n, i = this._segments, r = this._curves, s = t; s < e; s++) { n = r[s], n._path = this, n._segment1 = i[s], n._segment2 = i[s + 1] || i[0], n._changed() }(n = r[this._closed && !t ? i.length - 1 : t - 1]) && (n._segment2 = i[t] || i[0], n._changed()), (n = r[e]) && (n._segment1 = i[e], n._changed()) }, _countCurves: function () { var t = this._segments.length; return !this._closed && t > 0 ? t - 1 : t }, add: function (t) { return arguments.length > 1 && typeof t !== `number` ? this._add(M.readList(arguments)) : this._add([M.read(arguments)])[0] }, insert: function (t, e) { return arguments.length > 2 && typeof e !== `number` ? this._add(M.readList(arguments, 1), t) : this._add([M.read(arguments, 1)], t)[0] }, addSegment: function () { return this._add([M.read(arguments)])[0] }, insertSegment: function (t) { return this._add([M.read(arguments, 1)], t)[0] }, addSegments: function (t) { return this._add(M.readList(t)) }, insertSegments: function (t, e) { return this._add(M.readList(e), t) }, removeSegment: function (t) { return this.removeSegments(t, t + 1)[0] || null }, removeSegments: function (t, e, n) { t = t || 0, e = r.pick(e, this._segments.length); var i = this._segments; var s = this._curves; var a = i.length; var o = i.splice(t, e - t); var h = o.length; if (!h) { return o } for (var u = 0; u < h; u++) { var l = o[u]; l._selection && this._updateSelection(l, l._selection, 0), l._index = l._path = null } for (var u = t, c = i.length; u < c; u++) { i[u]._index = u } if (s) { for (var f = t > 0 && e === a + (this._closed ? 1 : 0) ? t - 1 : t, s = s.splice(f, h), u = s.length - 1; u >= 0; u--) { s[u]._path = null }n && (o._curves = s.slice(1)), this._adjustCurves(f, f) } return this._changed(41), o }, clear: `#removeSegments`, hasHandles: function () { for (var t = this._segments, e = 0, n = t.length; e < n; e++) { if (t[e].hasHandles()) { return !0 } } return !1 }, clearHandles: function () { for (var t = this._segments, e = 0, n = t.length; e < n; e++) { t[e].clearHandles() } }, getLength: function () { if (this._length == null) { for (var t = this.getCurves(), e = 0, n = 0, i = t.length; n < i; n++) { e += t[n].getLength() } this._length = e } return this._length }, getArea: function () { var t = this._area; if (t == null) { var e = this._segments; var n = this._closed; t = 0; for (var i = 0, r = e.length; i < r; i++) { var s = i + 1 === r; t += A.getArea(A.getValues(e[i], e[s ? 0 : i + 1], null, s && !n)) } this._area = t } return t }, isFullySelected: function () { var t = this._segments.length; return this.isSelected() && t > 0 && this._segmentSelection === 7 * t }, setFullySelected: function (t) { t && this._selectSegments(!0), this.setSelected(t) }, setSelection: function mt (t) { 1 & t || this._selectSegments(!1), mt.base.call(this, t) }, _selectSegments: function (t) { var e = this._segments; var n = e.length; var i = t ? 7 : 0; this._segmentSelection = i * n; for (var r = 0; r < n; r++) { e[r]._selection = i } }, _updateSelection: function (t, e, n) { t._selection = n; var i = this._segmentSelection += n - e; i > 0 && this.setSelected(!0) }, divideAt: function (t) { var e; var n = this.getLocationAt(t); return n && (e = n.getCurve().divideAt(n.getCurveOffset())) ? e._segment1 : null }, splitAt: function (t) { var e = this.getLocationAt(t); var n = e && e.index; var i = e && e.time; var r = 1e-8; var s = 1 - r; i > s && (n++, i = 0); var a = this.getCurves(); if (n >= 0 && n < a.length) { i >= r && a[n++].divideAtTime(i); var o; var h = this.removeSegments(n, this._segments.length, !0); return this._closed ? (this.setClosed(!1), o = this) : (o = new L(w.NO_INSERT), o.insertAbove(this), o.copyAttributes(this)), o._add(h, 0), this.addSegment(h[0]), o } return null }, split: function (t, n) { var i; var r = n === e ? t : (i = this.getCurves()[t]) && i.getLocationAtTime(n); return r != null ? this.splitAt(r) : null }, join: function (t, e) { var n = e || 0; if (t && t !== this) { var i = t._segments; var r = this.getLastSegment(); var s = t.getLastSegment(); if (!s) { return this }r && r._point.isClose(s._point, n) && t.reverse(); var a = t.getFirstSegment(); if (r && r._point.isClose(a._point, n)) { r.setHandleOut(a._handleOut), this._add(i.slice(1)) } else { var o = this.getFirstSegment(); o && o._point.isClose(a._point, n) && t.reverse(), s = t.getLastSegment(), o && o._point.isClose(s._point, n) ? (o.setHandleIn(s._handleIn), this._add(i.slice(0, i.length - 1), 0)) : this._add(i.slice()) }t._closed && this._add([i[0]]), t.remove() } var h = this.getFirstSegment(); var u = this.getLastSegment(); return h !== u && h._point.isClose(u._point, n) && (h.setHandleIn(u._handleIn), u.remove(), this.setClosed(!0)), this }, reduce: function (t) { for (var e = this.getCurves(), n = t && t.simplify, i = n ? 1e-7 : 0, r = e.length - 1; r >= 0; r--) { var s = e[r]; !s.hasHandles() && (!s.hasLength(i) || n && s.isCollinear(s.getNext())) && s.remove() } return this }, reverse: function () { this._segments.reverse(); for (var t = 0, e = this._segments.length; t < e; t++) { var n = this._segments[t]; var i = n._handleIn; n._handleIn = n._handleOut, n._handleOut = i, n._index = t } this._curves = null, this._changed(9) }, flatten: function (t) { for (var e = new N(this, t || 0.25, 256, (!0)), n = e.parts, i = n.length, r = [], s = 0; s < i; s++) { r.push(new M(n[s].curve.slice(0, 2))) }!this._closed && i > 0 && r.push(new M(n[i - 1].curve.slice(6))), this.setSegments(r) }, simplify: function (t) { var e = new B(this).fit(t || 2.5); return e && this.setSegments(e), !!e }, smooth: function (t) { function n (t, e) { var n = t && t.index; if (n != null) { var r = t.path; if (r && r !== i) { throw new Error(t._class + ` ` + n + ` of ` + r + ` is not part of ` + i) }e && t instanceof A && n++ } else { n = typeof t === `number` ? t : e } return Math.min(n < 0 && h ? n % o : n < 0 ? n + o : n, o - 1) } var i = this; var r = t || {}; var s = r.type || `asymmetric`; var a = this._segments; var o = a.length; var h = this._closed; var u = h && r.from === e && r.to === e; var l = n(r.from, 0); var c = n(r.to, o - 1); if (l > c) { if (h) { l -= o } else { var f = l; l = c, c = f } } if (/^(?:asymmetric|continuous)$/.test(s)) { var d = s === `asymmetric`; var _ = Math.min; var g = c - l + 1; var v = g - 1; var p = u ? _(g, 4) : 1; var m = p; var y = p; var w = []; if (h || (m = _(1, l), y = _(1, o - c - 1)), v += m + y, v <= 1) { return } for (var x = 0, b = l - m; x <= v; x++, b++) { w[x] = a[(b < 0 ? b + o : b) % o]._point } for (var C = w[0]._x + 2 * w[1]._x, S = w[0]._y + 2 * w[1]._y, k = 2, I = v - 1, P = [C], M = [S], T = [k], z = [], O = [], x = 1; x < v; x++) { var L = x < I; var E = L ? 1 : d ? 1 : 2; var N = L ? 4 : d ? 2 : 7; var B = L ? 4 : d ? 3 : 8; var F = L ? 2 : d ? 0 : 1; var j = E / k; k = T[x] = N - j, C = P[x] = B * w[x]._x + F * w[x + 1]._x - j * C, S = M[x] = B * w[x]._y + F * w[x + 1]._y - j * S }z[I] = P[I] / T[I], O[I] = M[I] / T[I]; for (var x = v - 2; x >= 0; x--) { z[x] = (P[x] - z[x + 1]) / T[x], O[x] = (M[x] - O[x + 1]) / T[x] }z[v] = (3 * w[v]._x - z[I]) / 2, O[v] = (3 * w[v]._y - O[I]) / 2; for (var x = m, D = v - y, b = l; x <= D; x++, b++) { var R = a[b < 0 ? b + o : b]; var q = R._point; var V = z[x] - q._x; var U = O[x] - q._y; (u || x < D) && R.setHandleOut(V, U), (u || x > m) && R.setHandleIn(-V, -U) } } else { for (var x = l; x <= c; x++) { a[x < 0 ? x + o : x].smooth(r, !u && x === l, !u && x === c) } } }, toShape: function (t) { function n (t, e) { var n = c[t]; var i = n.getNext(); var r = c[e]; var s = r.getNext(); return n._handleOut.isZero() && i._handleIn.isZero() && r._handleOut.isZero() && s._handleIn.isZero() && i._point.subtract(n._point).isCollinear(s._point.subtract(r._point)) } function i (t) { var e = c[t]; var n = e.getPrevious(); var i = e.getNext(); return n._handleOut.isZero() && e._handleIn.isZero() && e._handleOut.isZero() && i._handleIn.isZero() && e._point.subtract(n._point).isOrthogonal(i._point.subtract(e._point)) } function r (t) { var e = c[t]; var n = e.getNext(); var i = e._handleOut; var r = n._handleIn; var s = 0.5522847498307936; if (i.isOrthogonal(r)) { var a = e._point; var o = n._point; var h = new m(a, i, (!0)).intersect(new m(o, r, (!0)), !0); return h && u.isZero(i.getLength() / h.subtract(a).getLength() - s) && u.isZero(r.getLength() / h.subtract(o).getLength() - s) } return !1 } function s (t, e) { return c[t]._point.getDistance(c[e]._point) } if (!this._closed) { return null } var a; var o; var h; var l; var c = this._segments; if (!this.hasHandles() && c.length === 4 && n(0, 2) && n(1, 3) && i(1) ? (a = C.Rectangle, o = new d(s(0, 3), s(0, 1)), l = c[1]._point.add(c[2]._point).divide(2)) : c.length === 8 && r(0) && r(2) && r(4) && r(6) && n(1, 5) && n(3, 7) ? (a = C.Rectangle, o = new d(s(1, 6), s(0, 3)), h = o.subtract(new d(s(0, 7), s(1, 2))).divide(2), l = c[3]._point.add(c[4]._point).divide(2)) : c.length === 4 && r(0) && r(1) && r(2) && r(3) && (u.isZero(s(0, 2) - s(1, 3)) ? (a = C.Circle, h = s(0, 2) / 2) : (a = C.Ellipse, h = new d(s(2, 0) / 2, s(3, 1) / 2)), l = c[1]._point), a) { var f = this.getPosition(!0); var _ = new a({ center: f, size: o, radius: h, insert: !1 }); return _.copyAttributes(this, !0), _._matrix.prepend(this._matrix), _.rotate(l.subtract(f).getAngle() + 90), (t === e || t) && _.insertAbove(this), _ } return null }, toPath: `#clone`, compare: function yt (t) { if (!t || t instanceof E) { return yt.base.call(this, t) } var e = this.getCurves(); var n = t.getCurves(); var i = e.length; var r = n.length; if (!i || !r) { return i == r } for (var s, a, o = e[0].getValues(), h = [], u = 0, l = 0, c = 0; c < r; c++) { var f = n[c].getValues(); h.push(f); var d = A.getOverlaps(o, f); if (d) { s = !c && d[0][0] > 0 ? r - 1 : c, a = d[0][1]; break } } for (var _, g = Math.abs, v = 1e-8, f = h[s]; o && f;) { var d = A.getOverlaps(o, f); if (d) { var p = d[0][0]; if (g(p - l) < v) { l = d[1][0], l === 1 && (o = ++u < i ? e[u].getValues() : null, l = 0); var m = d[0][1]; if (g(m - a) < v) { if (_ || (_ = [s, m]), a = d[1][1], a === 1 && (++s >= r && (s = 0), f = h[s] || n[s].getValues(), a = 0), !o) { return _[0] === s && _[1] === a } continue } } } break } return !1 }, _hitTestSelf: function (t, e, n, i) { function r (e, n) { return t.subtract(e).divide(n).length <= 1 } function s (t, n, i) { if (!e.selected || n.isSelected()) { var s = t._point; if (n !== s && (n = n.add(s)), r(n, x)) { return new P(i, g, { segment: t, point: n }) } } } function a (t, n) { return (n || e.segments) && s(t, t._point, `segment`) || !n && e.handles && (s(t, t._handleIn, `handle-in`) || s(t, t._handleOut, `handle-out`)) } function o (t) { f.add(t) } function h (e) { var n = y || e._index > 0 && e._index < m - 1; if ((n ? u : l) === `round`) { return r(e._point, x) } if (f = new L({ internal: !0, closed: !0 }), n ? e.isSmooth() || L._addBevelJoin(e, u, k, c, null, i, o, !0) : l === `square` && L._addSquareCap(e, l, k, null, i, o, !0), !f.isEmpty()) { var s; return f.contains(t) || (s = f.getNearestLocation(t)) && r(s.getPoint(), w) } } var u; var l; var c; var f; var d; var _; var g = this; var v = this.getStyle(); var p = this._segments; var m = p.length; var y = this._closed; var w = e._tolerancePadding; var x = w; var b = e.stroke && v.hasStroke(); var C = e.fill && v.hasFill(); var S = e.curves; var k = b ? v.getStrokeWidth() / 2 : C && e.tolerance > 0 || S ? 0 : null; if (k !== null && (k > 0 ? (u = v.getStrokeJoin(), l = v.getStrokeCap(), c = v.getMiterLimit(), x = x.add(L._getStrokePadding(k, i))) : u = l = `round`), !e.ends || e.segments || y) { if (e.segments || e.handles) { for (var I = 0; I < m; I++) { if (_ = a(p[I])) { return _ } } } } else if (_ = a(p[0], !0) || a(p[m - 1], !0)) { return _ } if (k !== null) { if (d = this.getNearestLocation(t)) { var M = d.getTime(); M === 0 || M === 1 && m > 1 ? h(d.getSegment()) || (d = null) : r(d.getPoint(), x) || (d = null) } if (!d && u === `miter` && m > 1) { for (var I = 0; I < m; I++) { var T = p[I]; if (t.getDistance(T._point) <= c * k && h(T)) { d = T.getLocation(); break } } } } return !d && C && this._contains(t) || d && !b && !S ? new P(`fill`, this) : d ? new P(b ? `stroke` : `curve`, this, { location: d, point: d.getPoint() }) : null } }, r.each(A._evaluateMethods, function (t) { this[t + `At`] = function (e) { var n = this.getLocationAt(e); return n && n[t]() } }, { beans: !1, getLocationOf: function () { for (var t = c.read(arguments), e = this.getCurves(), n = 0, i = e.length; n < i; n++) { var r = e[n].getLocationOf(t); if (r) { return r } } return null }, getOffsetOf: function () { var t = this.getLocationOf.apply(this, arguments); return t ? t.getOffset() : null }, getLocationAt: function (t) { if (typeof t === `number`) { for (var e = this.getCurves(), n = 0, i = 0, r = e.length; i < r; i++) { var s = n; var a = e[i]; if (n += a.getLength(), n > t) { return a.getLocationAt(t - s) } } if (e.length > 0 && t <= this.getLength()) { return new z(e[e.length - 1], 1) } } else if (t && t.getPath && t.getPath() === this) { return t } return null }, getOffsetsWithTangent: function () { var t = c.read(arguments); if (t.isZero()) { return [] } for (var e = [], n = 0, i = this.getCurves(), r = 0, s = i.length; r < s; r++) { for (var a = i[r], o = a.getTimesWithTangent(t), h = 0, u = o.length; h < u; h++) { var l = n + a.getOffsetAtTime(o[h]); e.indexOf(l) < 0 && e.push(l) }n += a.length } return e } }), new function () { function t (t, e, n, i) { function r (e) { var n = h[e]; var i = h[e + 1]; s == n && a == i || (t.beginPath(), t.moveTo(s, a), t.lineTo(n, i), t.stroke(), t.beginPath(), t.arc(n, i, o, 0, 2 * Math.PI, !0), t.fill()) } for (var s, a, o = i / 2, h = new Array(6), u = 0, l = e.length; u < l; u++) { var c = e[u]; var f = c._selection; if (c._transformCoordinates(n, h), s = h[0], a = h[1], 2 & f && r(2), 4 & f && r(4), t.fillRect(s - o, a - o, i, i), !(1 & f)) { var d = t.fillStyle; t.fillStyle = `#ffffff`, t.fillRect(s - o + 1, a - o + 1, i - 2, i - 2), t.fillStyle = d } } } function e (t, e, n) { function i (e) { if (n) { e._transformCoordinates(n, _), r = _[0], s = _[1] } else { var i = e._point; r = i._x, s = i._y } if (g) { t.moveTo(r, s), g = !1 } else { if (n) { h = _[2], u = _[3] } else { var f = e._handleIn; h = r + f._x, u = s + f._y }h === r && u === s && l === a && c === o ? t.lineTo(r, s) : t.bezierCurveTo(l, c, h, u, r, s) } if (a = r, o = s, n) { l = _[4], c = _[5] } else { var f = e._handleOut; l = a + f._x, c = o + f._y } } for (var r, s, a, o, h, u, l, c, f = e._segments, d = f.length, _ = new Array(6), g = !0, v = 0; v < d; v++) { i(f[v]) }e._closed && d > 0 && i(f[0]) } return { _draw: function (t, n, i, r) { function s (t) { return c[(t % f + f) % f] } var a = n.dontStart; var o = n.dontFinish || n.clip; var h = this.getStyle(); var u = h.hasFill(); var l = h.hasStroke(); var c = h.getDashArray(); var f = !rt.support.nativeDash && l && c && c.length; if (a || t.beginPath(), (u || l && !f || o) && (e(t, this, r), this._closed && t.closePath()), !o && (u || l) && (this._setStyles(t, n, i), u && (t.fill(h.getFillRule()), t.shadowColor = `rgba(0,0,0,0)`), l)) { if (f) { a || t.beginPath(); var d; var _ = new N(this, 0.25, 32, (!1), r); var g = _.length; var v = -h.getDashOffset(); var p = 0; for (v %= g; v > 0;) { v -= s(p--) + s(p--) } for (;v < g;) { d = v + s(p++), (v > 0 || d > 0) && _.drawPart(t, Math.max(v, 0), Math.max(d, 0)), v = d + s(p++) } }t.stroke() } }, _drawSelected: function (n, i) { n.beginPath(), e(n, this, i), n.stroke(), t(n, this._segments, i, rt.settings.handleSize) } } }(), new function () {
    function t (t) { var e = t._segments; if (!e.length) { throw new Error(`Use a moveTo() command first`) } return e[e.length - 1] } return { moveTo: function () { var t = this._segments; t.length === 1 && this.removeSegment(0), t.length || this._add([new M(c.read(arguments))]) },
      moveBy: function () { throw new Error(`moveBy() is unsupported on Path items.`) },
      lineTo: function () { this._add([new M(c.read(arguments))]) },
      cubicCurveTo: function () { var e = c.read(arguments); var n = c.read(arguments); var i = c.read(arguments); var r = t(this); r.setHandleOut(e.subtract(r._point)), this._add([new M(i, n.subtract(i))]) },
      quadraticCurveTo: function () { var e = c.read(arguments); var n = c.read(arguments); var i = t(this)._point; this.cubicCurveTo(e.add(i.subtract(e).multiply(1 / 3)), e.add(n.subtract(e).multiply(1 / 3)), n) },
      curveTo: function () { var e = c.read(arguments); var n = c.read(arguments); var i = r.pick(r.read(arguments), 0.5); var s = 1 - i; var a = t(this)._point; var o = e.subtract(a.multiply(s * s)).subtract(n.multiply(i * i)).divide(2 * i * s); if (o.isNaN()) { throw new Error(`Cannot put a curve through points with parameter = ` + i) } this.quadraticCurveTo(o, n) },
      arcTo: function () {
        var e; var n; var i; var s; var a; var o = Math.abs; var h = Math.sqrt; var l = t(this); var f = l._point; var _ = c.read(arguments); var g = r.peek(arguments); var v = r.pick(g, !0); if (typeof v === `boolean`) { var y = f.add(_).divide(2); var e = y.add(y.subtract(f).rotate(v ? -90 : 90)) } else if (r.remain(arguments) <= 2) {
          e = _,
          _ = c.read(arguments)
        } else { var w = d.read(arguments); var x = u.isZero; if (x(w.width) || x(w.height)) { return this.lineTo(_) } var b = r.read(arguments); var v = !!r.read(arguments); var C = !!r.read(arguments); var y = f.add(_).divide(2); var S = f.subtract(y).rotate(-b); var k = S.x; var I = S.y; var P = o(w.width); var T = o(w.height); var A = P * P; var z = T * T; var O = k * k; var L = I * I; var E = h(O / A + L / z); if (E > 1 && (P *= E, T *= E, A = P * P, z = T * T), E = (A * z - A * L - z * O) / (A * L + z * O), o(E) < 1e-12 && (E = 0), E < 0) { throw new Error(`Cannot create an arc with the given arguments`) }n = new c(P * I / T, -T * k / P).multiply((C === v ? -1 : 1) * h(E)).rotate(b).add(y), a = (new p()).translate(n).rotate(b).scale(P, T), s = a._inverseTransform(f), i = s.getDirectedAngle(a._inverseTransform(_)), !v && i > 0 ? i -= 360 : v && i < 0 && (i += 360) } if (e) { var N = new m(f.add(e).divide(2), e.subtract(f).rotate(90), (!0)); var B = new m(e.add(_).divide(2), _.subtract(e).rotate(90), (!0)); var F = new m(f, _); var j = F.getSide(e); if (n = N.intersect(B, !0), !n) { if (!j) { return this.lineTo(_) } throw new Error(`Cannot create an arc with the given arguments`) }s = f.subtract(n), i = s.getDirectedAngle(_.subtract(n)); var D = F.getSide(n, !0); D === 0 ? i = j * o(i) : j === D && (i += i < 0 ? 360 : -360) } for (var R = 1e-7, q = o(i), V = q >= 360 ? 4 : Math.ceil((q - R) / 90), U = i / V, H = U * Math.PI / 360, Z = 4 / 3 * Math.sin(H) / (1 + Math.cos(H)), W = [], $ = 0; $ <= V; $++) { var S = _; var G = null; if ($ < V && (G = s.rotate(90).multiply(Z), a ? (S = a._transformPoint(s), G = a._transformPoint(s.add(G)).subtract(S)) : S = n.add(s)), $) { var J = s.rotate(-90).multiply(Z); a && (J = a._transformPoint(s.add(J)).subtract(S)), W.push(new M(S, J, G)) } else { l.setHandleOut(G) }s = s.rotate(U) } this._add(W)
      },
      lineBy: function () { var e = c.read(arguments); var n = t(this)._point; this.lineTo(n.add(e)) },
      curveBy: function () { var e = c.read(arguments); var n = c.read(arguments); var i = r.read(arguments); var s = t(this)._point; this.curveTo(s.add(e), s.add(n), i) },
      cubicCurveBy: function () { var e = c.read(arguments); var n = c.read(arguments); var i = c.read(arguments); var r = t(this)._point; this.cubicCurveTo(r.add(e), r.add(n), r.add(i)) },
      quadraticCurveBy: function () { var e = c.read(arguments); var n = c.read(arguments); var i = t(this)._point; this.quadraticCurveTo(i.add(e), i.add(n)) },
      arcBy: function () { var e = t(this)._point; var n = e.add(c.read(arguments)); var i = r.pick(r.peek(arguments), !0); typeof i === `boolean` ? this.arcTo(n, i) : this.arcTo(n, e.add(c.read(arguments))) },
      closePath: function (t) { this.setClosed(!0), this.join(this, t) } }
  }(), { _getBounds: function (t, e) { var n = e.handle ? `getHandleBounds` : e.stroke ? `getStrokeBounds` : `getBounds`; return L[n](this._segments, this._closed, this, t, e) }, statics: { getBounds: function (t, e, n, i, r, s) { function a (t) { t._transformCoordinates(i, h); for (var e = 0; e < 2; e++) { A._addBounds(u[e], u[e + 4], h[e + 2], h[e], e, s ? s[e] : 0, l, c, f) } var n = u; u = h, h = n } var o = t[0]; if (!o) { return new g() } for (var h = new Array(6), u = o._transformCoordinates(i, new Array(6)), l = u.slice(0, 2), c = l.slice(), f = new Array(2), d = 1, _ = t.length; d < _; d++) { a(t[d]) } return e && a(o), new g(l[0], l[1], c[0] - l[0], c[1] - l[1]) }, getStrokeBounds: function (t, e, n, i, r) { function s (t) { v = v.include(t) } function a (t) { v = v.unite(x.setCenter(t._point.transform(i))) } function o (t, e) { e === `round` || t.isSmooth() ? a(t) : L._addBevelJoin(t, e, p, w, i, f, s) } function h (t, e) { e === `round` ? a(t) : L._addSquareCap(t, e, p, i, f, s) } var u = n.getStyle(); var l = u.hasStroke(); var c = u.getStrokeWidth(); var f = l && n._getStrokeMatrix(i, r); var _ = l && L._getStrokePadding(c, f); var v = L.getBounds(t, e, n, i, r, _); if (!l) { return v } for (var p = c / 2, m = u.getStrokeJoin(), y = u.getStrokeCap(), w = u.getMiterLimit(), x = new g(new d(_)), b = t.length - (e ? 0 : 1), C = 1; C < b; C++) { o(t[C], m) } return e ? o(t[0], m) : b > 0 && (h(t[0], y), h(t[t.length - 1], y)), v }, _getStrokePadding: function (t, e) { if (!e) { return [t, t] } var n = new c(t, 0).transform(e); var i = new c(0, t).transform(e); var r = n.getAngleInRadians(); var s = n.getLength(); var a = i.getLength(); var o = Math.sin(r); var h = Math.cos(r); var u = Math.tan(r); var l = Math.atan2(a * u, s); var f = Math.atan2(a, u * s); return [Math.abs(s * Math.cos(l) * h + a * Math.sin(l) * o), Math.abs(a * Math.sin(f) * h + s * Math.cos(f) * o)] }, _addBevelJoin: function (t, e, n, i, r, s, a, o) { var h = t.getCurve(); var u = h.getPrevious(); var l = h.getPoint1().transform(r); var f = u.getNormalAtTime(1).multiply(n).transform(s); var d = h.getNormalAtTime(0).multiply(n).transform(s); if (f.getDirectedAngle(d) < 0 && (f = f.negate(), d = d.negate()), o && a(l), a(l.add(f)), e === `miter`) { var _ = new m(l.add(f), new c((-f.y), f.x), (!0)).intersect(new m(l.add(d), new c((-d.y), d.x), (!0)), !0); _ && l.getDistance(_) <= i * n && a(_) }a(l.add(d)) }, _addSquareCap: function (t, e, n, i, r, s, a) { var o = t._point.transform(i); var h = t.getLocation(); var u = h.getNormal().multiply(h.getTime() === 0 ? n : -n).transform(r); e === `square` && (a && (s(o.subtract(u)), s(o.add(u))), o = o.add(u.rotate(-90))), s(o.add(u)), s(o.subtract(u)) }, getHandleBounds: function (t, e, n, i, r) { var s; var a; var o = n.getStyle(); var h = r.stroke && o.hasStroke(); if (h) { var u = n._getStrokeMatrix(i, r); var l = o.getStrokeWidth() / 2; var c = l; o.getStrokeJoin() === `miter` && (c = l * o.getMiterLimit()), o.getStrokeCap() === `square` && (c = Math.max(c, l * Math.SQRT2)), s = L._getStrokePadding(l, u), a = L._getStrokePadding(c, u) } for (var f = new Array(6), d = 1 / 0, _ = -d, v = d, p = _, m = 0, y = t.length; m < y; m++) { var w = t[m]; w._transformCoordinates(i, f); for (var x = 0; x < 6; x += 2) { var b = x ? s : a; var C = b ? b[0] : 0; var S = b ? b[1] : 0; var k = f[x]; var I = f[x + 1]; var P = k - C; var M = k + C; var T = I - S; var A = I + S; P < d && (d = P), M > _ && (_ = M), T < v && (v = T), A > p && (p = A) } } return new g(d, v, _ - d, p - v) } } }); L.inject({ statics: new function () { function t (t, e, n) { var i = r.getNamed(n); var s = new L(i && i.insert == 0 && w.NO_INSERT); return s._add(t), s._closed = e, s.set(i, { insert: !0 }) } function e (e, n, r) { for (var s = new Array(4), a = 0; a < 4; a++) { var o = i[a]; s[a] = new M(o._point.multiply(n).add(e), o._handleIn.multiply(n), o._handleOut.multiply(n)) } return t(s, !0, r) } var n = 0.5522847498307936; var i = [new M([-1, 0], [0, n], [0, -n]), new M([0, -1], [-n, 0], [n, 0]), new M([1, 0], [0, -n], [0, n]), new M([0, 1], [n, 0], [-n, 0])]; return { Line: function () { return t([new M(c.readNamed(arguments, `from`)), new M(c.readNamed(arguments, `to`))], !1, arguments) }, Circle: function () { var t = c.readNamed(arguments, `center`); var n = r.readNamed(arguments, `radius`); return e(t, new d(n), arguments) }, Rectangle: function () { var e; var i = g.readNamed(arguments, `rectangle`); var r = d.readNamed(arguments, `radius`, 0, { readNull: !0 }); var s = i.getBottomLeft(!0); var a = i.getTopLeft(!0); var o = i.getTopRight(!0); var h = i.getBottomRight(!0); if (!r || r.isZero()) { e = [new M(s), new M(a), new M(o), new M(h)] } else { r = d.min(r, i.getSize(!0).divide(2)); var u = r.width; var l = r.height; var c = u * n; var f = l * n; e = [new M(s.add(u, 0), null, [-c, 0]), new M(s.subtract(0, l), [0, f]), new M(a.add(0, l), null, [0, -f]), new M(a.add(u, 0), [-c, 0], null), new M(o.subtract(u, 0), null, [c, 0]), new M(o.add(0, l), [0, -f], null), new M(h.subtract(0, l), null, [0, f]), new M(h.subtract(u, 0), [c, 0])] } return t(e, !0, arguments) }, RoundRectangle: `#Rectangle`, Ellipse: function () { var t = C._readEllipse(arguments); return e(t.center, t.radius, arguments) }, Oval: `#Ellipse`, Arc: function () { var t = c.readNamed(arguments, `from`); var e = c.readNamed(arguments, `through`); var n = c.readNamed(arguments, `to`); var i = r.getNamed(arguments); var s = new L(i && i.insert == 0 && w.NO_INSERT); return s.moveTo(t), s.arcTo(e, n), s.set(i) }, RegularPolygon: function () { for (var e = c.readNamed(arguments, `center`), n = r.readNamed(arguments, `sides`), i = r.readNamed(arguments, `radius`), s = 360 / n, a = n % 3 === 0, o = new c(0, a ? -i : i), h = a ? -1 : 0.5, u = new Array(n), l = 0; l < n; l++) { u[l] = new M(e.add(o.rotate((l + h) * s))) } return t(u, !0, arguments) }, Star: function () { for (var e = c.readNamed(arguments, `center`), n = 2 * r.readNamed(arguments, `points`), i = r.readNamed(arguments, `radius1`), s = r.readNamed(arguments, `radius2`), a = 360 / n, o = new c(0, (-1)), h = new Array(n), u = 0; u < n; u++) { h[u] = new M(e.add(o.rotate(a * u).multiply(u % 2 ? s : i))) } return t(h, !0, arguments) } } }() }); var E = O.extend({ _class: `CompoundPath`, _serializeFields: { children: [] }, beans: !0, initialize: function (t) { this._children = [], this._namedChildren = {}, this._initialize(t) || (typeof t === `string` ? this.setPathData(t) : this.addChildren(Array.isArray(t) ? t : arguments)) }, insertChildren: function wt (t, e) { var n = e; var i = n[0]; i && typeof i[0] === `number` && (n = [n]); for (var s = e.length - 1; s >= 0; s--) { var a = n[s]; n !== e || a instanceof L || (n = r.slice(n)), Array.isArray(a) ? n[s] = new L({ segments: a, insert: !1 }) : a instanceof E && (n.splice.apply(n, [s, 1].concat(a.removeChildren())), a.remove()) } return wt.base.call(this, t, n) }, reduce: function xt (t) { for (var e = this._children, n = e.length - 1; n >= 0; n--) { var i = e[n].reduce(t); i.isEmpty() && i.remove() } if (!e.length) { var i = new L(w.NO_INSERT); return i.copyAttributes(this), i.insertAbove(this), this.remove(), i } return xt.base.call(this) }, isClosed: function () { for (var t = this._children, e = 0, n = t.length; e < n; e++) { if (!t[e]._closed) { return !1 } } return !0 }, setClosed: function (t) { for (var e = this._children, n = 0, i = e.length; n < i; n++) { e[n].setClosed(t) } }, getFirstSegment: function () { var t = this.getFirstChild(); return t && t.getFirstSegment() }, getLastSegment: function () { var t = this.getLastChild(); return t && t.getLastSegment() }, getCurves: function () { for (var t = this._children, e = [], n = 0, i = t.length; n < i; n++) { r.push(e, t[n].getCurves()) } return e }, getFirstCurve: function () { var t = this.getFirstChild(); return t && t.getFirstCurve() }, getLastCurve: function () { var t = this.getLastChild(); return t && t.getLastCurve() }, getArea: function () { for (var t = this._children, e = 0, n = 0, i = t.length; n < i; n++) { e += t[n].getArea() } return e }, getLength: function () { for (var t = this._children, e = 0, n = 0, i = t.length; n < i; n++) { e += t[n].getLength() } return e }, getPathData: function (t, e) { for (var n = this._children, i = [], r = 0, s = n.length; r < s; r++) { var a = n[r]; var o = a._matrix; i.push(a.getPathData(t && !o.isIdentity() ? t.appended(o) : t, e)) } return i.join(``) }, _hitTestChildren: function bt (t, e, n) { return bt.base.call(this, t, e[`class`] === L || e.type === `path` ? e : r.set({}, e, { fill: !1 }), n) }, _draw: function (t, e, n, i) { var r = this._children; if (r.length) { e = e.extend({ dontStart: !0, dontFinish: !0 }), t.beginPath(); for (var s = 0, a = r.length; s < a; s++) { r[s].draw(t, e, i) } if (!e.clip) { this._setStyles(t, e, n); var o = this._style; o.hasFill() && (t.fill(o.getFillRule()), t.shadowColor = `rgba(0,0,0,0)`), o.hasStroke() && t.stroke() } } }, _drawSelected: function (t, e, n) { for (var i = this._children, r = 0, s = i.length; r < s; r++) { var a = i[r]; var o = a._matrix; n[a._id] || a._drawSelected(t, o.isIdentity() ? e : e.appended(o)) } } }, new function () { function t (t, e) { var n = t._children; if (e && !n.length) { throw new Error(`Use a moveTo() command first`) } return n[n.length - 1] } return r.each([`lineTo`, `cubicCurveTo`, `quadraticCurveTo`, `curveTo`, `arcTo`, `lineBy`, `cubicCurveBy`, `quadraticCurveBy`, `curveBy`, `arcBy`], function (e) { this[e] = function () { var n = t(this, !0); n[e].apply(n, arguments) } }, { moveTo: function () { var e = t(this); var n = e && e.isEmpty() ? e : new L(w.NO_INSERT); n !== e && this.addChild(n), n.moveTo.apply(n, arguments) }, moveBy: function () { var e = t(this, !0); var n = e && e.getLastSegment(); var i = c.read(arguments); this.moveTo(n ? i.add(n._point) : i) }, closePath: function (e) { t(this, !0).closePath(e) } }) }(), r.each([`reverse`, `flatten`, `simplify`, `smooth`], function (t) { this[t] = function (e) { for (var n, i = this._children, r = 0, s = i.length; r < s; r++) { n = i[r][t](e) || n } return n } }, {})); O.inject(new function () { function t (t, e) { var n = t.clone(!1).reduce({ simplify: !0 }).transform(null, !0, !0); return e ? n.resolveCrossings().reorient(n.getFillRule() === `nonzero`, !0) : n } function n (t, e, n, i, r) { var s = new E(w.NO_INSERT); return s.addChildren(t, !0), s = s.reduce({ simplify: e }), r && r.insert == 0 || s.insertAbove(i && n.isSibling(i) && n.getIndex() < i.getIndex() ? i : n), s.copyAttributes(n, !0), s } function i (e, i, a, o) { function u (t) { for (var e = 0, n = t.length; e < n; e++) { var i = t[e]; r.push(x, i._segments), r.push(b, i.getCurves()), i._overlapsOnly = !0 } } if (o && (o.trace == 0 || o.stroke) && /^(subtract|intersect)$/.test(a)) { return s(e, i, a) } var c = t(e, !0); var _ = i && e !== i && t(i, !0); var g = p[a]; g[a] = !0, _ && (g.subtract || g.exclude) ^ (_.isClockwise() ^ c.isClockwise()) && _.reverse(); var v; var m = l(z.expand(c.getCrossings(_))); var y = c._children || [c]; var w = _ && (_._children || [_]); var x = []; var b = []; if (m.length) { u(y), w && u(w); for (var C = 0, S = m.length; C < S; C++) { f(m[C]._segment, c, _, b, g) } for (var C = 0, S = x.length; C < S; C++) { var k = x[C]; var I = k._intersection; k._winding || f(k, c, _, b, g), I && I._overlap || (k._path._overlapsOnly = !1) }v = d(x, g) } else { v = h(w ? y.concat(w) : y.slice(), (t) => { return !!g[t] }) } return n(v, !0, e, i, o) } function s (e, i, r) { function s (t) { if (!c[t._id] && (l || o.contains(t.getPointAt(t.getLength() / 2)) ^ u)) { return f.unshift(t), c[t._id] = !0 } } for (var a = t(e), o = t(i), h = a.getCrossings(o), u = r === `subtract`, l = r === `divide`, c = {}, f = [], d = h.length - 1; d >= 0; d--) { var _ = h[d].split(); _ && (s(_) && _.getFirstSegment().setHandleIn(0, 0), a.getLastSegment().setHandleOut(0, 0)) } return s(a), n(f, !1, e, i) } function a (t, e) { for (var n = t; n;) { if (n === e) { return }n = n._previous } for (;t._next && t._next !== e;) { t = t._next } if (!t._next) { for (;e._previous;) { e = e._previous }t._next = e, e._previous = t } } function o (t) { for (var e = t.length - 1; e >= 0; e--) { t[e].clearHandles() } } function h (t, e, n) { var i = t && t.length; if (i) { var s = r.each(t, function (t, e) { this[t._id] = { container: null, winding: t.isClockwise() ? 1 : -1, index: e } }, {}); var a = t.slice().sort((t, e) => { return v(e.getArea()) - v(t.getArea()) }); var o = a[0]; n == null && (n = o.isClockwise()); for (var h = 0; h < i; h++) { for (var u = a[h], l = s[u._id], c = u.getInteriorPoint(), f = 0, d = h - 1; d >= 0; d--) { var _ = a[d]; if (_.contains(c)) { var g = s[_._id]; f = g.winding, l.winding += f, l.container = g.exclude ? g.container : _; break } } if (e(l.winding) === e(f)) { l.exclude = !0, t[l.index] = null } else { var p = l.container; u.setClockwise(p ? !p.isClockwise() : n) } } } return t } function l (t, e, n) { function i (t) { return t._path._id + `.` + t._segment1._index } for (var r, s, h, u = e && [], l = 1e-8, c = 1 - l, f = !1, d = n || [], _ = n && {}, g = (n && n.length) - 1; g >= 0; g--) { var v = n[g]; v._path && (_[i(v)] = !0) } for (var g = t.length - 1; g >= 0; g--) { var p; var m = t[g]; var y = m._time; var w = y; var x = e && !e(m); var v = m._curve; if (v && (v !== s ? (f = !v.hasHandles() || _ && _[i(v)], r = [], h = null, s = v) : h >= l && (y /= h)), x) { r && r.push(m) } else { if (e && u.unshift(m), h = w, y < l) { p = v._segment1 } else if (y > c) { p = v._segment2 } else { var b = v.divideAtTime(y, !0); f && d.push(v, b), p = b._segment1; for (var C = r.length - 1; C >= 0; C--) { var S = r[C]; S._time = (S._time - y) / (1 - y) } }m._setSegment(p); var k = p._intersection; var I = m._intersection; if (k) { a(k, I); for (var P = k; P;) { a(P._intersection, k), P = P._next } } else { p._intersection = I } } } return n || o(d), u || t } function c (t, e, n, i, r) { function s (s) { var a = s[l + 0]; var h = s[l + 6]; if (!(p < _(a, h) || p > g(a, h))) { var f = s[u + 0]; var v = s[u + 2]; var m = s[u + 4]; var b = s[u + 6]; if (a === h) { return void ((f < x && b > w || b < x && f > w) && (I = !0)) } var C = p === a ? 0 : p === h ? 1 : w > g(f, v, m, b) || x < _(f, v, m, b) ? 1 : A.solveCubic(s, l, p, T, 0, 1) > 0 ? T[0] : 1; var P = C === 0 ? f : C === 1 ? b : A.getPoint(s, C)[n ? `y` : `x`]; var z = a > h ? 1 : -1; var O = o[l] > o[l + 6] ? 1 : -1; var L = o[u + 6]; return p !== a ? (P < w ? S += z : P > x ? k += z : I = !0, P > d - y && P < d + y && (M /= 2)) : (z !== O ? f < w ? S += z : f > x && (k += z) : f != L && (L < x && P > x ? (k += z, I = !0) : L > w && P < w && (S += z, I = !0)), M = 0), o = s, !r && P > w && P < x && A.getTangent(s, C)[n ? `x` : `y`] === 0 && c(t, e, !n, i, !0) } } function a (t) { var e = t[l + 0]; var i = t[l + 2]; var r = t[l + 4]; var a = t[l + 6]; if (p <= g(e, i, r, a) && p >= _(e, i, r, a)) { for (var o, h = t[u + 0], c = t[u + 2], f = t[u + 4], d = t[u + 6], v = w > g(h, c, f, d) || x < _(h, c, f, d) ? [t] : A.getMonoCurves(t, n), m = 0, y = v.length; m < y; m++) { if (o = s(v[m])) { return o } } } } for (var o, h, u = n ? 1 : 0, l = 1 ^ u, f = [t.x, t.y], d = f[u], p = f[l], m = 1e-9, y = 1e-6, w = d - m, x = d + m, b = 0, C = 0, S = 0, k = 0, I = !1, P = !1, M = 1, T = [], z = 0, O = e.length; z < O; z++) { var L; var E = e[z]; var N = E._path; var B = E.getValues(); if (!(z && e[z - 1]._path === N || (o = null, N._closed || (h = A.getValues(N.getLastCurve().getSegment2(), E.getSegment1(), null, !i), h[l] !== h[l + 6] && (o = h)), o))) { o = B; for (var F = N.getLastCurve(); F && F !== E;) { var j = F.getValues(); if (j[l] !== j[l + 6]) { o = j; break }F = F.getPrevious() } } if (L = a(B)) { return L } if (z + 1 === O || e[z + 1]._path !== N) { if (h && (L = a(h))) { return L }!I || S || k || (S = k = N.isClockwise(i) ^ n ? 1 : -1), b += S, C += k, S = k = 0, I && (P = !0, I = !1), h = null } } return b = v(b), C = v(C), { winding: g(b, C), windingL: b, windingR: C, quality: M, onPath: P } } function f (t, e, n, i, r) { var s; var a = []; var o = t; var h = 0; do { var l = t.getCurve(); var f = l.getLength(); a.push({ segment: t, curve: l, length: f }), h += f, t = t.getNext() } while (t && !t._intersection && t !== o);for (var d = [0.5, 0.25, 0.75], s = { winding: 0, quality: -1 }, _ = 1e-8, g = 1 - _, p = 0; p < d.length && s.quality < 0.5; p++) { for (var f = h * d[p], m = 0, y = a.length; m < y; m++) { var w = a[m]; var x = w.length; if (f <= x) { var l = w.curve; var b = l._path; var C = b._parent; var S = C instanceof E ? C : b; var k = u.clamp(l.getTimeAt(f), _, g); var I = l.getPointAtTime(k); var P = v(l.getTangentAtTime(k).y) < Math.SQRT1_2; var M = null; if (r.subtract && n) { var T = S === e ? n._getWinding(I, P, !0) : e._getWinding(I, P, !0); if (S === e && T.winding || S === n && !T.winding) { if (T.quality < 1) { continue }M = { winding: 0, quality: 1 } } }M = M || c(I, i, P, !0), M.quality > s.quality && (s = M); break }f -= x } } for (var m = a.length - 1; m >= 0; m--) { a[m].segment._winding = s } } function d (t, e) { function n (t) { var n; return !(!t || t._visited || e && (!e[(n = t._winding || {}).winding] || e.unite && n.winding === 2 && n.windingL && n.windingR)) } function i (t) { if (t) { for (var e = 0, n = a.length; e < n; e++) { if (t === a[e]) { return !0 } } } return !1 } function r (t) { for (var e = t._segments, n = 0, i = e.length; n < i; n++) { e[n]._visited = !0 } } function s (t, e) { function r (r, s) { for (;r && r !== s;) { var o = r._segment; var u = o && o._path; if (u) { var l = o.getNext() || u.getFirstSegment(); var c = l._intersection; o !== t && (i(o) || i(l) || l && n(o) && (n(l) || c && n(c._segment))) && h.push(o), e && a.push(o) }r = r._next } } var s = t._intersection; var o = s; var h = []; if (e && (a = [t]), s) { for (r(s); s && s._prev;) { s = s._prev }r(s, o) } return h } var a; var o = []; t.sort((t, e) => { var n = t._intersection; var i = e._intersection; var r = !(!n || !n._overlap); var s = !(!i || !i._overlap); var a = t._path; var o = e._path; return r ^ s ? r ? 1 : -1 : !n ^ !i ? n ? 1 : -1 : a !== o ? a._id - o._id : t._index - e._index }); for (var h = 0, u = t.length; h < u; h++) { var l; var c; var f; var d = t[h]; var _ = n(d); var g = null; var v = !1; var p = !0; var m = []; if (_ && d._path._overlapsOnly) { var y = d._path; var x = d._intersection._segment._path; y.compare(x) && (y.getArea() && o.push(y.clone(!1)), r(y), r(x), _ = !1) } for (;_;) { var b = !g; var C = s(d, b); var S = C.shift(); var v = !b && (i(d) || i(S)); var k = !v && S; if (b && (g = new L(w.NO_INSERT), l = null), v) { (d.isFirst() || d.isLast()) && (p = d._path._closed), d._visited = !0; break } if (k && l && (m.push(l), l = null), l || (k && C.push(d), l = { start: g._segments.length, crossings: C, visited: c = [], handleIn: f }), k && (d = S), !n(d)) { g.removeSegments(l.start); for (var I = 0, P = c.length; I < P; I++) { c[I]._visited = !1 }c.length = 0; do { d = l && l.crossings.shift(), d && d._path || (d = null, l = m.pop(), l && (c = l.visited, f = l.handleIn)) } while (l && !n(d));if (!d) { break } } var T = d.getNext(); g.add(new M(d._point, f, T && d._handleOut)), d._visited = !0, c.push(d), d = T || d._path.getFirstSegment(), f = T && T._handleIn }v && (p && (g.getFirstSegment().setHandleIn(f), g.setClosed(p)), g.getArea() !== 0 && o.push(g)) } return o } var _ = Math.min; var g = Math.max; var v = Math.abs; var p = { unite: { 1: !0, 2: !0 }, intersect: { 2: !0 }, subtract: { 1: !0 }, exclude: { 1: !0, '-1': !0 } }; return { _getWinding: function (t, e, n) { return c(t, this.getCurves(), e, n) }, unite: function (t, e) { return i(this, t, `unite`, e) }, intersect: function (t, e) { return i(this, t, `intersect`, e) }, subtract: function (t, e) { return i(this, t, `subtract`, e) }, exclude: function (t, e) { return i(this, t, `exclude`, e) }, divide: function (t, e) { return e && (e.trace == 0 || e.stroke) ? s(this, t, `divide`) : n([this.subtract(t, e), this.intersect(t, e)], !0, this, t, e) }, resolveCrossings: function () { function t (t, e) { var n = t && t._intersection; return n && n._overlap && n._path === e } var e = this._children; var n = e || [this]; var i = !1; var s = !1; var a = this.getIntersections(null, (t) => { return t.hasOverlap() && (i = !0) || t.isCrossing() && (s = !0) }); var h = i && s && []; if (a = z.expand(a), i) { for (var u = l(a, (t) => { return t.hasOverlap() }, h), c = u.length - 1; c >= 0; c--) { var f = u[c]; var _ = f._path; var g = f._segment; var v = g.getPrevious(); var p = g.getNext(); t(v, _) && t(p, _) && (g.remove(), v._handleOut._set(0, 0), p._handleIn._set(0, 0), v === g || v.getCurve().hasLength() || (p._handleIn.set(v._handleIn), v.remove())) } }s && (l(a, i && ((t) => { var e = t.getCurve(); var n = t.getSegment(); var i = t._intersection; var r = i._curve; var s = i._segment; return !!(e && r && e._path && r._path) || (n && (n._intersection = null), void (s && (s._intersection = null))) }), h), h && o(h), n = d(r.each(n, function (t) { r.push(this, t._segments) }, []))); var m; var y = n.length; return y > 1 && e ? (n !== e && this.setChildren(n), m = this) : y !== 1 || e || (n[0] !== this && this.setSegments(n[0].removeSegments()), m = this), m || (m = new E(w.NO_INSERT), m.addChildren(n), m = m.reduce(), m.copyAttributes(this), this.replaceWith(m)), m }, reorient: function (t, n) { var i = this._children; return i && i.length ? this.setChildren(h(this.removeChildren(), (e) => { return !!(t ? e : 1 & e) }, n)) : n !== e && this.setClockwise(n), this }, getInteriorPoint: function () { var t = this.getBounds(); var e = t.getCenter(!0); if (!this.contains(e)) { for (var n = this.getCurves(), i = e.y, r = [], s = [], a = 0, o = n.length; a < o; a++) { var h = n[a].getValues(); var u = h[1]; var l = h[3]; var c = h[5]; var f = h[7]; if (i >= _(u, l, c, f) && i <= g(u, l, c, f)) { for (var d = A.getMonoCurves(h), v = 0, p = d.length; v < p; v++) { var m = d[v]; var y = m[1]; var w = m[7]; if (y !== w && (i >= y && i <= w || i >= w && i <= y)) { var x = i === y ? m[0] : i === w ? m[6] : A.solveCubic(m, 1, i, s, 0, 1) === 1 ? A.getPoint(m, s[0]).x : (m[0] + m[6]) / 2; r.push(x) } } } }r.length > 1 && (r.sort((t, e) => { return t - e }), e.x = (r[0] + r[1]) / 2) } return e } } }()); var N = r.extend({ _class: `PathFlattener`, initialize: function (t, e, n, i, r) { function s (t, e) { var n = A.getValues(t, e, r); h.push(n), a(n, t._index, 0, 1) } function a (t, n, r, s) { if (!(s - r > c) || i && A.isStraight(t) || A.isFlatEnough(t, e || 0.25)) { var o = t[6] - t[0]; var h = t[7] - t[1]; var f = Math.sqrt(o * o + h * h); f > 0 && (l += f, u.push({ offset: l, curve: t, index: n, time: s })) } else { var d = A.subdivide(t, 0.5); var _ = (r + s) / 2; a(d[0], n, r, _), a(d[1], n, _, s) } } for (var o, h = [], u = [], l = 0, c = 1 / (n || 32), f = t._segments, d = f[0], _ = 1, g = f.length; _ < g; _++) { o = f[_], s(d, o), d = o }t._closed && s(o || d, f[0]), this.curves = h, this.parts = u, this.length = l, this.index = 0 }, _get: function (t) { for (var e, n = this.parts, i = n.length, r = this.index; e = r, r && !(n[--r].offset < t);) {} for (;e < i; e++) { var s = n[e]; if (s.offset >= t) { this.index = e; var a = n[e - 1]; var o = a && a.index === s.index ? a.time : 0; var h = a ? a.offset : 0; return { index: s.index, time: o + (s.time - o) * (t - h) / (s.offset - h) } } } return { index: n[i - 1].index, time: 1 } }, drawPart: function (t, e, n) { for (var i = this._get(e), r = this._get(n), s = i.index, a = r.index; s <= a; s++) { var o = A.getPart(this.curves[s], s === i.index ? i.time : 0, s === r.index ? r.time : 1); s === i.index && t.moveTo(o[0], o[1]), t.bezierCurveTo.apply(t, o.slice(2)) } } }, r.each(A._evaluateMethods, function (t) { this[t + `At`] = function (e) { var n = this._get(e); return A[t](this.curves[n.index], n.time) } }, {})); var B = r.extend({ initialize: function (t) { for (var e, n = this.points = [], i = t._segments, r = t._closed, s = 0, a = i.length; s < a; s++) { var o = i[s].point; e && e.equals(o) || n.push(e = o.clone()) }r && (n.unshift(n[n.length - 1]), n.push(n[1])), this.closed = r }, fit: function (t) { var e = this.points; var n = e.length; var i = null; return n > 0 && (i = [new M(e[0])], n > 1 && (this.fitCubic(i, t, 0, n - 1, e[1].subtract(e[0]), e[n - 2].subtract(e[n - 1])), this.closed && (i.shift(), i.pop()))), i }, fitCubic: function (t, e, n, i, r, s) { var a = this.points; if (i - n === 1) { var o = a[n]; var h = a[i]; var u = o.getDistance(h) / 3; return void this.addCurve(t, [o, o.add(r.normalize(u)), h.add(s.normalize(u)), h]) } for (var l, c = this.chordLengthParameterize(n, i), f = Math.max(e, e * e), d = !0, _ = 0; _ <= 4; _++) { var g = this.generateBezier(n, i, c, r, s); var v = this.findMaxError(n, i, g, c); if (v.error < e && d) { return void this.addCurve(t, g) } if (l = v.index, v.error >= f) { break }d = this.reparameterize(n, i, c, g), f = v.error } var p = a[l - 1].subtract(a[l + 1]); this.fitCubic(t, e, n, l, r, p), this.fitCubic(t, e, l, i, p.negate(), s) }, addCurve: function (t, e) { var n = t[t.length - 1]; n.setHandleOut(e[1].subtract(e[0])), t.push(new M(e[3], e[2].subtract(e[3]))) }, generateBezier: function (t, e, n, i, r) { for (var s = 1e-12, a = Math.abs, o = this.points, h = o[t], u = o[e], l = [[0, 0], [0, 0]], c = [0, 0], f = 0, d = e - t + 1; f < d; f++) { var _ = n[f]; var g = 1 - _; var v = 3 * _ * g; var p = g * g * g; var m = v * g; var y = v * _; var w = _ * _ * _; var x = i.normalize(m); var b = r.normalize(y); var C = o[t + f].subtract(h.multiply(p + m)).subtract(u.multiply(y + w)); l[0][0] += x.dot(x), l[0][1] += x.dot(b), l[1][0] = l[0][1], l[1][1] += b.dot(b), c[0] += x.dot(C), c[1] += b.dot(C) } var S; var k; var I = l[0][0] * l[1][1] - l[1][0] * l[0][1]; if (a(I) > s) { var P = l[0][0] * c[1] - l[1][0] * c[0]; var M = c[0] * l[1][1] - c[1] * l[0][1]; S = M / I, k = P / I } else { var T = l[0][0] + l[0][1]; var A = l[1][0] + l[1][1]; S = k = a(T) > s ? c[0] / T : a(A) > s ? c[1] / A : 0 } var z; var O; var L = u.getDistance(h); var E = s * L; if (S < E || k < E) { S = k = L / 3 } else { var N = u.subtract(h); z = i.normalize(S), O = r.normalize(k), z.dot(N) - O.dot(N) > L * L && (S = k = L / 3, z = O = null) } return [h, h.add(z || i.normalize(S)), u.add(O || r.normalize(k)), u] }, reparameterize: function (t, e, n, i) { for (var r = t; r <= e; r++) { n[r - t] = this.findRoot(i, this.points[r], n[r - t]) } for (var r = 1, s = n.length; r < s; r++) { if (n[r] <= n[r - 1]) { return !1 } } return !0 }, findRoot: function (t, e, n) { for (var i = [], r = [], s = 0; s <= 2; s++) { i[s] = t[s + 1].subtract(t[s]).multiply(3) } for (var s = 0; s <= 1; s++) { r[s] = i[s + 1].subtract(i[s]).multiply(2) } var a = this.evaluate(3, t, n); var o = this.evaluate(2, i, n); var h = this.evaluate(1, r, n); var l = a.subtract(e); var c = o.dot(o) + l.dot(h); return u.isZero(c) ? n : n - l.dot(o) / c }, evaluate: function (t, e, n) { for (var i = e.slice(), r = 1; r <= t; r++) { for (var s = 0; s <= t - r; s++) { i[s] = i[s].multiply(1 - n).add(i[s + 1].multiply(n)) } } return i[0] }, chordLengthParameterize: function (t, e) { for (var n = [0], i = t + 1; i <= e; i++) { n[i - t] = n[i - t - 1] + this.points[i].getDistance(this.points[i - 1]) } for (var i = 1, r = e - t; i <= r; i++) { n[i] /= n[r] } return n }, findMaxError: function (t, e, n, i) { for (var r = Math.floor((e - t + 1) / 2), s = 0, a = t + 1; a < e; a++) { var o = this.evaluate(3, n, i[a - t]); var h = o.subtract(this.points[a]); var u = h.x * h.x + h.y * h.y; u >= s && (s = u, r = a) } return { error: s, index: r } } }); var F = w.extend({ _class: `TextItem`, _applyMatrix: !1, _canApplyMatrix: !1, _serializeFields: { content: null }, _boundsOptions: { stroke: !1, handle: !1 }, initialize: function (t) { this._content = ``, this._lines = []; var n = t && r.isPlainObject(t) && t.x === e && t.y === e; this._initialize(n && t, !n && c.read(arguments)) }, _equals: function (t) { return this._content === t._content }, copyContent: function (t) { this.setContent(t._content) }, getContent: function () { return this._content }, setContent: function (t) { this._content = `` + t, this._lines = this._content.split(/\r\n|\n|\r/gm), this._changed(521) }, isEmpty: function () { return !this._content }, getCharacterStyle: `#getStyle`, setCharacterStyle: `#setStyle`, getParagraphStyle: `#getStyle`, setParagraphStyle: `#setStyle` }); var j = F.extend({ _class: `PointText`, initialize: function () { F.apply(this, arguments) }, getPoint: function () { var t = this._matrix.getTranslation(); return new f(t.x, t.y, this, `setPoint`) }, setPoint: function () { var t = c.read(arguments); this.translate(t.subtract(this._matrix.getTranslation())) }, _draw: function (t, e, n) { if (this._content) { this._setStyles(t, e, n); var i = this._lines; var r = this._style; var s = r.hasFill(); var a = r.hasStroke(); var o = r.getLeading(); var h = t.shadowColor; t.font = r.getFontStyle(), t.textAlign = r.getJustification(); for (var u = 0, l = i.length; u < l; u++) { t.shadowColor = h; var c = i[u]; s && (t.fillText(c, 0, 0), t.shadowColor = `rgba(0,0,0,0)`), a && t.strokeText(c, 0, 0), t.translate(0, o) } } }, _getBounds: function (t, e) { var n = this._style; var i = this._lines; var r = i.length; var s = n.getJustification(); var a = n.getLeading(); var o = this.getView().getTextWidth(n.getFontStyle(), i); var h = 0; s !== `left` && (h -= o / (s === `center` ? 2 : 1)); var u = new g(h, r ? -0.75 * a : 0, o, r * a); return t ? t._transformBounds(u, u) : u } }); var D = r.extend(new function () {
    function t (t) { var i; var r = t.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || t.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i); var s = `rgb`; if (r) { var o = r[4] ? 4 : 3; i = new Array(o); for (var h = 0; h < o; h++) { var u = r[h + 1]; i[h] = parseInt(u.length == 1 ? u + u : u, 16) / 255 } } else if (r = t.match(/^(rgb|hsl)a?\((.*)\)$/)) { s = r[1], i = r[2].split(/[,\s]+/g); for (var l = s === `hsl`, h = 0, c = Math.min(i.length, 4); h < c; h++) { var f = i[h]; var u = parseFloat(f); if (l) { if (h === 0) { var d = f.match(/([a-z]*)$/)[1]; u *= { turn: 360, rad: 180 / Math.PI, grad: 0.9 }[d] || 1 } else { h < 3 && (u /= 100) } } else { h < 3 && (u /= 255) }i[h] = u } } else { var _ = a[t]; if (!_) { if (n) { e || (e = tt.getContext(1, 1), e.globalCompositeOperation = `copy`), e.fillStyle = `rgba(0,0,0,0)`, e.fillStyle = t, e.fillRect(0, 0, 1, 1); var g = e.getImageData(0, 0, 1, 1).data; _ = a[t] = [g[0] / 255, g[1] / 255, g[2] / 255] } else { _ = [0, 0, 0] } }i = _.slice() } return [s, i] } var e; var i = { gray: [`gray`], rgb: [`red`, `green`, `blue`], hsb: [`hue`, `saturation`, `brightness`], hsl: [`hue`, `saturation`, `lightness`], gradient: [`gradient`, `origin`, `destination`, `highlight`] }; var s = {}; var a = { transparent: [0, 0, 0, 0] }; var o = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]]; var u = { 'rgb-hsb': function (t, e, n) { var i = Math.max(t, e, n); var r = Math.min(t, e, n); var s = i - r; var a = s === 0 ? 0 : 60 * (i == t ? (e - n) / s + (e < n ? 6 : 0) : i == e ? (n - t) / s + 2 : (t - e) / s + 4); return [a, i === 0 ? 0 : s / i, i] }, 'hsb-rgb': function (t, e, n) { t = (t / 60 % 6 + 6) % 6; var i = Math.floor(t); var r = t - i; var i = o[i]; var s = [n, n * (1 - e), n * (1 - e * r), n * (1 - e * (1 - r))]; return [s[i[0]], s[i[1]], s[i[2]]] }, 'rgb-hsl': function (t, e, n) { var i = Math.max(t, e, n); var r = Math.min(t, e, n); var s = i - r; var a = s === 0; var o = a ? 0 : 60 * (i == t ? (e - n) / s + (e < n ? 6 : 0) : i == e ? (n - t) / s + 2 : (t - e) / s + 4); var h = (i + r) / 2; var u = a ? 0 : h < 0.5 ? s / (i + r) : s / (2 - i - r); return [o, u, h] }, 'hsl-rgb': function (t, e, n) { if (t = (t / 360 % 1 + 1) % 1, e === 0) { return [n, n, n] } for (var i = [t + 1 / 3, t, t - 1 / 3], r = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - r, a = [], o = 0; o < 3; o++) { var h = i[o]; h < 0 && (h += 1), h > 1 && (h -= 1), a[o] = 6 * h < 1 ? s + 6 * (r - s) * h : 2 * h < 1 ? r : 3 * h < 2 ? s + (r - s) * (2 / 3 - h) * 6 : s } return a }, 'rgb-gray': function (t, e, n) { return [0.2989 * t + 0.587 * e + 0.114 * n] }, 'gray-rgb': function (t) { return [t, t, t] }, 'gray-hsb': function (t) { return [0, 0, t] }, 'gray-hsl': function (t) { return [0, 0, t] }, 'gradient-rgb': function () { return [] }, 'rgb-gradient': function () { return [] } }; return r.each(i, function (t, e) { s[e] = [], r.each(t, function (t, n) { var a = r.capitalize(t); var o = /^(hue|saturation)$/.test(t); var h = s[e][n] = e === `gradient` ? t === `gradient` ? function (t) { var e = this._components[0]; return t = R.read(Array.isArray(t) ? t : arguments, 0, { readNull: !0 }), e !== t && (e && e._removeOwner(this), t && t._addOwner(this)), t } : function () { return c.read(arguments, 0, { readNull: t === `highlight`, clone: !0 }) } : function (t) { return t == null || isNaN(t) ? 0 : +t }; this[`get` + a] = function () { return this._type === e || o && /^hs[bl]$/.test(this._type) ? this._components[n] : this._convert(e)[n] }, this[`set` + a] = function (t) { this._type === e || o && /^hs[bl]$/.test(this._type) || (this._components = this._convert(e), this._properties = i[e], this._type = e), this._components[n] = h.call(this, t), this._changed() } }, this) }, { _class: `Color`,
      _readIndex: !0,
      initialize: function l (e) { var n; var a; var o; var h; var u = arguments; var c = this.__read; var f = 0; Array.isArray(e) && (u = e, e = u[0]); var d = e != null && typeof e; if (d === `string` && e in i && (n = e, e = u[1], Array.isArray(e) ? (a = e, o = u[2]) : (c && (f = 1), u = r.slice(u, 1), d = typeof e)), !a) { if (h = d === `number` ? u : d === `object` && e.length != null ? e : null) { n || (n = h.length >= 3 ? `rgb` : `gray`); var _ = i[n].length; o = h[_], c && (f += h === arguments ? _ + (o != null ? 1 : 0) : 1), h.length > _ && (h = r.slice(h, 0, _)) } else if (d === `string`) { var g = t(e); n = g[0], a = g[1], a.length === 4 && (o = a[3], a.length--) } else if (d === `object`) { if (e.constructor === l) { if (n = e._type, a = e._components.slice(), o = e._alpha, n === `gradient`) { for (var v = 1, p = a.length; v < p; v++) { var m = a[v]; m && (a[v] = m.clone()) } } } else if (e.constructor === R) { n = `gradient`, h = u } else { n = `hue` in e ? `lightness` in e ? `hsl` : `hsb` : `gradient` in e || `stops` in e || `radial` in e ? `gradient` : `gray` in e ? `gray` : `rgb`; var y = i[n]; var w = s[n]; this._components = a = []; for (var v = 0, p = y.length; v < p; v++) { var x = e[y[v]]; x == null && !v && n === `gradient` && `stops` in e && (x = { stops: e.stops, radial: e.radial }), x = w[v].call(this, x), x != null && (a[v] = x) }o = e.alpha } }c && n && (f = 1) } if (this._type = n || `rgb`, !a) { this._components = a = []; for (var w = s[this._type], v = 0, p = w.length; v < p; v++) { var x = w[v].call(this, h && h[v]); x != null && (a[v] = x) } } return this._components = a, this._properties = i[this._type], this._alpha = o, c && (this.__read = f), this },
      set: `#initialize`,
      _serialize: function (t, e) { var n = this.getComponents(); return r.serialize(/^(gray|rgb)$/.test(this._type) ? n : [this._type].concat(n), t, !0, e) },
      _changed: function () { this._canvasStyle = null, this._owner && this._owner._changed(129) },
      _convert: function (t) { var e; return this._type === t ? this._components.slice() : (e = u[this._type + `-` + t]) ? e.apply(this, this._components) : u[`rgb-` + t].apply(this, u[this._type + `-rgb`].apply(this, this._components)) },
      convert: function (t) { return new D(t, this._convert(t), this._alpha) },
      getType: function () { return this._type },
      setType: function (t) { this._components = this._convert(t), this._properties = i[t], this._type = t },
      getComponents: function () { var t = this._components.slice(); return this._alpha != null && t.push(this._alpha), t },
      getAlpha: function () { return this._alpha != null ? this._alpha : 1 },
      setAlpha: function (t) { this._alpha = t == null ? null : Math.min(Math.max(t, 0), 1), this._changed() },
      hasAlpha: function () { return this._alpha != null },
      equals: function (t) { var e = r.isPlainValue(t, !0) ? D.read(arguments) : t; return e === this || e && this._class === e._class && this._type === e._type && this.getAlpha() === e.getAlpha() && r.equals(this._components, e._components) || !1 },
      toString: function () { for (var t = this._properties, e = [], n = this._type === `gradient`, i = h.instance, r = 0, s = t.length; r < s; r++) { var a = this._components[r]; a != null && e.push(t[r] + `: ` + (n ? a : i.number(a))) } return this._alpha != null && e.push(`alpha: ` + i.number(this._alpha)), `{ ` + e.join(`, `) + ` }` },
      toCSS: function (t) { function e (t) { return Math.round(255 * (t < 0 ? 0 : t > 1 ? 1 : t)) } var n = this._convert(`rgb`); var i = t || this._alpha == null ? 1 : this._alpha; return n = [e(n[0]), e(n[1]), e(n[2])], i < 1 && n.push(i < 0 ? 0 : i), t ? `#` + ((1 << 24) + (n[0] << 16) + (n[1] << 8) + n[2]).toString(16).slice(1) : (n.length == 4 ? `rgba(` : `rgb(`) + n.join(`,`) + `)` },
      toCanvasStyle: function (t, e) {
        if (this._canvasStyle) { return this._canvasStyle } if (this._type !== `gradient`) { return this._canvasStyle = this.toCSS() } var n; var i = this._components; var r = i[0]; var s = r._stops; var a = i[1]; var o = i[2]; var h = i[3]; var u = e && e.inverted(); if (u && (a = u._transformPoint(a), o = u._transformPoint(o), h && (h = u._transformPoint(h))), r._radial) { var l = o.getDistance(a); if (h) { var c = h.subtract(a); c.getLength() > l && (h = a.add(c.normalize(l - 0.1))) } var f = h || a; n = t.createRadialGradient(f.x, f.y, 0, a.x, a.y, l) } else { n = t.createLinearGradient(a.x, a.y, o.x, o.y) } for (var d = 0, _ = s.length; d < _; d++) { var g = s[d]; var v = g._offset; n.addColorStop(v == null ? d / (_ - 1) : v, g._color.toCanvasStyle()) } return this._canvasStyle = n
      },
      transform: function (t) { if (this._type === `gradient`) { for (var e = this._components, n = 1, i = e.length; n < i; n++) { var r = e[n]; t._transformPoint(r, r, !0) } this._changed() } },
      statics: { _types: i, random: function () { var t = Math.random; return new D(t(), t(), t()) } } })
  }(), new function () { var t = { add: function (t, e) { return t + e }, subtract: function (t, e) { return t - e }, multiply: function (t, e) { return t * e }, divide: function (t, e) { return t / e } }; return r.each(t, function (t, e) { this[e] = function (e) { e = D.read(arguments); for (var n = this._type, i = this._components, r = e._convert(n), s = 0, a = i.length; s < a; s++) { r[s] = t(i[s], r[s]) } return new D(n, r, this._alpha != null ? t(this._alpha, e.getAlpha()) : null) } }, {}) }()); var R = r.extend({ _class: `Gradient`, initialize: function (t, e) { this._id = l.get(), t && r.isPlainObject(t) && (this.set(t), t = e = null), this._stops == null && this.setStops(t || [`white`, `black`]), this._radial == null && this.setRadial(typeof e === `string` && e === `radial` || e || !1) }, _serialize: function (t, e) { return e.add(this, function () { return r.serialize([this._stops, this._radial], t, !0, e) }) }, _changed: function () { for (var t = 0, e = this._owners && this._owners.length; t < e; t++) { this._owners[t]._changed() } }, _addOwner: function (t) { this._owners || (this._owners = []), this._owners.push(t) }, _removeOwner: function (t) { var n = this._owners ? this._owners.indexOf(t) : -1; n != -1 && (this._owners.splice(n, 1), this._owners.length || (this._owners = e)) }, clone: function () { for (var t = [], e = 0, n = this._stops.length; e < n; e++) { t[e] = this._stops[e].clone() } return new R(t, this._radial) }, getStops: function () { return this._stops }, setStops: function (t) { if (t.length < 2) { throw new Error(`Gradient stop list needs to contain at least two stops.`) } var n = this._stops; if (n) { for (var i = 0, r = n.length; i < r; i++) { n[i]._owner = e } }n = this._stops = q.readList(t, 0, { clone: !0 }); for (var i = 0, r = n.length; i < r; i++) { n[i]._owner = this } this._changed() }, getRadial: function () { return this._radial }, setRadial: function (t) { this._radial = t, this._changed() }, equals: function (t) { if (t === this) { return !0 } if (t && this._class === t._class) { var e = this._stops; var n = t._stops; var i = e.length; if (i === n.length) { for (var r = 0; r < i; r++) { if (!e[r].equals(n[r])) { return !1 } } return !0 } } return !1 } }); var q = r.extend({ _class: `GradientStop`, initialize: function (t, n) { var i = t; var r = n; typeof t === `object` && n === e && (Array.isArray(t) && typeof t[0] !== `number` ? (i = t[0], r = t[1]) : (`color` in t || `offset` in t || `rampPoint` in t) && (i = t.color, r = t.offset || t.rampPoint || 0)), this.setColor(i), this.setOffset(r) }, clone: function () { return new q(this._color.clone(), this._offset) }, _serialize: function (t, e) { var n = this._color; var i = this._offset; return r.serialize(i == null ? [n] : [n, i], t, !0, e) }, _changed: function () { this._owner && this._owner._changed(129) }, getOffset: function () { return this._offset }, setOffset: function (t) { this._offset = t, this._changed() }, getRampPoint: `#getOffset`, setRampPoint: `#setOffset`, getColor: function () { return this._color }, setColor: function () { var t = D.read(arguments, 0, { clone: !0 }); t && (t._owner = this), this._color = t, this._changed() }, equals: function (t) { return t === this || t && this._class === t._class && this._color.equals(t._color) && this._offset == t._offset || !1 } }); var V = r.extend(new function () { var t = { fillColor: null, fillRule: `nonzero`, strokeColor: null, strokeWidth: 1, strokeCap: `butt`, strokeJoin: `miter`, strokeScaling: !0, miterLimit: 10, dashOffset: 0, dashArray: [], shadowColor: null, shadowBlur: 0, shadowOffset: new c(), selectedColor: null }; var n = r.set({}, t, { fontFamily: `sans-serif`, fontWeight: `normal`, fontSize: 12, leading: null, justification: `left` }); var i = r.set({}, n, { fillColor: new D() }); var s = { strokeWidth: 193, strokeCap: 193, strokeJoin: 193, strokeScaling: 201, miterLimit: 193, fontFamily: 9, fontWeight: 9, fontSize: 9, font: 9, leading: 9, justification: 9 }; var a = { beans: !0 }; var o = { _class: `Style`, beans: !0, initialize: function (e, r, s) { this._values = {}, this._owner = r, this._project = r && r._project || s || rt.project, this._defaults = !r || r instanceof x ? n : r instanceof F ? i : t, e && this.set(e) } }; return r.each(n, (t, n) => { var i = /Color$/.test(n); var h = n === `shadowOffset`; var u = r.capitalize(n); var l = s[n]; var f = `set` + u; var d = `get` + u; o[f] = function (t) { var r = this._owner; var s = r && r._children; if (s && s.length > 0 && !(r instanceof E)) { for (var a = 0, o = s.length; a < o; a++) { s[a]._style[f](t) } } else if (n in this._defaults) { var h = this._values[n]; h !== t && (i && (h && h._owner !== e && (h._owner = e, h._canvasStyle = null), t && t.constructor === D && (t._owner && (t = t.clone()), t._owner = r)), this._values[n] = t, r && r._changed(l || 129)) } }, o[d] = function (t) { var s; var a = this._owner; var o = a && a._children; if (n in this._defaults && (!o || !o.length || t || a instanceof E)) { var s = this._values[n]; if (s === e) { s = this._defaults[n], s && s.clone && (s = s.clone()) } else { var u = i ? D : h ? c : null; !u || s && s.constructor === u || (this._values[n] = s = u.read([s], 0, { readNull: !0, clone: !0 }), s && i && (s._owner = a)) } } else if (o) { for (var l = 0, f = o.length; l < f; l++) { var _ = o[l]._style[d](); if (l) { if (!r.equals(s, _)) { return e } } else { s = _ } } } return s }, a[d] = function (t) { return this._style[d](t) }, a[f] = function (t) { this._style[f](t) } }), r.each({ Font: `FontFamily`, WindingRule: `FillRule` }, (t, e) => { var n = `get` + e; var i = `set` + e; o[n] = a[n] = `#get` + t, o[i] = a[i] = `#set` + t }), w.inject(a), o }(), { set: function (t) { var e = t instanceof V; var n = e ? t._values : t; if (n) { for (var i in n) { if (i in this._defaults) { var r = n[i]; this[i] = r && e && r.clone ? r.clone() : r } } } }, equals: function (t) { function n (t, n, i) { var s = t._values; var a = n._values; var o = n._defaults; for (var h in s) { var u = s[h]; var l = a[h]; if (!(i && h in a || r.equals(u, l === e ? o[h] : l))) { return !1 } } return !0 } return t === this || t && this._class === t._class && n(this, t) && n(t, this, !0) || !1 }, _dispose: function () { var t; t = this.getFillColor(), t && (t._canvasStyle = null), t = this.getStrokeColor(), t && (t._canvasStyle = null), t = this.getShadowColor(), t && (t._canvasStyle = null) }, hasFill: function () { var t = this.getFillColor(); return !!t && t.alpha > 0 }, hasStroke: function () { var t = this.getStrokeColor(); return !!t && t.alpha > 0 && this.getStrokeWidth() > 0 }, hasShadow: function () { var t = this.getShadowColor(); return !!t && t.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero()) }, getView: function () { return this._project._view }, getFontStyle: function () { var t = this.getFontSize(); return this.getFontWeight() + ` ` + t + (/[a-z]/i.test(t + ``) ? ` ` : `px `) + this.getFontFamily() }, getFont: `#getFontFamily`, setFont: `#setFontFamily`, getLeading: function Ct () { var t = Ct.base.call(this); var e = this.getFontSize(); return /pt|em|%|px/.test(e) && (e = this.getView().getPixelSize(e)), t != null ? t : 1.2 * e } }); var U = new function () { function t (t, e, n, i) { for (var r = [``, `webkit`, `moz`, `Moz`, `ms`, `o`], s = e[0].toUpperCase() + e.substring(1), a = 0; a < 6; a++) { var o = r[a]; var h = o ? o + s : e; if (h in t) { if (!n) { return t[h] }t[h] = i; break } } } return { getStyles: function (t) { var e = t && t.nodeType !== 9 ? t.ownerDocument : t; var n = e && e.defaultView; return n && n.getComputedStyle(t, ``) }, getBounds: function (t, e) { var n; var i = t.ownerDocument; var r = i.body; var s = i.documentElement; try { n = t.getBoundingClientRect() } catch (a) { n = { left: 0, top: 0, width: 0, height: 0 } } var o = n.left - (s.clientLeft || r.clientLeft || 0); var h = n.top - (s.clientTop || r.clientTop || 0); if (!e) { var u = i.defaultView; o += u.pageXOffset || s.scrollLeft || r.scrollLeft, h += u.pageYOffset || s.scrollTop || r.scrollTop } return new g(o, h, n.width, n.height) }, getViewportBounds: function (t) { var e = t.ownerDocument; var n = e.defaultView; var i = e.documentElement; return new g(0, 0, n.innerWidth || i.clientWidth, n.innerHeight || i.clientHeight) }, getOffset: function (t, e) { return U.getBounds(t, e).getPoint() }, getSize: function (t) { return U.getBounds(t, !0).getSize() }, isInvisible: function (t) { return U.getSize(t).equals(new d(0, 0)) }, isInView: function (t) { return !U.isInvisible(t) && U.getViewportBounds(t).intersects(U.getBounds(t, !0)) }, isInserted: function (t) { return i.body.contains(t) }, getPrefixed: function (e, n) { return e && t(e, n) }, setPrefixed: function (e, n, i) { if (typeof n === `object`) { for (var r in n) { t(e, r, !0, n[r]) } } else { t(e, n, !0, i) } } } }(); var H = { add: function (t, e) { if (t) { for (var n in e) { for (var r = e[n], s = n.split(/[\s,]+/g), a = 0, o = s.length; a < o; a++) { var h = s[a]; var u = t === i && (h === `touchstart` || h === `touchmove`) && { passive: !1 }; t.addEventListener(h, r, u) } } } }, remove: function (t, e) { if (t) { for (var n in e) { for (var i = e[n], r = n.split(/[\s,]+/g), s = 0, a = r.length; s < a; s++) { t.removeEventListener(r[s], i, !1) } } } }, getPoint: function (t) { var e = t.targetTouches ? t.targetTouches.length ? t.targetTouches[0] : t.changedTouches[0] : t; return new c(e.pageX || e.clientX + i.documentElement.scrollLeft, e.pageY || e.clientY + i.documentElement.scrollTop) }, getTarget: function (t) { return t.target || t.srcElement }, getRelatedTarget: function (t) { return t.relatedTarget || t.toElement }, getOffset: function (t, e) { return H.getPoint(t).subtract(U.getOffset(e || H.getTarget(t))) } }; H.requestAnimationFrame = new function () { function t () { var e = s; s = []; for (var n = 0, a = e.length; n < a; n++) { e[n]() }r = i && s.length, r && i(t) } var e; var i = U.getPrefixed(n, `requestAnimationFrame`); var r = !1; var s = []; return function (n) { s.push(n), i ? r || (i(t), r = !0) : e || (e = setInterval(t, 1e3 / 60)) } }(); var Z = r.extend(s, { _class: `View`, initialize: function St (t, e) { function r (t) { return e[t] || parseInt(e.getAttribute(t), 10) } function s () { var t = U.getSize(e); return t.isNaN() || t.isZero() ? new d(r(`width`), r(`height`)) : t } var o; if (n && e) { this._id = e.getAttribute(`id`), this._id == null && e.setAttribute(`id`, this._id = `view-` + St._id++), H.add(e, this._viewEvents); var h = `none`; if (U.setPrefixed(e.style, { userDrag: h, userSelect: h, touchCallout: h, contentZooming: h, tapHighlightColor: `rgba(0,0,0,0)` }), a.hasAttribute(e, `resize`)) { var u = this; H.add(n, this._windowEvents = { resize: function () { u.setViewSize(s()) } }) } if (o = s(), a.hasAttribute(e, `stats`) && typeof Stats !== `undefined`) { this._stats = new Stats(); var l = this._stats.domElement; var c = l.style; var f = U.getOffset(e); c.position = `absolute`, c.left = f.x + `px`, c.top = f.y + `px`, i.body.appendChild(l) } } else { o = new d(e), e = null } this._project = t, this._scope = t._scope, this._element = e, this._pixelRatio || (this._pixelRatio = n && n.devicePixelRatio || 1), this._setElementSize(o.width, o.height), this._viewSize = o, St._views.push(this), St._viewsById[this._id] = this, (this._matrix = new p())._owner = this, St._focused || (St._focused = this), this._frameItems = {}, this._frameItemCount = 0, this._itemEvents = { native: {}, virtual: {} }, this._autoUpdate = !rt.agent.node, this._needsUpdate = !1 }, remove: function () { if (!this._project) { return !1 }Z._focused === this && (Z._focused = null), Z._views.splice(Z._views.indexOf(this), 1), delete Z._viewsById[this._id]; var t = this._project; return t._view === this && (t._view = null), H.remove(this._element, this._viewEvents), H.remove(n, this._windowEvents), this._element = this._project = null, this.off(`frame`), this._animate = !1, this._frameItems = {}, !0 }, _events: r.each(w._itemHandlers.concat([`onResize`, `onKeyDown`, `onKeyUp`]), function (t) { this[t] = {} }, { onFrame: { install: function () { this.play() }, uninstall: function () { this.pause() } } }), _animate: !1, _time: 0, _count: 0, getAutoUpdate: function () { return this._autoUpdate }, setAutoUpdate: function (t) { this._autoUpdate = t, t && this.requestUpdate() }, update: function () {}, draw: function () { this.update() }, requestUpdate: function () { if (!this._requested) { var t = this; H.requestAnimationFrame(() => { if (t._requested = !1, t._animate) { t.requestUpdate(); var e = t._element; U.getPrefixed(i, `hidden`) && a.getAttribute(e, `keepalive`) !== `true` || !U.isInView(e) || t._handleFrame() }t._autoUpdate && t.update() }), this._requested = !0 } }, play: function () { this._animate = !0, this.requestUpdate() }, pause: function () { this._animate = !1 }, _handleFrame: function () { rt = this._scope; var t = Date.now() / 1e3; var e = this._last ? t - this._last : 0; this._last = t, this.emit(`frame`, new r({ delta: e, time: this._time += e, count: this._count++ })), this._stats && this._stats.update() }, _animateItem: function (t, e) { var n = this._frameItems; e ? (n[t._id] = { item: t, time: 0, count: 0 }, ++this._frameItemCount === 1 && this.on(`frame`, this._handleFrameItems)) : (delete n[t._id], --this._frameItemCount === 0 && this.off(`frame`, this._handleFrameItems)) }, _handleFrameItems: function (t) { for (var e in this._frameItems) { var n = this._frameItems[e]; n.item.emit(`frame`, new r(t, { time: n.time += t.delta, count: n.count++ })) } }, _changed: function () { this._project._changed(4097), this._bounds = this._decomposed = e }, getElement: function () { return this._element }, getPixelRatio: function () { return this._pixelRatio }, getResolution: function () { return 72 * this._pixelRatio }, getViewSize: function () { var t = this._viewSize; return new _(t.width, t.height, this, `setViewSize`) }, setViewSize: function () { var t = d.read(arguments); var e = t.subtract(this._viewSize); e.isZero() || (this._setElementSize(t.width, t.height), this._viewSize.set(t), this._changed(), this.emit(`resize`, { size: t, delta: e }), this._autoUpdate && this.update()) }, _setElementSize: function (t, e) { var n = this._element; n && (n.width !== t && (n.width = t), n.height !== e && (n.height = e)) }, getBounds: function () { return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(new g(new c(), this._viewSize))), this._bounds }, getSize: function () { return this.getBounds().getSize() }, isVisible: function () { return U.isInView(this._element) }, isInserted: function () { return U.isInserted(this._element) }, getPixelSize: function (t) { var e; var n = this._element; if (n) { var r = n.parentNode; var s = i.createElement(`div`); s.style.fontSize = t, r.appendChild(s), e = parseFloat(U.getStyles(s).fontSize), r.removeChild(s) } else { e = parseFloat(e) } return e }, getTextWidth: function (t, e) { return 0 } }, r.each([`rotate`, `scale`, `shear`, `skew`], function (t) { var e = t === `rotate`; this[t] = function () { var n = (e ? r : c).read(arguments); var i = c.read(arguments, 0, { readNull: !0 }); return this.transform((new p())[t](n, i || this.getCenter(!0))) } }, { _decompose: function () { return this._decomposed || (this._decomposed = this._matrix.decompose()) }, translate: function () { var t = new p(); return this.transform(t.translate.apply(t, arguments)) }, getCenter: function () { return this.getBounds().getCenter() }, setCenter: function () { var t = c.read(arguments); this.translate(this.getCenter().subtract(t)) }, getZoom: function () { var t = this._decompose(); var e = t && t.scaling; return e ? (e.x + e.y) / 2 : 0 }, setZoom: function (t) { this.transform((new p()).scale(t / this.getZoom(), this.getCenter())) }, getRotation: function () { var t = this._decompose(); return t && t.rotation }, setRotation: function (t) { var e = this.getRotation(); e != null && t != null && this.rotate(t - e) }, getScaling: function () { var t = this._decompose(); var n = t && t.scaling; return n ? new f(n.x, n.y, this, `setScaling`) : e }, setScaling: function () { var t = this.getScaling(); var e = c.read(arguments, 0, { clone: !0, readNull: !0 }); t && e && this.scale(e.x / t.x, e.y / t.y) }, getMatrix: function () { return this._matrix }, setMatrix: function () { var t = this._matrix; t.initialize.apply(t, arguments) }, transform: function (t) { this._matrix.append(t) }, scrollBy: function () { this.translate(c.read(arguments).negate()) } }), { projectToView: function () { return this._matrix._transformPoint(c.read(arguments)) }, viewToProject: function () { return this._matrix._inverseTransform(c.read(arguments)) }, getEventPoint: function (t) { return this.viewToProject(H.getOffset(t, this._element)) } }, { statics: { _views: [], _viewsById: {}, _id: 0, create: function (t, e) { i && typeof e === `string` && (e = i.getElementById(e)); var r = n ? W : Z; return new r(t, e) } } }, new function () { function t (t) { var e = H.getTarget(t); return e.getAttribute && Z._viewsById[e.getAttribute(`id`)] } function e () { var t = Z._focused; if (!t || !t.isVisible()) { for (var e = 0, n = Z._views.length; e < n; e++) { if ((t = Z._views[e]).isVisible()) { Z._focused = h = t; break } } } } function r (t, e, n) { t._handleMouseEvent(`mousemove`, e, n) } function s (t, e, n, i, r, s, a) { function o (t, n) { if (t.responds(n)) { if (h || (h = new X(n, i, r, e || t, s ? r.subtract(s) : null)), t.emit(n, h) && (I = !0, h.prevented && (P = !0), h.stopped)) { return u = !0 } } else { var a = M[n]; if (a) { return o(t, a) } } } for (var h, u = !1; t && t !== a && !o(t, n);) { t = t._parent } return u } function a (t, e, n, i, r, a) { return t._project.removeOn(n), P = I = !1, b && s(b, null, n, i, r, a) || e && e !== b && !e.isDescendant(b) && s(e, null, n, i, r, a, b) || s(t, b || e || t, n, i, r, a) } if (n) { var o; var h; var u; var l; var c; var f = !1; var d = !1; var _ = n.navigator; _.pointerEnabled || _.msPointerEnabled ? (u = `pointerdown MSPointerDown`, l = `pointermove MSPointerMove`, c = `pointerup pointercancel MSPointerUp MSPointerCancel`) : (u = `touchstart`, l = `touchmove`, c = `touchend touchcancel`, `ontouchstart` in n && _.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i) || (u += ` mousedown`, l += ` mousemove`, c += ` mouseup`)); var g = {}; var v = { mouseout: function (t) { var e = Z._focused; var n = H.getRelatedTarget(t); if (e && (!n || n.nodeName === `HTML`)) { var i = H.getOffset(t, e._element); var s = i.x; var a = Math.abs; var o = a(s); var h = 1 << 25; var u = o - h; i.x = a(u) < o ? u * (s < 0 ? -1 : 1) : s, r(e, t, e.viewToProject(i)) } }, scroll: e }; g[u] = function (e) { var n = Z._focused = t(e); f || (f = !0, n._handleMouseEvent(`mousedown`, e)) }, v[l] = function (n) { var i = Z._focused; if (!d) { var s = t(n); s ? i !== s && (i && r(i, n), o || (o = i), i = Z._focused = h = s) : h && h === i && (o && !o.isInserted() && (o = null), i = Z._focused = o, o = null, e()) }i && r(i, n) }, v[u] = function () { d = !0 }, v[c] = function (t) { var e = Z._focused; e && f && e._handleMouseEvent(`mouseup`, t), d = f = !1 }, H.add(i, v), H.add(n, { load: e }); var p; var m; var y; var w; var x; var b; var C; var S; var k; var I = !1; var P = !1; var M = { doubleclick: `click`, mousedrag: `mousemove` }; var T = !1; var A = { mousedown: { mousedown: 1, mousedrag: 1, click: 1, doubleclick: 1 }, mouseup: { mouseup: 1, mousedrag: 1, click: 1, doubleclick: 1 }, mousemove: { mousedrag: 1, mousemove: 1, mouseenter: 1, mouseleave: 1 } }; return { _viewEvents: g, _handleMouseEvent: function (t, e, n) { function i (t) { return r.virtual[t] || l.responds(t) || u && u.responds(t) } var r = this._itemEvents; var o = r[`native`][t]; var h = t === `mousemove`; var u = this._scope.tool; var l = this; h && f && i(`mousedrag`) && (t = `mousedrag`), n || (n = this.getEventPoint(e)); var c = this.getBounds().contains(n); var d = o && c && l._project.hitTest(n, { tolerance: 0, fill: !0, stroke: !0 }); var _ = d && d.item || null; var g = !1; var v = {}; if (v[t.substr(5)] = !0, o && _ !== x && (x && s(x, null, `mouseleave`, e, n), _ && s(_, null, `mouseenter`, e, n), x = _), T ^ c && (s(this, null, c ? `mouseenter` : `mouseleave`, e, n), p = c ? this : null, g = !0), !c && !v.drag || n.equals(y) || (a(this, _, h ? t : `mousemove`, e, n, y), g = !0), T = c, v.down && c || v.up && m) { if (a(this, _, t, e, n, m), v.down) { if (k = _ === C && Date.now() - S < 300, w = C = _, !P && _) { for (var M = _; M && !M.responds(`mousedrag`);) { M = M._parent }M && (b = _) }m = n } else { v.up && (P || _ !== w || (S = Date.now(), a(this, _, k ? `doubleclick` : `click`, e, n, m), k = !1), w = b = null) }T = !1, g = !0 }y = n, g && u && (I = u._handleMouseEvent(t, e, n, v) || I), e.cancelable !== !1 && (I && !v.move || v.down && i(`mouseup`)) && e.preventDefault() }, _handleKeyEvent: function (t, e, n, i) { function r (r) { r.responds(t) && (rt = a, r.emit(t, s = s || new G(t, e, n, i))) } var s; var a = this._scope; var o = a.tool; this.isVisible() && (r(this), o && o.responds(t) && r(o)) }, _countItemEvent: function (t, e) { var n = this._itemEvents; var i = n[`native`]; var r = n.virtual; for (var s in A) { i[s] = (i[s] || 0) + (A[s][t] || 0) * e }r[t] = (r[t] || 0) + e }, statics: { updateFocus: e, _resetState: function () { f = d = I = T = !1, o = h = p = m = y = w = x = b = C = S = k = null } } } } }()); var W = Z.extend({ _class: `CanvasView`, initialize: function (t, e) { if (!(e instanceof n.HTMLCanvasElement)) { var i = d.read(arguments, 1); if (i.isZero()) { throw new Error(`Cannot create CanvasView with the provided argument: ` + r.slice(arguments, 1)) }e = tt.getCanvas(i) } var s = this._context = e.getContext(`2d`); if (s.save(), this._pixelRatio = 1, !/^off|false$/.test(a.getAttribute(e, `hidpi`))) { var o = n.devicePixelRatio || 1; var h = U.getPrefixed(s, `backingStorePixelRatio`) || 1; this._pixelRatio = o / h }Z.call(this, t, e), this._needsUpdate = !0 }, remove: function kt () { return this._context.restore(), kt.base.call(this) }, _setElementSize: function It (t, e) { var n = this._pixelRatio; if (It.base.call(this, t * n, e * n), n !== 1) { var i = this._element; var r = this._context; if (!a.hasAttribute(i, `resize`)) { var s = i.style; s.width = t + `px`, s.height = e + `px` }r.restore(), r.save(), r.scale(n, n) } }, getPixelSize: function Pt (t) { var e; var n = rt.agent; if (n && n.firefox) { e = Pt.base.call(this, t) } else { var i = this._context; var r = i.font; i.font = t + ` serif`, e = parseFloat(i.font), i.font = r } return e }, getTextWidth: function (t, e) { var n = this._context; var i = n.font; var r = 0; n.font = t; for (var s = 0, a = e.length; s < a; s++) { r = Math.max(r, n.measureText(e[s]).width) } return n.font = i, r }, update: function () { if (!this._needsUpdate) { return !1 } var t = this._project; var e = this._context; var n = this._viewSize; return e.clearRect(0, 0, n.width + 1, n.height + 1), t && t.draw(e, this._matrix, this._pixelRatio), this._needsUpdate = !1, !0 } }); var $ = r.extend({ _class: `Event`, initialize: function (t) { this.event = t, this.type = t && t.type }, prevented: !1, stopped: !1, preventDefault: function () { this.prevented = !0, this.event.preventDefault() }, stopPropagation: function () { this.stopped = !0, this.event.stopPropagation() }, stop: function () { this.stopPropagation(), this.preventDefault() }, getTimeStamp: function () { return this.event.timeStamp }, getModifiers: function () { return J.modifiers } }); var G = $.extend({ _class: `KeyEvent`, initialize: function (t, e, n, i) { this.type = t, this.event = e, this.key = n, this.character = i }, toString: function () { return `{ type: '` + this.type + `', key: '` + this.key + `', character: '` + this.character + `', modifiers: ` + this.getModifiers() + ` }` } }); var J = new function () { function t (t) { var n = t.key || t.keyIdentifier; return n = /^U\+/.test(n) ? String.fromCharCode(parseInt(n.substr(2), 16)) : /^Arrow[A-Z]/.test(n) ? n.substr(5) : n === `Unidentified` || n === e ? String.fromCharCode(t.keyCode) : n, h[n] || (n.length > 1 ? r.hyphenate(n) : n.toLowerCase()) } function s (t, e, n, i) { var o; var h = Z._focused; if (l[e] = t, t ? c[e] = n : delete c[e], e.length > 1 && (o = r.camelize(e)) in f) { f[o] = t; var u = rt && rt.agent; if (o === `meta` && u && u.mac) { if (t) { a = {} } else { for (var d in a) { d in c && s(!1, d, a[d], i) }a = null } } } else { t && a && (a[e] = n) }h && h._handleKeyEvent(t ? `keydown` : `keyup`, i, e, n) } var a; var o; var h = { '\t': `tab`, ' ': `space`, '\b': `backspace`, '\x7f': `delete`, Spacebar: `space`, Del: `delete`, Win: `meta`, Esc: `escape` }; var u = { tab: `\t`, space: ` `, enter: `\r` }; var l = {}; var c = {}; var f = new r({ shift: !1, control: !1, alt: !1, meta: !1, capsLock: !1, space: !1 }).inject({ option: { get: function () { return this.alt } }, command: { get: function () { var t = rt && rt.agent; return t && t.mac ? this.meta : this.control } } }); return H.add(i, { keydown: function (e) { var n = t(e); var i = rt && rt.agent; n.length > 1 || i && i.chrome && (e.altKey || i.mac && e.metaKey || !i.mac && e.ctrlKey) ? s(!0, n, u[n] || (n.length > 1 ? `` : n), e) : o = n }, keypress: function (e) { if (o) { var n = t(e); var i = e.charCode; var r = i >= 32 ? String.fromCharCode(i) : n.length > 1 ? `` : n; n !== o && (n = r.toLowerCase()), s(!0, n, r, e), o = null } }, keyup: function (e) { var n = t(e); n in c && s(!1, n, c[n], e) } }), H.add(n, { blur: function (t) { for (var e in c) { s(!1, e, c[e], t) } } }), { modifiers: f, isDown: function (t) { return !!l[t] } } }(); var X = $.extend({ _class: `MouseEvent`, initialize: function (t, e, n, i, r) { this.type = t, this.event = e, this.point = n, this.target = i, this.delta = r }, toString: function () { return `{ type: '` + this.type + `', point: ` + this.point + `, target: ` + this.target + (this.delta ? `, delta: ` + this.delta : ``) + `, modifiers: ` + this.getModifiers() + ` }` } }); var K = $.extend({ _class: `ToolEvent`, _item: null, initialize: function (t, e, n) { this.tool = t, this.type = e, this.event = n }, _choosePoint: function (t, e) { return t || (e ? e.clone() : null) }, getPoint: function () { return this._choosePoint(this._point, this.tool._point) }, setPoint: function (t) { this._point = t }, getLastPoint: function () { return this._choosePoint(this._lastPoint, this.tool._lastPoint) }, setLastPoint: function (t) { this._lastPoint = t }, getDownPoint: function () { return this._choosePoint(this._downPoint, this.tool._downPoint) }, setDownPoint: function (t) { this._downPoint = t }, getMiddlePoint: function () { return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint }, setMiddlePoint: function (t) { this._middlePoint = t }, getDelta: function () { return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta }, setDelta: function (t) { this._delta = t }, getCount: function () { return this.tool[/^mouse(down|up)$/.test(this.type) ? `_downCount` : `_moveCount`] }, setCount: function (t) { this.tool[/^mouse(down|up)$/.test(this.type) ? `downCount` : `count`] = t }, getItem: function () { if (!this._item) { var t = this.tool._scope.project.hitTest(this.getPoint()); if (t) { for (var e = t.item, n = e._parent; /^(Group|CompoundPath)$/.test(n._class);) { e = n, n = n._parent } this._item = e } } return this._item }, setItem: function (t) { this._item = t }, toString: function () { return `{ type: ` + this.type + `, point: ` + this.getPoint() + `, count: ` + this.getCount() + `, modifiers: ` + this.getModifiers() + ` }` } }); var Y = o.extend({ _class: `Tool`, _list: `tools`, _reference: `tool`, _events: [`onMouseDown`, `onMouseUp`, `onMouseDrag`, `onMouseMove`, `onActivate`, `onDeactivate`, `onEditOptions`, `onKeyDown`, `onKeyUp`], initialize: function (t) { o.call(this), this._moveCount = -1, this._downCount = -1, this.set(t) }, getMinDistance: function () { return this._minDistance }, setMinDistance: function (t) { this._minDistance = t, t != null && this._maxDistance != null && t > this._maxDistance && (this._maxDistance = t) }, getMaxDistance: function () { return this._maxDistance }, setMaxDistance: function (t) { this._maxDistance = t, this._minDistance != null && t != null && t < this._minDistance && (this._minDistance = t) }, getFixedDistance: function () { return this._minDistance == this._maxDistance ? this._minDistance : null }, setFixedDistance: function (t) { this._minDistance = this._maxDistance = t }, _handleMouseEvent: function (t, e, n, i) { function r (t, e) { var r = n; var s = a ? c._point : c._downPoint || r; if (a) { if (c._moveCount >= 0 && r.equals(s)) { return !1 } if (s && (t != null || e != null)) { var o = r.subtract(s); var h = o.getLength(); if (h < (t || 0)) { return !1 }e && (r = s.add(o.normalize(Math.min(h, e)))) }c._moveCount++ } return c._point = r, c._lastPoint = s || r, i.down && (c._moveCount = -1, c._downPoint = r, c._downCount++), !0 } function s () { o && (l = c.emit(t, new K(c, t, e)) || l) }rt = this._scope, i.drag && !this.responds(t) && (t = `mousemove`); var a = i.move || i.drag; var o = this.responds(t); var h = this.minDistance; var u = this.maxDistance; var l = !1; var c = this; if (i.down) { r(), s() } else if (i.up) { r(null, u), s() } else if (o) { for (;r(h, u);) { s() } } return l } }); var Q = { request: function (e) { var n = new t.XMLHttpRequest(); return n.open((e.method || `get`).toUpperCase(), e.url, r.pick(e.async, !0)), e.mimeType && n.overrideMimeType(e.mimeType), n.onload = function () { var t = n.status; t === 0 || t === 200 ? e.onLoad && e.onLoad.call(n, n.responseText) : n.onerror() }, n.onerror = function () { var t = n.status; var i = `Could not load "` + e.url + `" (Status: ` + t + `)`; if (!e.onError) { throw new Error(i) }e.onError(i, t) }, n.send(null) } }; var tt = { canvases: [], getCanvas: function (t, e) { if (!n) { return null } var r; var s = !0; typeof t === `object` && (e = t.height, t = t.width), this.canvases.length ? r = this.canvases.pop() : (r = i.createElement(`canvas`), s = !1); var a = r.getContext(`2d`); if (!a) { throw new Error(`Canvas ` + r + ` is unable to provide a 2D context.`) } return r.width === t && r.height === e ? s && a.clearRect(0, 0, t + 1, e + 1) : (r.width = t, r.height = e), a.save(), r }, getContext: function (t, e) { var n = this.getCanvas(t, e); return n ? n.getContext(`2d`) : null }, release: function (t) { var e = t && t.canvas ? t.canvas : t; e && e.getContext && (e.getContext(`2d`).restore(), this.canvases.push(e)) } }; var et = new function () { function t (t, e, n) { return 0.2989 * t + 0.587 * e + 0.114 * n } function e (e, n, i, r) { var s = r - t(e, n, i); d = e + s, _ = n + s, g = i + s; var r = t(d, _, g); var a = v(d, _, g); var o = p(d, _, g); if (a < 0) { var h = r - a; d = r + (d - r) * r / h, _ = r + (_ - r) * r / h, g = r + (g - r) * r / h } if (o > 255) { var u = 255 - r; var l = o - r; d = r + (d - r) * u / l, _ = r + (_ - r) * u / l, g = r + (g - r) * u / l } } function n (t, e, n) { return p(t, e, n) - v(t, e, n) } function i (t, e, n, i) { var r; var s = [t, e, n]; var a = p(t, e, n); var o = v(t, e, n); o = o === t ? 0 : o === e ? 1 : 2, a = a === t ? 0 : a === e ? 1 : 2, r = v(o, a) === 0 ? p(o, a) === 1 ? 2 : 1 : 0, s[a] > s[o] ? (s[r] = (s[r] - s[o]) * i / (s[a] - s[o]), s[a] = i) : s[r] = s[a] = 0, s[o] = 0, d = s[0], _ = s[1], g = s[2] } var s; var a; var o; var h; var u; var l; var c; var f; var d; var _; var g; var v = Math.min; var p = Math.max; var m = Math.abs; var y = { multiply: function () { d = u * s / 255, _ = l * a / 255, g = c * o / 255 }, screen: function () { d = u + s - u * s / 255, _ = l + a - l * a / 255, g = c + o - c * o / 255 }, overlay: function () { d = u < 128 ? 2 * u * s / 255 : 255 - 2 * (255 - u) * (255 - s) / 255, _ = l < 128 ? 2 * l * a / 255 : 255 - 2 * (255 - l) * (255 - a) / 255, g = c < 128 ? 2 * c * o / 255 : 255 - 2 * (255 - c) * (255 - o) / 255 }, 'soft-light': function () { var t = s * u / 255; d = t + u * (255 - (255 - u) * (255 - s) / 255 - t) / 255, t = a * l / 255, _ = t + l * (255 - (255 - l) * (255 - a) / 255 - t) / 255, t = o * c / 255, g = t + c * (255 - (255 - c) * (255 - o) / 255 - t) / 255 }, 'hard-light': function () { d = s < 128 ? 2 * s * u / 255 : 255 - 2 * (255 - s) * (255 - u) / 255, _ = a < 128 ? 2 * a * l / 255 : 255 - 2 * (255 - a) * (255 - l) / 255, g = o < 128 ? 2 * o * c / 255 : 255 - 2 * (255 - o) * (255 - c) / 255 }, 'color-dodge': function () { d = u === 0 ? 0 : s === 255 ? 255 : v(255, 255 * u / (255 - s)), _ = l === 0 ? 0 : a === 255 ? 255 : v(255, 255 * l / (255 - a)), g = c === 0 ? 0 : o === 255 ? 255 : v(255, 255 * c / (255 - o)) }, 'color-burn': function () { d = u === 255 ? 255 : s === 0 ? 0 : p(0, 255 - 255 * (255 - u) / s), _ = l === 255 ? 255 : a === 0 ? 0 : p(0, 255 - 255 * (255 - l) / a), g = c === 255 ? 255 : o === 0 ? 0 : p(0, 255 - 255 * (255 - c) / o) }, darken: function () { d = u < s ? u : s, _ = l < a ? l : a, g = c < o ? c : o }, lighten: function () { d = u > s ? u : s, _ = l > a ? l : a, g = c > o ? c : o }, difference: function () { d = u - s, d < 0 && (d = -d), _ = l - a, _ < 0 && (_ = -_), g = c - o, g < 0 && (g = -g) }, exclusion: function () { d = u + s * (255 - u - u) / 255, _ = l + a * (255 - l - l) / 255, g = c + o * (255 - c - c) / 255 }, hue: function () { i(s, a, o, n(u, l, c)), e(d, _, g, t(u, l, c)) }, saturation: function () { i(u, l, c, n(s, a, o)), e(d, _, g, t(u, l, c)) }, luminosity: function () { e(u, l, c, t(s, a, o)) }, color: function () { e(s, a, o, t(u, l, c)) }, add: function () { d = v(u + s, 255), _ = v(l + a, 255), g = v(c + o, 255) }, subtract: function () { d = p(u - s, 0), _ = p(l - a, 0), g = p(c - o, 0) }, average: function () { d = (u + s) / 2, _ = (l + a) / 2, g = (c + o) / 2 }, negation: function () { d = 255 - m(255 - s - u), _ = 255 - m(255 - a - l), g = 255 - m(255 - o - c) } }; var w = this.nativeModes = r.each([`source-over`, `source-in`, `source-out`, `source-atop`, `destination-over`, `destination-in`, `destination-out`, `destination-atop`, `lighter`, `darker`, `copy`, `xor`], function (t) { this[t] = !0 }, {}); var x = tt.getContext(1, 1); x && (r.each(y, (t, e) => { var n = e === `darken`; var i = !1; x.save(); try { x.fillStyle = n ? `#300` : `#a00`, x.fillRect(0, 0, 1, 1), x.globalCompositeOperation = e, x.globalCompositeOperation === e && (x.fillStyle = n ? `#a00` : `#300`, x.fillRect(0, 0, 1, 1), i = x.getImageData(0, 0, 1, 1).data[0] !== n ? 170 : 51) } catch (r) {}x.restore(), w[e] = i }), tt.release(x)), this.process = function (t, e, n, i, r) { var v = e.canvas; var p = t === `normal`; if (p || w[t]) { n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.globalAlpha = i, p || (n.globalCompositeOperation = t), n.drawImage(v, r.x, r.y), n.restore() } else { var m = y[t]; if (!m) { return } for (var x = n.getImageData(r.x, r.y, v.width, v.height), b = x.data, C = e.getImageData(0, 0, v.width, v.height).data, S = 0, k = b.length; S < k; S += 4) { s = C[S], u = b[S], a = C[S + 1], l = b[S + 1], o = C[S + 2], c = b[S + 2], h = C[S + 3], f = b[S + 3], m(); var I = h * i / 255; var P = 1 - I; b[S] = I * d + P * u, b[S + 1] = I * _ + P * l, b[S + 2] = I * g + P * c, b[S + 3] = h * i + P * f }n.putImageData(x, r.x, r.y) } } }(); var nt = new function () { function t (t, e, s) { return n(i.createElementNS(r, t), e, s) } function e (t, e) { var n = o[e]; var i = n ? t.getAttributeNS(n, e) : t.getAttribute(e); return i === `null` ? null : i } function n (t, e, n) { for (var i in e) { var r = e[i]; var s = o[i]; typeof r === `number` && n && (r = n.number(r)), s ? t.setAttributeNS(s, i, r) : t.setAttribute(i, r) } return t } var r = `http://www.w3.org/2000/svg`; var s = `http://www.w3.org/2000/xmlns`; var a = `http://www.w3.org/1999/xlink`; var o = { href: a, xlink: s, xmlns: s + `/`, 'xmlns:xlink': s + `/` }; return { svg: r, xmlns: s, xlink: a, create: t, get: e, set: n } }(); var it = r.each({ fillColor: [`fill`, `color`], fillRule: [`fill-rule`, `string`], strokeColor: [`stroke`, `color`], strokeWidth: [`stroke-width`, `number`], strokeCap: [`stroke-linecap`, `string`], strokeJoin: [`stroke-linejoin`, `string`], strokeScaling: [`vector-effect`, `lookup`, { true: `none`, false: `non-scaling-stroke` }, function (t, e) { return !e && (t instanceof O || t instanceof C || t instanceof F) }], miterLimit: [`stroke-miterlimit`, `number`], dashArray: [`stroke-dasharray`, `array`], dashOffset: [`stroke-dashoffset`, `number`], fontFamily: [`font-family`, `string`], fontWeight: [`font-weight`, `string`], fontSize: [`font-size`, `number`], justification: [`text-anchor`, `lookup`, { left: `start`, center: `middle`, right: `end` }], opacity: [`opacity`, `number`], blendMode: [`mix-blend-mode`, `style`] }, function (t, e) { var n = r.capitalize(e); var i = t[2]; this[e] = { type: t[1], property: e, attribute: t[0], toSVG: i, fromSVG: i && r.each(i, function (t, e) { this[t] = e }, {}), exportFilter: t[3], get: `get` + n, set: `set` + n } }, {}); new function () {
    function e (t, e, n) { var i = new r(); var s = t.getTranslation(); if (e) { t = t._shiftless(); var a = t._inverseTransform(s); i[n ? `cx` : `x`] = a.x, i[n ? `cy` : `y`] = a.y, s = null } if (!t.isIdentity()) { var o = t.decompose(); if (o) { var h = []; var l = o.rotation; var c = o.scaling; var f = o.skewing; s && !s.isZero() && h.push(`translate(` + S.point(s) + `)`), l && h.push(`rotate(` + S.number(l) + `)`), u.isZero(c.x - 1) && u.isZero(c.y - 1) || h.push(`scale(` + S.point(c) + `)`), f.x && h.push(`skewX(` + S.number(f.x) + `)`), f.y && h.push(`skewY(` + S.number(f.y) + `)`), i.transform = h.join(` `) } else { i.transform = `matrix(` + t.getValues().join(`,`) + `)` } } return i } function n (t, n) { for (var i = e(t._matrix), r = t._children, s = nt.create(`g`, i, S), a = 0, o = r.length; a < o; a++) { var h = r[a]; var u = b(h, n); if (u) { if (h.isClipMask()) { var l = nt.create(`clipPath`); l.appendChild(u), m(h, l, `clip`), nt.set(s, { 'clip-path': `url(#` + l.id + `)` }) } else { s.appendChild(u) } } } return s } function i (t, n) { var i = e(t._matrix, !0); var r = t.getSize(); var s = t.getImage(); return i.x -= r.width / 2, i.y -= r.height / 2, i.width = r.width, i.height = r.height, i.href = n.embedImages == 0 && s && s.src || t.toDataURL(), nt.create(`image`, i, S) } function s (t, n) { var i = n.matchShapes; if (i) { var r = t.toShape(!1); if (r) { return a(r, n) } } var s; var o = t._segments; var h = o.length; var u = e(t._matrix); if (i && h >= 2 && !t.hasHandles()) { if (h > 2) { s = t._closed ? `polygon` : `polyline`; for (var l = [], c = 0; c < h; c++) { l.push(S.point(o[c]._point)) }u.points = l.join(` `) } else { s = `line`; var f = o[0]._point; var d = o[1]._point; u.set({ x1: f.x, y1: f.y, x2: d.x, y2: d.y }) } } else { s = `path`, u.d = t.getPathData(null, n.precision) } return nt.create(s, u, S) } function a (t) {
      var n = t._type; var i = t._radius; var r = e(t._matrix, !0, n !== `rectangle`); if (n === `rectangle`) {
        n = `rect`; var s = t._size; var a = s.width; var o = s.height; r.x -= a / 2, r.y -= o / 2, r.width = a, r.height = o, i.isZero() && (i = null)
      } return i && (n === `circle` ? r.r = i : (r.rx = i.width, r.ry = i.height)), nt.create(n, r, S)
    } function o (t, n) { var i = e(t._matrix); var r = t.getPathData(null, n.precision); return r && (i.d = r), nt.create(`path`, i, S) } function c (t, n) { var i = e(t._matrix, !0); var r = t._definition; var s = v(r, `symbol`); var a = r._item; var o = a.getBounds(); return s || (s = nt.create(`symbol`, { viewBox: S.rectangle(o) }), s.appendChild(b(a, n)), m(r, s, `symbol`)), i.href = `#` + s.id, i.x += o.x, i.y += o.y, i.width = o.width, i.height = o.height, i.overflow = `visible`, nt.create(`use`, i, S) } function f (t) { var e = v(t, `color`); if (!e) { var n; var i = t.getGradient(); var r = i._radial; var s = t.getOrigin(); var a = t.getDestination(); if (r) { n = { cx: s.x, cy: s.y, r: s.getDistance(a) }; var o = t.getHighlight(); o && (n.fx = o.x, n.fy = o.y) } else { n = { x1: s.x, y1: s.y, x2: a.x, y2: a.y } }n.gradientUnits = `userSpaceOnUse`, e = nt.create((r ? `radial` : `linear`) + `Gradient`, n, S); for (var h = i._stops, u = 0, l = h.length; u < l; u++) { var c = h[u]; var f = c._color; var d = f.getAlpha(); var _ = c._offset; n = { offset: _ == null ? u / (l - 1) : _ }, f && (n[`stop-color`] = f.toCSS(!0)), d < 1 && (n[`stop-opacity`] = d), e.appendChild(nt.create(`stop`, n, S)) }m(t, e, `color`) } return `url(#` + e.id + `)` } function d (t) { var n = nt.create(`text`, e(t._matrix, !0), S); return n.textContent = t._content, n } function _ (t, e, n) { var i = {}; var s = !n && t.getParent(); var a = []; return t._name != null && (i.id = t._name), r.each(it, (e) => { var n = e.get; var o = e.type; var h = t[n](); if (e.exportFilter ? e.exportFilter(t, h) : !s || !r.equals(s[n](), h)) { if (o === `color` && h != null) { var u = h.getAlpha(); u < 1 && (i[e.attribute + `-opacity`] = u) }o === `style` ? a.push(e.attribute + `: ` + h) : i[e.attribute] = h == null ? `none` : o === `color` ? h.gradient ? f(h, t) : h.toCSS(!0) : o === `array` ? h.join(`,`) : o === `lookup` ? e.toSVG[h] : h } }), a.length && (i.style = a.join(`;`)), i.opacity === 1 && delete i.opacity, t._visible || (i.visibility = `hidden`), nt.set(e, i, S) } function v (t, e) { return k || (k = { ids: {}, svgs: {} }), t && k.svgs[e + `-` + (t._id || t.__id || (t.__id = l.get(`svg`)))] } function m (t, e, n) { k || v(); var i = k.ids[n] = (k.ids[n] || 0) + 1; e.id = n + `-` + i, k.svgs[n + `-` + (t._id || t.__id)] = e } function x (e, n) { var i = e; var r = null; if (k) { i = e.nodeName.toLowerCase() === `svg` && e; for (var s in k.svgs) { r || (i || (i = nt.create(`svg`), i.appendChild(e)), r = i.insertBefore(nt.create(`defs`), i.firstChild)), r.appendChild(k.svgs[s]) }k = null } return n.asString ? (new t.XMLSerializer()).serializeToString(i) : i } function b (t, e, n) { var i = I[t._class]; var r = i && i(t, e); if (r) { var s = e.onExport; s && (r = s(t, r, e) || r); var a = JSON.stringify(t._data); a && a !== `{}` && a !== `null` && r.setAttribute(`data-paper-data`, a) } return r && _(t, r, n) } function C (t) { return t || (t = {}), S = new h(t.precision), t } var S; var k; var I = { Group: n, Layer: n, Raster: i, Path: s, Shape: a, CompoundPath: o, SymbolItem: c, PointText: d }; w.inject({ exportSVG: function (t) { return t = C(t), x(b(this, t, !0), t) } }), y.inject({ exportSVG: function (t) { t = C(t); var n = this._children; var i = this.getView(); var s = r.pick(t.bounds, `view`); var a = t.matrix || s === `view` && i._matrix; var o = a && p.read([a]); var h = s === `view` ? new g([0, 0], i.getViewSize()) : s === `content` ? w._getBounds(n, o, { stroke: !0 }).rect : g.read([s], 0, { readNull: !0 }); var u = { version: `1.1`, xmlns: nt.svg, 'xmlns:xlink': nt.xlink }; h && (u.width = h.width, u.height = h.height, (h.x || h.y) && (u.viewBox = S.rectangle(h))); var l = nt.create(`svg`, u, S); var c = l; o && !o.isIdentity() && (c = l.appendChild(nt.create(`g`, e(o), S))); for (var f = 0, d = n.length; f < d; f++) { c.appendChild(b(n[f], t, !0)) } return x(l, t) } })
  }(), new function () { function s (t, e, n, i, r) { var s = nt.get(t, e); var a = s == null ? i ? null : n ? `` : 0 : n ? s : parseFloat(s); return /%\s*$/.test(s) ? a / 100 * (r ? 1 : A[/x|^width/.test(e) ? `width` : `height`]) : a } function a (t, e, n, i, r) { return e = s(t, e || `x`, !1, i, r), n = s(t, n || `y`, !1, i, r), !i || e != null && n != null ? new c(e, n) : null } function o (t, e, n, i, r) { return e = s(t, e || `width`, !1, i, r), n = s(t, n || `height`, !1, i, r), !i || e != null && n != null ? new d(e, n) : null } function h (t, e, n) { return t === `none` ? null : e === `number` ? parseFloat(t) : e === `array` ? t ? t.split(/[\s,]+/g).map(parseFloat) : [] : e === `color` ? P(t) || t : e === `lookup` ? n[t] : t } function u (t, e, n, i) { var r = t.childNodes; var s = e === `clippath`; var a = e === `defs`; var o = new x(); var h = o._project; var u = h._currentStyle; var l = []; if (s || a || (o = k(o, t, i), h._currentStyle = o._style.clone()), i) { for (var c = t.querySelectorAll(`defs`), f = 0, d = c.length; f < d; f++) { M(c[f], n, !1) } } for (var f = 0, d = r.length; f < d; f++) { var _; var g = r[f]; g.nodeType !== 1 || /^defs$/i.test(g.nodeName) || !(_ = M(g, n, !1)) || _ instanceof I || l.push(_) } return o.addChildren(l), s && (o = k(o.reduce(), t, i)), h._currentStyle = u, (s || a) && (o.remove(), o = null), o } function l (t, e) { for (var n = t.getAttribute(`points`).match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), i = [], r = 0, s = n.length; r < s; r += 2) { i.push(new c(parseFloat(n[r]), parseFloat(n[r + 1]))) } var a = new L(i); return e === `polygon` && a.closePath(), a } function f (t) { return O.create(t.getAttribute(`d`)) } function _ (t, e) { var n; var i = (s(t, `href`, !0) || ``).substring(1); var r = e === `radialgradient`; if (i) { n = z[i].getGradient(), n._radial ^ r && (n = n.clone(), n._radial = r) } else { for (var o = t.childNodes, h = [], u = 0, l = o.length; u < l; u++) { var c = o[u]; c.nodeType === 1 && h.push(k(new q(), c)) }n = new R(h, r) } var f; var d; var _; var g = s(t, `gradientUnits`, !0) !== `userSpaceOnUse`; r ? (f = a(t, `cx`, `cy`, !1, g), d = f.add(s(t, `r`, !1, !1, g), 0), _ = a(t, `fx`, `fy`, !0, g)) : (f = a(t, `x1`, `y1`, !1, g), d = a(t, `x2`, `y2`, !1, g)); var v = k(new D(n, f, d, _), t); return v._scaleToBounds = g, null } function v (t, e, n, i) { if (t.transform) { for (var r = (i.getAttribute(n) || ``).split(/\)\s*/g), s = new p(), a = 0, o = r.length; a < o; a++) { var h = r[a]; if (!h) { break } for (var u = h.split(/\(\s*/), l = u[0], c = u[1].split(/[\s,]+/g), f = 0, d = c.length; f < d; f++) { c[f] = parseFloat(c[f]) } switch (l) { case `matrix`:s.append(new p(c[0], c[1], c[2], c[3], c[4], c[5])); break; case `rotate`:s.rotate(c[0], c[1] || 0, c[2] || 0); break; case `translate`:s.translate(c[0], c[1] || 0); break; case `scale`:s.scale(c); break; case `skewX`:s.skew(c[0], 0); break; case `skewY`:s.skew(0, c[0]) } }t.transform(s) } } function m (t, e, n) { var i = n === `fill-opacity` ? `getFillColor` : `getStrokeColor`; var r = t[i] && t[i](); r && r.setAlpha(parseFloat(e)) } function b (t, n, i) { var s = t.attributes[n]; var a = s && s.value; if (!a && t.style) { var o = r.camelize(n); a = t.style[o], a || i.node[o] === i.parent[o] || (a = i.node[o]) } return a ? a === `none` ? null : a : e } function k (t, n, i) { var s = n.parentNode; var a = { node: U.getStyles(n) || {}, parent: !i && !/^defs$/i.test(s.tagName) && U.getStyles(s) || {} }; return r.each(N, (i, r) => { var s = b(n, r, a); t = s !== e && i(t, s, r, n, a) || t }), t } function P (t) { var e = t && t.match(/\((?:["'#]*)([^"')]+)/); var i = e && e[1]; var r = i && z[n ? i.replace(n.location.href.split(`#`)[0] + `#`, ``) : i]; return r && r._scaleToBounds && (r = r.clone(), r._scaleToBounds = !0), r } function M (t, e, n) { var s; var a; var h; var u = t.nodeName.toLowerCase(); var l = u !== `#document`; var c = i.body; n && l && (A = rt.getView().getSize(), A = o(t, null, null, !0) || A, s = nt.create(`svg`, { style: `stroke-width: 1px; stroke-miterlimit: 10` }), a = t.parentNode, h = t.nextSibling, s.appendChild(t), c.appendChild(s)); var f = rt.settings; var d = f.applyMatrix; var _ = f.insertItems; f.applyMatrix = !1, f.insertItems = !1; var g = E[u]; var v = g && g(t, u, e, n) || null; if (f.insertItems = _, f.applyMatrix = d, v) { !l || v instanceof x || (v = k(v, t, n)); var p = e.onImport; var m = l && t.getAttribute(`data-paper-data`); p && (v = p(t, v, e) || v), e.expandShapes && v instanceof C && (v.remove(), v = v.toPath()), m && (v._data = JSON.parse(m)) } return s && (c.removeChild(s), a && (h ? a.insertBefore(t, h) : a.appendChild(t))), n && (z = {}, v && r.pick(e.applyMatrix, d) && v.matrix.apply(!0, !0)), v } function T (n, r, s) { function a (i) { try { var a = typeof i === `object` ? i : (new t.DOMParser()).parseFromString(i, `image/svg+xml`); if (!a.nodeName) { throw a = null, new Error(`Unsupported SVG source: ` + n) }rt = h, u = M(a, r, !0), r && r.insert === !1 || s._insertItem(e, u); var l = r.onLoad; l && l(u, i) } catch (c) { o(c) } } function o (t, e) { var n = r.onError; if (!n) { throw new Error(t) }n(t, e) } if (!n) { return null }r = typeof r === `function` ? { onLoad: r } : r || {}; var h = rt; var u = null; if (typeof n !== `string` || /^.*</.test(n)) { if (typeof File !== `undefined` && n instanceof File) { var l = new FileReader(); return l.onload = function () { a(l.result) }, l.onerror = function () { o(l.error) }, l.readAsText(n) }a(n) } else { var c = i.getElementById(n); c ? a(c) : Q.request({ url: n, async: !0, onLoad: a, onError: o }) } return u } var A; var z = {}; var E = { '#document': function (t, e, n, i) { for (var r = t.childNodes, s = 0, a = r.length; s < a; s++) { var o = r[s]; if (o.nodeType === 1) { return M(o, n, i) } } }, g: u, svg: u, clippath: u, polygon: l, polyline: l, path: f, lineargradient: _, radialgradient: _, image: function (t) { var e = new S(s(t, `href`, !0)); return e.on(`load`, function () { var e = o(t); this.setSize(e); var n = a(t).add(e.divide(2)); this._matrix.append((new p()).translate(n)) }), e }, symbol: function (t, e, n, i) { return new I(u(t, e, n, i), (!0)) }, defs: u, use: function (t) { var e = (s(t, `href`, !0) || ``).substring(1); var n = z[e]; var i = a(t); return n ? n instanceof I ? n.place(i) : n.clone().translate(i) : null }, circle: function (t) { return new C.Circle(a(t, `cx`, `cy`), s(t, `r`)) }, ellipse: function (t) { return new C.Ellipse({ center: a(t, `cx`, `cy`), radius: o(t, `rx`, `ry`) }) }, rect: function (t) { return new C.Rectangle(new g(a(t), o(t)), o(t, `rx`, `ry`)) }, line: function (t) { return new L.Line(a(t, `x1`, `y1`), a(t, `x2`, `y2`)) }, text: function (t) { var e = new j(a(t).add(a(t, `dx`, `dy`))); return e.setContent(t.textContent.trim() || ``), e } }; var N = r.set(r.each(it, function (t) { this[t.attribute] = function (e, n) { if (e[t.set] && (e[t.set](h(n, t.type, t.fromSVG)), t.type === `color`)) { var i = e[t.get](); if (i && i._scaleToBounds) { var r = e.getBounds(); i.transform((new p()).translate(r.getPoint()).scale(r.getSize())) } } } }, {}), { id: function (t, e) { z[e] = t, t.setName && t.setName(e) }, 'clip-path': function (t, e) { var n = P(e); if (n) { if (n = n.clone(), n.setClipMask(!0), !(t instanceof x)) { return new x(n, t) }t.insertChild(0, n) } }, gradientTransform: v, transform: v, 'fill-opacity': m, 'stroke-opacity': m, visibility: function (t, e) { t.setVisible && t.setVisible(e === `visible`) }, display: function (t, e) { t.setVisible && t.setVisible(e !== null) }, 'stop-color': function (t, e) { t.setColor && t.setColor(e) }, 'stop-opacity': function (t, e) { t._color && t._color.setAlpha(parseFloat(e)) }, offset: function (t, e) { if (t.setOffset) { var n = e.match(/(.*)%$/); t.setOffset(n ? n[1] / 100 : parseFloat(e)) } }, viewBox: function (t, e, n, i, r) { var s; var a; var u = new g(h(e, `array`)); var l = o(i, null, null, !0); if (t instanceof x) { var c = l ? l.divide(u.getSize()) : 1; var a = (new p()).scale(c).translate(u.getPoint().negate()); s = t } else { t instanceof I && (l && u.setSize(l), s = t._item) } if (s) { if (b(i, `overflow`, r) !== `visible`) { var f = new C.Rectangle(u); f.setClipMask(!0), s.addChild(f) }a && s.transform(a) } } }); w.inject({ importSVG: function (t, e) { return T(t, e, this) } }), y.inject({ importSVG: function (t, e) { return this.activate(), T(t, e, this) } }) }(), r.exports.PaperScript = (function () {
    function e (t, e) { return (g.acorn || v).parse(t, e) } function s (t, e, n) { var i = w[e]; if (t && t[i]) { var r = t[i](n); return e === `!=` ? !r : r } switch (e) { case `+`:return t + n; case `-`:return t - n; case `*`:return t * n; case `/`:return t / n; case `%`:return t % n; case `==`:return t == n; case `!=`:return t != n } } function o (t, e) { var n = x[t]; if (e && e[n]) { return e[n]() } switch (t) { case `+`:return +e; case `-`:return -e } } function h (r, s) { function a (t) { for (var e = 0, n = d.length; e < n; e++) { var i = d[e]; if (i[0] >= t) { break }t += i[1] } return t } function o (t) { return r.substring(a(t.range[0]), a(t.range[1])) } function h (t, e) { return r.substring(a(t.range[1]), a(e.range[0])) } function u (t, e) { for (var n = a(t.range[0]), i = a(t.range[1]), s = 0, o = d.length - 1; o >= 0; o--) { if (n > d[o][0]) { s = o + 1; break } }d.splice(s, 0, [n, e.length - i + n]), r = r.substring(0, n) + e + r.substring(i) } function l (t, e) { if (t) { for (var n in t) { if (n !== `range` && n !== `loc`) { var i = t[n]; if (Array.isArray(i)) { for (var r = 0, s = i.length; r < s; r++) { l(i[r], t) } } else { i && typeof i === `object` && l(i, t) } } } switch (t.type) { case `UnaryExpression`:if (t.operator in x && t.argument.type !== `Literal`) { var a = o(t.argument); u(t, `$__("` + t.operator + `", ` + a + `)`) } break; case `BinaryExpression`:if (t.operator in w && t.left.type !== `Literal`) { var c = o(t.left); var f = o(t.right); var d = h(t.left, t.right); var _ = t.operator; u(t, `__$__(` + c + `,` + d.replace(new RegExp(`\\` + _), `"` + _ + `"`) + `, ` + f + `)`) } break; case `UpdateExpression`:case `AssignmentExpression`:var g = e && e.type; if (!(g === `ForStatement` || g === `BinaryExpression` && /^[=!<>]/.test(e.operator) || g === `MemberExpression` && e.computed)) { if (t.type === `UpdateExpression`) { var a = o(t.argument); var v = `__$__(` + a + `, "` + t.operator[0] + `", 1)`; var p = a + ` = ` + v; t.prefix || g !== `AssignmentExpression` && g !== `VariableDeclarator` || (o(e.left || e.id) === a && (p = v), p = a + `; ` + p), u(t, p) } else if (/^.=$/.test(t.operator) && t.left.type !== `Literal`) { var c = o(t.left); var f = o(t.right); var v = c + ` = __$__(` + c + `, "` + t.operator[0] + `", ` + f + `)`; u(t, /^\(.*\)$/.test(o(t)) ? `(` + v + `)` : v) } } break; case `ExportDefaultDeclaration`:u({ range: [t.start, t.declaration.start] }, `module.exports = `); break; case `ExportNamedDeclaration`:var m = t.declaration; var y = t.specifiers; if (m) { var b = m.declarations; b && (b.forEach((t) => { u(t, `module.exports.` + o(t)) }), u({ range: [t.start, m.start + m.kind.length] }, ``)) } else if (y) { var C = y.map((t) => { var e = o(t); return `module.exports.` + e + ` = ` + e + `; ` }).join(``); C && u(t, C) } } } } function c (t) { var e = ``; var n = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`; for (t = (Math.abs(t) << 1) + (t < 0 ? 1 : 0); t || !e;) { var i = 31 & t; t >>= 5, t && (i |= 32), e += n[i] } return e } if (!r) { return `` }s = s || {}; var f; var d = []; var _ = s.url || ``; var g = rt.agent; var v = g.versionNumber; var p = !1; var m = s.sourceMaps; var y = s.source || r; var b = /\r\n|\n|\r/gm; var C = s.offset || 0; if (m && (g.chrome && v >= 30 || g.webkit && v >= 537.76 || g.firefox && v >= 23 || g.node)) { if (g.node) { C -= 2 } else if (n && _ && !n.location.href.indexOf(_)) { var S = i.getElementsByTagName(`html`)[0].innerHTML; C = S.substr(0, S.indexOf(r) + 1).match(b).length + 1 }p = C > 0 && !(g.chrome && v >= 36 || g.safari && v >= 600 || g.firefox && v >= 40 || g.node); var k = [`AA` + c(p ? 0 : C) + `A`]; k.length = (r.match(b) || []).length + 1 + (p ? C : 0), f = { version: 3, file: _, names: [], mappings: k.join(`;AACA`), sourceRoot: ``, sources: [_], sourcesContent: [y] } } return l(e(r, { ranges: !0, preserveParens: !0, sourceType: `module` })), f && (p && (r = new Array(C + 1).join(`\n`) + r), /^(inline|both)$/.test(m) && (r += `\n//# sourceMappingURL=data:application/json;base64,` + t.btoa(unescape(encodeURIComponent(JSON.stringify(f))))), r += `\n//# sourceURL=` + (_ || `paperscript`)), { url: _, source: y, code: r, map: f } } function u (t, e, n) { function a (e, n) { for (var i in e) { !n && /^_/.test(i) || !new RegExp(`([\\b\\s\\W]|^)` + i.replace(/\$/g, `\\$`) + `\\b`).test(t) || (g.push(i), v.push(e[i])) } }rt = e; var u; var l = e.getView(); var f = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(t) && !/\bnew\s+Tool\b/.test(t) ? new Y() : null; var d = f ? f._events : []; var _ = [`onFrame`, `onResize`].concat(d); var g = []; var v = []; var p = typeof t === `object` ? t : h(t, n); t = p.code, a({ __$__: s, $__: o, paper: e, view: l, tool: f }, !0), a(e), t = `var module = { exports: {} }; ` + t; var m = r.each(_, function (e) { new RegExp(`\\s+` + e + `\\b`).test(t) && (g.push(e), this.push(`module.exports.` + e + ` = ` + e + `;`)) }, []).join(`\n`); m && (t += `\n` + m), t += `\nreturn module.exports;`; var y = rt.agent; if (i && (y.chrome || y.firefox && y.versionNumber < 40)) { var w = i.createElement(`script`); var x = i.head || i.getElementsByTagName(`head`)[0]; y.firefox && (t = `\n` + t), w.appendChild(i.createTextNode(`document.__paperscript__ = function(` + g + `) {` + t + `\n}`)), x.appendChild(w), u = i.__paperscript__, delete i.__paperscript__, x.removeChild(w) } else { u = Function(g, t) } var m = u && u.apply(e, v); var b = m || {}; return r.each(d, (t) => { var e = b[t]; e && (f[t] = e) }), l && (b.onResize && l.setOnResize(b.onResize), l.emit(`resize`, { size: l.size, delta: new c() }), b.onFrame && l.setOnFrame(b.onFrame), l.requestUpdate()), m } function l (t) { if (/^text\/(?:x-|)paperscript$/.test(t.type) && a.getAttribute(t, `ignore`) !== `true`) { var e = a.getAttribute(t, `canvas`); var n = i.getElementById(e); var r = t.src || t.getAttribute(`data-src`); var s = a.hasAttribute(t, `async`); var o = `data-paper-scope`; if (!n) { throw new Error(`Unable to find canvas with id "` + e + `"`) } var h = a.get(n.getAttribute(o)) || (new a()).setup(n); return n.setAttribute(o, h._id), r ? Q.request({ url: r, async: s, mimeType: `text/plain`, onLoad: function (t) { u(t, h, r) } }) : u(t.innerHTML, h, t.baseURI), t.setAttribute(`data-paper-ignore`, `true`), h } } function f () { r.each(i && i.getElementsByTagName(`script`), l) } function _ (t) { return t ? l(t) : f() } var g = this; var v = g.acorn; if (!v && typeof require !== `undefined`) { try { v = require(`acorn`) } catch (p) {} } if (!v) {
      var m; var y; v = m = y = {}, (function (t, e) { return typeof m === `object` && typeof y === `object` ? e(m) : typeof define === `function` && define.amd ? define([`exports`], e) : void e(t.acorn || (t.acorn = {})) }(this, (t) => {
        'use strict'; function e (t) { ct = t || {}; for (var e in gt) { Object.prototype.hasOwnProperty.call(ct, e) || (ct[e] = gt[e]) }_t = ct.sourceFile || null } function n (t, e) { var n = vt(ft, t); e += ` (` + n.line + `:` + n.column + `)`; var i = new SyntaxError(e); throw i.pos = t, i.loc = n, i.raisedAt = pt, i } function i (t) { function e (t) { if (t.length == 1) { return n += `return str === ` + JSON.stringify(t[0]) + `;` }n += `switch(str){`; for (var e = 0; e < t.length; ++e) { n += `case ` + JSON.stringify(t[e]) + `:` }n += `return true}return false;` }t = t.split(` `); var n = ``; var i = []; t:for (var r = 0; r < t.length; ++r) { for (var s = 0; s < i.length; ++s) { if (i[s][0].length == t[r].length) { i[s].push(t[r]); continue t } }i.push([t[r]]) } if (i.length > 3) { i.sort((t, e) => { return e.length - t.length }), n += `switch(str.length){`; for (var r = 0; r < i.length; ++r) { var a = i[r]; n += `case ` + a[0].length + `:`, e(a) }n += `}` } else { e(t) } return new Function(`str`, n) } function r () { this.line = kt, this.column = pt - It } function s () { kt = 1, pt = It = 0, St = !0, u() } function a (t, e) { yt = pt, ct.locations && (xt = new r()), bt = t, u(), Ct = e, St = t.beforeExpr } function o () { var t = ct.onComment && ct.locations && new r(); var e = pt; var i = ft.indexOf(`*/`, pt += 2); if (i === -1 && n(pt - 2, `Unterminated comment`), pt = i + 2, ct.locations) { Xe.lastIndex = e; for (var s; (s = Xe.exec(ft)) && s.index < pt;) { ++kt, It = s.index + s[0].length } }ct.onComment && ct.onComment(!0, ft.slice(e + 2, i), e, pt, t, ct.locations && new r()) } function h () { for (var t = pt, e = ct.onComment && ct.locations && new r(), n = ft.charCodeAt(pt += 2); pt < dt && n !== 10 && n !== 13 && n !== 8232 && n !== 8233;) { ++pt, n = ft.charCodeAt(pt) }ct.onComment && ct.onComment(!1, ft.slice(t + 2, pt), t, pt, e, ct.locations && new r()) } function u () { for (;pt < dt;) { var t = ft.charCodeAt(pt); if (t === 32) { ++pt } else if (t === 13) { ++pt; var e = ft.charCodeAt(pt); e === 10 && ++pt, ct.locations && (++kt, It = pt) } else if (t === 10 || t === 8232 || t === 8233) { ++pt, ct.locations && (++kt, It = pt) } else if (t > 8 && t < 14) { ++pt } else if (t === 47) { var e = ft.charCodeAt(pt + 1); if (e === 42) { o() } else { if (e !== 47) { break }h() } } else if (t === 160) { ++pt } else { if (!(t >= 5760 && He.test(String.fromCharCode(t)))) { break }++pt } } } function l () { var t = ft.charCodeAt(pt + 1); return t >= 48 && t <= 57 ? S(!0) : (++pt, a(we)) } function c () { var t = ft.charCodeAt(pt + 1); return St ? (++pt, x()) : t === 61 ? w(Se, 2) : w(be, 1) } function f () { var t = ft.charCodeAt(pt + 1); return t === 61 ? w(Se, 2) : w(Be, 1) } function d (t) { var e = ft.charCodeAt(pt + 1); return e === t ? w(t === 124 ? Pe : Me, 2) : e === 61 ? w(Se, 2) : w(t === 124 ? Te : ze, 1) } function _ () { var t = ft.charCodeAt(pt + 1); return t === 61 ? w(Se, 2) : w(Ae, 1) } function g (t) { var e = ft.charCodeAt(pt + 1); return e === t ? e == 45 && ft.charCodeAt(pt + 2) == 62 && Je.test(ft.slice(Mt, pt)) ? (pt += 3, h(), u(), y()) : w(ke, 2) : e === 61 ? w(Se, 2) : w(Ne, 1) } function v (t) { var e = ft.charCodeAt(pt + 1); var n = 1; return e === t ? (n = t === 62 && ft.charCodeAt(pt + 2) === 62 ? 3 : 2, ft.charCodeAt(pt + n) === 61 ? w(Se, n + 1) : w(Ee, n)) : e == 33 && t == 60 && ft.charCodeAt(pt + 2) == 45 && ft.charCodeAt(pt + 3) == 45 ? (pt += 4, h(), u(), y()) : (e === 61 && (n = ft.charCodeAt(pt + 2) === 61 ? 3 : 2), w(Le, n)) } function p (t) { var e = ft.charCodeAt(pt + 1); return e === 61 ? w(Oe, ft.charCodeAt(pt + 2) === 61 ? 3 : 2) : w(t === 61 ? Ce : Ie, 1) } function m (t) { switch (t) { case 46:return l(); case 40:return ++pt, a(ge); case 41:return ++pt, a(ve); case 59:return ++pt, a(me); case 44:return ++pt, a(pe); case 91:return ++pt, a(ce); case 93:return ++pt, a(fe); case 123:return ++pt, a(de); case 125:return ++pt, a(_e); case 58:return ++pt, a(ye); case 63:return ++pt, a(xe); case 48:var e = ft.charCodeAt(pt + 1); if (e === 120 || e === 88) { return C() } case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return S(!1); case 34:case 39:return k(t); case 47:return c(t); case 37:case 42:return f(); case 124:case 38:return d(t); case 94:return _(); case 43:case 45:return g(t); case 60:case 62:return v(t); case 61:case 33:return p(t); case 126:return w(Ie, 1) } return !1 } function y (t) { if (t ? pt = mt + 1 : mt = pt, ct.locations && (wt = new r()), t) { return x() } if (pt >= dt) { return a(jt) } var e = ft.charCodeAt(pt); if (Ke(e) || e === 92) { return M() } var i = m(e); if (i === !1) { var s = String.fromCharCode(e); if (s === `\\` || $e.test(s)) { return M() }n(pt, `Unexpected character '` + s + `'`) } return i } function w (t, e) { var n = ft.slice(pt, pt + e); pt += e, a(t, n) } function x () { for (var t, e, i = ``, r = pt; ;) { pt >= dt && n(r, `Unterminated regular expression`); var s = ft.charAt(pt); if (Je.test(s) && n(r, `Unterminated regular expression`), t) { t = !1 } else { if (s === `[`) { e = !0 } else if (s === `]` && e) { e = !1 } else if (s === `/` && !e) { break }t = s === `\\` }++pt } var i = ft.slice(r, pt); ++pt; var o = P(); o && !/^[gmsiy]*$/.test(o) && n(r, `Invalid regexp flag`); try { var h = new RegExp(i, o) } catch (u) { u instanceof SyntaxError && n(r, u.message), n(u) } return a(Nt, h) } function b (t, e) { for (var n = pt, i = 0, r = 0, s = e == null ? 1 / 0 : e; r < s; ++r) { var a; var o = ft.charCodeAt(pt); if (a = o >= 97 ? o - 97 + 10 : o >= 65 ? o - 65 + 10 : o >= 48 && o <= 57 ? o - 48 : 1 / 0, a >= t) { break }++pt, i = i * t + a } return pt === n || e != null && pt - n !== e ? null : i } function C () { pt += 2; var t = b(16); return t == null && n(mt + 2, `Expected hexadecimal number`), Ke(ft.charCodeAt(pt)) && n(pt, `Identifier directly after number`), a(Et, t) } function S (t) { var e = pt; var i = !1; var r = ft.charCodeAt(pt) === 48; t || b(10) !== null || n(e, `Invalid number`), ft.charCodeAt(pt) === 46 && (++pt, b(10), i = !0); var s = ft.charCodeAt(pt); s !== 69 && s !== 101 || (s = ft.charCodeAt(++pt), s !== 43 && s !== 45 || ++pt, b(10) === null && n(e, `Invalid number`), i = !0), Ke(ft.charCodeAt(pt)) && n(pt, `Identifier directly after number`); var o; var h = ft.slice(e, pt); return i ? o = parseFloat(h) : r && h.length !== 1 ? /[89]/.test(h) || Ot ? n(e, `Invalid number`) : o = parseInt(h, 8) : o = parseInt(h, 10), a(Et, o) } function k (t) { pt++; for (var e = ``; ;) { pt >= dt && n(mt, `Unterminated string constant`); var i = ft.charCodeAt(pt); if (i === t) { return ++pt, a(Bt, e) } if (i === 92) { i = ft.charCodeAt(++pt); var r = /^[0-7]+/.exec(ft.slice(pt, pt + 3)); for (r && (r = r[0]); r && parseInt(r, 8) > 255;) { r = r.slice(0, -1) } if (r === `0` && (r = null), ++pt, r) { Ot && n(pt - 2, `Octal literal in strict mode`), e += String.fromCharCode(parseInt(r, 8)), pt += r.length - 1 } else { switch (i) { case 110:e += `\n`; break; case 114:e += `\r`; break; case 120:e += String.fromCharCode(I(2)); break; case 117:e += String.fromCharCode(I(4)); break; case 85:e += String.fromCharCode(I(8)); break; case 116:e += `\t`; break; case 98:e += `\b`; break; case 118:e += `\x0B`; break; case 102:e += `\f`; break; case 48:e += `\0`; break; case 13:ft.charCodeAt(pt) === 10 && ++pt; case 10:ct.locations && (It = pt, ++kt); break; default:e += String.fromCharCode(i) } } } else { i !== 13 && i !== 10 && i !== 8232 && i !== 8233 || n(mt, `Unterminated string constant`), e += String.fromCharCode(i), ++pt } } } function I (t) { var e = b(16, t); return e === null && n(mt, `Bad character escape sequence`), e } function P () { je = !1; for (var t, e = !0, i = pt; ;) { var r = ft.charCodeAt(pt); if (Ye(r)) { je && (t += ft.charAt(pt)), ++pt } else { if (r !== 92) { break }je || (t = ft.slice(i, pt)), je = !0, ft.charCodeAt(++pt) != 117 && n(pt, `Expecting Unicode escape sequence \\uXXXX`), ++pt; var s = I(4); var a = String.fromCharCode(s); a || n(pt - 1, `Invalid Unicode escape`), (e ? Ke(s) : Ye(s)) || n(pt - 4, `Invalid Unicode escape`), t += a }e = !1 } return je ? t : ft.slice(i, pt) } function M () { var t = P(); var e = Ft; return !je && Ue(t) && (e = le[t]), a(e, t) } function T () { Pt = mt, Mt = yt, Tt = xt, y() } function A (t) { if (Ot = t, pt = mt, ct.locations) { for (;pt < It;) { It = ft.lastIndexOf(`\n`, It - 2) + 1, --kt } }u(), y() } function z () { this.type = null, this.start = mt, this.end = null } function O () { this.start = wt, this.end = null, _t !== null && (this.source = _t) } function L () { var t = new z(); return ct.locations && (t.loc = new O()), ct.directSourceFile && (t.sourceFile = ct.directSourceFile), ct.ranges && (t.range = [mt, 0]), t } function E (t) { var e = new z(); return e.start = t.start, ct.locations && (e.loc = new O(), e.loc.start = t.loc.start), ct.ranges && (e.range = [t.range[0], 0]), e } function N (t, e) { return t.type = e, t.end = Mt, ct.locations && (t.loc.end = Tt), ct.ranges && (t.range[1] = Mt), t } function B (t) { return ct.ecmaVersion >= 5 && t.type === `ExpressionStatement` && t.expression.type === `Literal` && t.expression.value === `use strict` } function F (t) { if (bt === t) { return T(), !0 } } function j () { return !ct.strictSemicolons && (bt === jt || bt === _e || Je.test(ft.slice(Mt, mt))) } function D () { F(me) || j() || q() } function R (t) { bt === t ? T() : q() } function q () { n(mt, `Unexpected token`) } function V (t) { t.type !== `Identifier` && t.type !== `MemberExpression` && n(t.start, `Assigning to rvalue`), Ot && t.type === `Identifier` && Ve(t.name) && n(t.start, `Assigning to ` + t.name + ` in strict mode`) } function U (t) { Pt = Mt = pt, ct.locations && (Tt = new r()), At = Ot = null, zt = [], y(); var e = t || L(); var n = !0; for (t || (e.body = []); bt !== jt;) { var i = H(); e.body.push(i), n && B(i) && A(!0), n = !1 } return N(e, `Program`) } function H () { (bt === be || bt === Se && Ct == `/=`) && y(!0); var t = bt; var e = L(); switch (t) { case Dt:case Vt:T(); var i = t === Dt; F(me) || j() ? e.label = null : bt !== Ft ? q() : (e.label = lt(), D()); for (var r = 0; r < zt.length; ++r) { var s = zt[r]; if (e.label == null || s.name === e.label.name) { if (s.kind != null && (i || s.kind === `loop`)) { break } if (e.label && i) { break } } } return r === zt.length && n(e.start, `Unsyntactic ` + t.keyword), N(e, i ? `BreakStatement` : `ContinueStatement`); case Ut:return T(), D(), N(e, `DebuggerStatement`); case Zt:return T(), zt.push(Qe), e.body = H(), zt.pop(), R(ne), e.test = Z(), D(), N(e, `DoWhileStatement`); case Gt:if (T(), zt.push(Qe), R(ge), bt === me) { return $(e, null) } if (bt === ee) { var a = L(); return T(), J(a, !0), N(a, `VariableDeclaration`), a.declarations.length === 1 && F(ue) ? G(e, a) : $(e, a) } var a = X(!1, !0); return F(ue) ? (V(a), G(e, a)) : $(e, a); case Jt:return T(), ht(e, !0); case Xt:return T(), e.test = Z(), e.consequent = H(), e.alternate = F(Wt) ? H() : null, N(e, `IfStatement`); case Kt:return At || ct.allowReturnOutsideFunction || n(mt, `'return' outside of function`), T(), F(me) || j() ? e.argument = null : (e.argument = X(), D()), N(e, `ReturnStatement`); case Yt:T(), e.discriminant = Z(), e.cases = [], R(de), zt.push(tn); for (var o, h; bt != _e;) { if (bt === Rt || bt === Ht) { var u = bt === Rt; o && N(o, `SwitchCase`), e.cases.push(o = L()), o.consequent = [], T(), u ? o.test = X() : (h && n(Pt, `Multiple default clauses`), h = !0, o.test = null), R(ye) } else { o || q(), o.consequent.push(H()) } } return o && N(o, `SwitchCase`), T(), zt.pop(), N(e, `SwitchStatement`); case Qt:return T(), Je.test(ft.slice(Mt, mt)) && n(Mt, `Illegal newline after throw`), e.argument = X(), D(), N(e, `ThrowStatement`); case te:if (T(), e.block = W(), e.handler = null, bt === qt) { var l = L(); T(), R(ge), l.param = lt(), Ot && Ve(l.param.name) && n(l.param.start, `Binding ` + l.param.name + ` in strict mode`), R(ve), l.guard = null, l.body = W(), e.handler = N(l, `CatchClause`) } return e.guardedHandlers = Lt, e.finalizer = F($t) ? W() : null, e.handler || e.finalizer || n(e.start, `Missing catch or finally clause`), N(e, `TryStatement`); case ee:return T(), J(e), D(), N(e, `VariableDeclaration`); case ne:return T(), e.test = Z(), zt.push(Qe), e.body = H(), zt.pop(), N(e, `WhileStatement`); case ie:return Ot && n(mt, `'with' in strict mode`), T(), e.object = Z(), e.body = H(), N(e, `WithStatement`); case de:return W(); case me:return T(), N(e, `EmptyStatement`); default:var c = Ct; var f = X(); if (t === Ft && f.type === `Identifier` && F(ye)) { for (var r = 0; r < zt.length; ++r) { zt[r].name === c && n(f.start, `Label '` + c + `' is already declared`) } var d = bt.isLoop ? `loop` : bt === Yt ? `switch` : null; return zt.push({ name: c, kind: d }), e.body = H(), zt.pop(), e.label = f, N(e, `LabeledStatement`) } return e.expression = f, D(), N(e, `ExpressionStatement`) } } function Z () { R(ge); var t = X(); return R(ve), t } function W (t) { var e; var n = L(); var i = !0; var r = !1; for (n.body = [], R(de); !F(_e);) { var s = H(); n.body.push(s), i && t && B(s) && (e = r, A(r = !0)), i = !1 } return r && !e && A(!1), N(n, `BlockStatement`) } function $ (t, e) { return t.init = e, R(me), t.test = bt === me ? null : X(), R(me), t.update = bt === ve ? null : X(), R(ve), t.body = H(), zt.pop(), N(t, `ForStatement`) } function G (t, e) { return t.left = e, t.right = X(), R(ve), t.body = H(), zt.pop(), N(t, `ForInStatement`) } function J (t, e) { for (t.declarations = [], t.kind = `var`; ;) { var i = L(); if (i.id = lt(), Ot && Ve(i.id.name) && n(i.id.start, `Binding ` + i.id.name + ` in strict mode`), i.init = F(Ce) ? X(!0, e) : null, t.declarations.push(N(i, `VariableDeclarator`)), !F(pe)) { break } } return t } function X (t, e) { var n = K(e); if (!t && bt === pe) { var i = E(n); for (i.expressions = [n]; F(pe);) { i.expressions.push(K(e)) } return N(i, `SequenceExpression`) } return n } function K (t) { var e = Y(t); if (bt.isAssign) { var n = E(e); return n.operator = Ct, n.left = e, T(), n.right = K(t), V(e), N(n, `AssignmentExpression`) } return e } function Y (t) { var e = Q(t); if (F(xe)) { var n = E(e); return n.test = e, n.consequent = X(!0), R(ye), n.alternate = X(!0, t), N(n, `ConditionalExpression`) } return e } function Q (t) { return tt(et(), -1, t) } function tt (t, e, n) { var i = bt.binop; if (i != null && (!n || bt !== ue) && i > e) { var r = E(t); r.left = t, r.operator = Ct; var s = bt; T(), r.right = tt(et(), i, n); var a = N(r, s === Pe || s === Me ? `LogicalExpression` : `BinaryExpression`); return tt(a, e, n) } return t } function et () { if (bt.prefix) { var t = L(); var e = bt.isUpdate; return t.operator = Ct, t.prefix = !0, St = !0, T(), t.argument = et(), e ? V(t.argument) : Ot && t.operator === `delete` && t.argument.type === `Identifier` && n(t.start, `Deleting local variable in strict mode`), N(t, e ? `UpdateExpression` : `UnaryExpression`) } for (var i = nt(); bt.postfix && !j();) { var t = E(i); t.operator = Ct, t.prefix = !1, t.argument = i, V(i), T(), i = N(t, `UpdateExpression`) } return i } function nt () { return it(rt()) } function it (t, e) { if (F(we)) { var n = E(t); return n.object = t, n.property = lt(!0), n.computed = !1, it(N(n, `MemberExpression`), e) } if (F(ce)) { var n = E(t); return n.object = t, n.property = X(), n.computed = !0, R(fe), it(N(n, `MemberExpression`), e) } if (!e && F(ge)) { var n = E(t); return n.callee = t, n.arguments = ut(ve, !1), it(N(n, `CallExpression`), e) } return t } function rt () { switch (bt) { case se:var t = L(); return T(), N(t, `ThisExpression`); case Ft:return lt(); case Et:case Bt:case Nt:var t = L(); return t.value = Ct, t.raw = ft.slice(mt, yt), T(), N(t, `Literal`); case ae:case oe:case he:var t = L(); return t.value = bt.atomValue, t.raw = bt.keyword, T(), N(t, `Literal`); case ge:var e = wt; var n = mt; T(); var i = X(); return i.start = n, i.end = yt, ct.locations && (i.loc.start = e, i.loc.end = xt), ct.ranges && (i.range = [n, yt]), R(ve), i; case ce:var t = L(); return T(), t.elements = ut(fe, !0, !0), N(t, `ArrayExpression`); case de:return at(); case Jt:var t = L(); return T(), ht(t, !1); case re:return st(); default:q() } } function st () { var t = L(); return T(), t.callee = it(rt(), !0), F(ge) ? t.arguments = ut(ve, !1) : t.arguments = Lt, N(t, `NewExpression`) } function at () { var t = L(); var e = !0; var i = !1; for (t.properties = [], T(); !F(_e);) { if (e) { e = !1 } else if (R(pe), ct.allowTrailingCommas && F(_e)) { break } var r; var s = { key: ot() }; var a = !1; if (F(ye) ? (s.value = X(!0), r = s.kind = `init`) : ct.ecmaVersion >= 5 && s.key.type === `Identifier` && (s.key.name === `get` || s.key.name === `set`) ? (a = i = !0, r = s.kind = s.key.name, s.key = ot(), bt !== ge && q(), s.value = ht(L(), !1)) : q(), s.key.type === `Identifier` && (Ot || i)) { for (var o = 0; o < t.properties.length; ++o) { var h = t.properties[o]; if (h.key.name === s.key.name) { var u = r == h.kind || a && h.kind === `init` || r === `init` && (h.kind === `get` || h.kind === `set`); u && !Ot && r === `init` && h.kind === `init` && (u = !1), u && n(s.key.start, `Redefinition of property`) } } }t.properties.push(s) } return N(t, `ObjectExpression`) } function ot () { return bt === Et || bt === Bt ? rt() : lt(!0) } function ht (t, e) { bt === Ft ? t.id = lt() : e ? q() : t.id = null, t.params = []; var i = !0; for (R(ge); !F(ve);) { i ? i = !1 : R(pe), t.params.push(lt()) } var r = At; var s = zt; if (At = !0, zt = [], t.body = W(!0), At = r, zt = s, Ot || t.body.body.length && B(t.body.body[0])) { for (var a = t.id ? -1 : 0; a < t.params.length; ++a) { var o = a < 0 ? t.id : t.params[a]; if ((qe(o.name) || Ve(o.name)) && n(o.start, `Defining '` + o.name + `' in strict mode`), a >= 0) { for (var h = 0; h < a; ++h) { o.name === t.params[h].name && n(o.start, `Argument name clash in strict mode`) } } } } return N(t, e ? `FunctionDeclaration` : `FunctionExpression`) } function ut (t, e, n) { for (var i = [], r = !0; !F(t);) { if (r) { r = !1 } else if (R(pe), e && ct.allowTrailingCommas && F(t)) { break }n && bt === pe ? i.push(null) : i.push(X(!0)) } return i } function lt (t) { var e = L(); return t && ct.forbidReserved == `everywhere` && (t = !1), bt === Ft ? (!t && (ct.forbidReserved && (ct.ecmaVersion === 3 ? De : Re)(Ct) || Ot && qe(Ct)) && ft.slice(mt, yt).indexOf(`\\`) == -1 && n(mt, `The keyword '` + Ct + `' is reserved`), e.name = Ct) : t && bt.keyword ? e.name = bt.keyword : q(), St = !1, T(), N(e, `Identifier`) }t.version = `0.5.0`; var ct; var ft; var dt; var _t; t.parse = function (t, n) { return ft = String(t), dt = ft.length, e(n), s(), U(ct.program) }; var gt = t.defaultOptions = { ecmaVersion: 5, strictSemicolons: !1, allowTrailingCommas: !0, forbidReserved: !1, allowReturnOutsideFunction: !1, locations: !1, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null }; var vt = t.getLineInfo = function (t, e) { for (var n = 1, i = 0; ;) { Xe.lastIndex = i; var r = Xe.exec(t); if (!(r && r.index < e)) { break }++n, i = r.index + r[0].length } return { line: n, column: e - i } }; t.tokenize = function (t, n) { function i (t) { return Mt = yt, y(t), r.start = mt, r.end = yt, r.startLoc = wt, r.endLoc = xt, r.type = bt, r.value = Ct, r }ft = String(t), dt = ft.length, e(n), s(); var r = {}; return i.jumpTo = function (t, e) { if (pt = t, ct.locations) { kt = 1, It = Xe.lastIndex = 0; for (var n; (n = Xe.exec(ft)) && n.index < t;) { ++kt, It = n.index + n[0].length } }St = e, u() }, i }; var pt; var mt; var yt; var wt; var xt; var bt; var Ct; var St; var kt; var It; var Pt; var Mt; var Tt; var At; var zt; var Ot; var Lt = []; var Et = { type: `num` }; var Nt = { type: `regexp` }; var Bt = { type: `string` }; var Ft = { type: `name` }; var jt = { type: `eof` }; var Dt = { keyword: `break` }; var Rt = { keyword: `case`, beforeExpr: !0 }; var qt = { keyword: `catch` }; var Vt = { keyword: `continue` }; var Ut = { keyword: `debugger` }; var Ht = { keyword: `default` }; var Zt = { keyword: `do`, isLoop: !0 }; var Wt = { keyword: `else`, beforeExpr: !0 }; var $t = { keyword: `finally` }; var Gt = { keyword: `for`, isLoop: !0 }; var Jt = { keyword: `function` }; var Xt = { keyword: `if` }; var Kt = { keyword: `return`, beforeExpr: !0 }; var Yt = { keyword: `switch`
        }; var Qt = { keyword: `throw`, beforeExpr: !0 }; var te = { keyword: `try` }; var ee = { keyword: `var` }; var ne = { keyword: `while`, isLoop: !0 }; var ie = { keyword: `with` }; var re = { keyword: `new`, beforeExpr: !0 }; var se = { keyword: `this` }; var ae = { keyword: `null`, atomValue: null }; var oe = { keyword: `true`, atomValue: !0 }; var he = { keyword: `false`, atomValue: !1 }; var ue = { keyword: `in`, binop: 7, beforeExpr: !0 }; var le = { break: Dt, case: Rt, catch: qt, continue: Vt, debugger: Ut, default: Ht, do: Zt, else: Wt, finally: $t, for: Gt, function: Jt, if: Xt, return: Kt, switch: Yt, throw: Qt, try: te, var: ee, while: ne, with: ie, null: ae, true: oe, false: he, new: re, in: ue, instanceof: { keyword: `instanceof`, binop: 7, beforeExpr: !0 }, this: se, typeof: { keyword: `typeof`, prefix: !0, beforeExpr: !0 }, void: { keyword: `void`, prefix: !0, beforeExpr: !0 }, delete: { keyword: `delete`, prefix: !0, beforeExpr: !0 } }; var ce = { type: `[`, beforeExpr: !0 }; var fe = { type: `]` }; var de = { type: `{`, beforeExpr: !0 }; var _e = { type: `}` }; var ge = { type: `(`, beforeExpr: !0 }; var ve = { type: `)` }; var pe = { type: `,`, beforeExpr: !0 }; var me = { type: `;`, beforeExpr: !0 }; var ye = { type: `:`, beforeExpr: !0 }; var we = { type: `.` }; var xe = { type: `?`, beforeExpr: !0 }; var be = { binop: 10, beforeExpr: !0 }; var Ce = { isAssign: !0, beforeExpr: !0 }; var Se = { isAssign: !0, beforeExpr: !0 }; var ke = { postfix: !0, prefix: !0, isUpdate: !0 }; var Ie = { prefix: !0, beforeExpr: !0 }; var Pe = { binop: 1, beforeExpr: !0 }; var Me = { binop: 2, beforeExpr: !0 }; var Te = { binop: 3, beforeExpr: !0 }; var Ae = { binop: 4, beforeExpr: !0 }; var ze = { binop: 5, beforeExpr: !0 }; var Oe = { binop: 6, beforeExpr: !0 }; var Le = { binop: 7, beforeExpr: !0 }; var Ee = { binop: 8, beforeExpr: !0 }; var Ne = { binop: 9, prefix: !0, beforeExpr: !0 }; var Be = { binop: 10, beforeExpr: !0 }; t.tokTypes = { bracketL: ce, bracketR: fe, braceL: de, braceR: _e, parenL: ge, parenR: ve, comma: pe, semi: me, colon: ye, dot: we, question: xe, slash: be, eq: Ce, name: Ft, eof: jt, num: Et, regexp: Nt, string: Bt }; for (var Fe in le) { t.tokTypes[`_` + Fe] = le[Fe] } var je; var De = i(`abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile`); var Re = i(`class enum extends super const export import`); var qe = i(`implements interface let package private protected public static yield`); var Ve = i(`eval arguments`); var Ue = i(`break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this`); var He = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; var Ze = `\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc`; var We = `\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f`; var $e = new RegExp(`[` + Ze + `]`); var Ge = new RegExp(`[` + Ze + We + `]`); var Je = /[\n\r\u2028\u2029]/; var Xe = /\r\n|[\n\r\u2028\u2029]/g; var Ke = t.isIdentifierStart = function (t) { return t < 65 ? t === 36 : t < 91 || (t < 97 ? t === 95 : t < 123 || t >= 170 && $e.test(String.fromCharCode(t))) }; var Ye = t.isIdentifierChar = function (t) { return t < 48 ? t === 36 : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? t === 95 : t < 123 || t >= 170 && Ge.test(String.fromCharCode(t)))) }; var Qe = { kind: `loop` }; var tn = { kind: `switch` }
      })), v.version || (v = null)
    } var w = { '+': `__add`, '-': `__subtract`, '*': `__multiply`, '/': `__divide`, '%': `__modulo`, '==': `__equals`, '!=': `__equals` }; var x = { '-': `__negate`, '+': `__self` }; var b = r.each([`add`, `subtract`, `multiply`, `divide`, `modulo`, `equals`, `negate`], function (t) { this[`__` + t] = `#` + t }, { __self: function () { return this } }); return c.inject(b), d.inject(b), D.inject(b), n && (i.readyState === `complete` ? setTimeout(f) : H.add(n, { load: f })), { compile: h, execute: u, load: _, parse: e }
  }.call(this)); var rt = new (a.inject(r.exports, { Base: r, Numerical: u, Key: J, DomEvent: H, DomElement: U, document: i, window: n, Symbol: I, PlacedSymbol: k }))(); return rt.agent.node && require(`./node/extend.js`)(rt), typeof define === `function` && define.amd ? define(`paper`, rt) : typeof module === `object` && module && (module.exports = rt), rt
}.call(this, typeof self === `object` ? self : null))
